Feature "AggregationAcceptance": Scenario "Using a optional match after aggregation and before an aggregation"
Feature "AggregationAcceptance": Scenario "Distinct should work with multiple equal grouping keys and only one different"
Feature "AggregationAcceptance": Scenario "percentileDisc on empty data should return null"
Feature "CaseExpression": Scenario "Returning a CASE expression into pattern expression"
Feature "CaseExpression": Scenario "Returning a CASE expression into integer"
Feature "CaseExpression": Scenario "Returning a CASE expression with label predicates"
Feature "CaseExpression": Scenario "Using a CASE expression in a WITH, positive case"
Feature "CaseExpression": Scenario "Using a CASE expression in a WITH, negative case"
Feature "CaseExpression": Scenario "Using a CASE expression with label predicates in a WITH"
Feature "CaseExpression": Scenario "Using a CASE expression in a WHERE, with label predicate"
Feature "CaseExpression": Scenario "Returning a CASE expression with a pattern expression alternative"
Feature "CaseExpression": Scenario "Shorthand case with filter should work as expected"
Feature "ConstraintAcceptance": Scenario "Merge node with prop and label and unique index"
Feature "ConstraintAcceptance": Scenario "Merge node with prop and label and unique index when no match"
Feature "ConstraintAcceptance": Scenario "Merge using unique constraint should update existing node"
Feature "ConstraintAcceptance": Scenario "Merge using unique constraint should create missing node"
Feature "ConstraintAcceptance": Scenario "Should match on merge using multiple unique indexes if only found single node for both indexes"
Feature "ConstraintAcceptance": Scenario "Should match on merge using multiple unique indexes and labels if only found single node for both indexes"
Feature "ConstraintAcceptance": Scenario "Should match on merge using multiple unique indexes using same key if only found single node for both indexes"
Feature "ConstraintAcceptance": Scenario "Should create on merge using multiple unique indexes if found no nodes"
Feature "ConstraintAcceptance": Scenario "Should create on merge using multiple unique indexes and labels if found no nodes"
Feature "ConstraintAcceptance": Scenario "Should fail on merge using multiple unique indexes using same key if found different nodes"
Feature "ConstraintAcceptance": Scenario "Should fail on merge using multiple unique indexes if found different nodes"
Feature "ConstraintAcceptance": Scenario "Should fail on merge using multiple unique indexes if it found a node matching single property only"
Feature "ConstraintAcceptance": Scenario "Should fail on merge using multiple unique indexes if it found a node matching single property only flipped order"
Feature "ConstraintAcceptance": Scenario "Should fail on merge using multiple unique indexes and labels if found different nodes"
Feature "ConstraintAcceptance": Scenario "Merge with uniqueness constraints must properly handle multiple labels"
Feature "ConstraintAcceptance": Scenario "Unrelated nodes with same property should not clash"
Feature "ConstraintAcceptance": Scenario "Works fine with index and constraint"
Feature "ConstraintAcceptance": Scenario "Works with property repeated in literal map in set"
Feature "ConstraintAcceptance": Scenario "Works with property in map that gets set"
Feature "ConstraintAcceptance": Scenario "Failing when creation would violate constraint"
Feature "DeleteAcceptance": Scenario "Return properties from deleted node"
Feature "ExplainAcceptance": Scenario "Explanation of in-query procedure call"
Feature "ForeachAcceptance": Scenario "Add labels inside FOREACH"
Feature "ForeachAcceptance": Scenario "Merging inside a FOREACH using a previously matched node"
Feature "ForeachAcceptance": Scenario "Merging inside a FOREACH using a previously matched node and a previously merged node"
Feature "ForeachAcceptance": Scenario "Merging inside a FOREACH using two previously merged nodes"
Feature "ForeachAcceptance": Scenario "Merging inside a FOREACH using two previously merged nodes that also depend on WITH"
Feature "ForeachAcceptance": Scenario "Inside nested FOREACH"
Feature "ForeachAcceptance": Scenario "Inside nested FOREACH, nodes inlined"
Feature "ForeachAcceptance": Scenario "Should handle running merge inside a foreach loop"
Feature "ForeachAcceptance": Scenario "Merge inside foreach should see variables introduced by update actions outside foreach"
Feature "IndexAcceptance": Scenario "Works fine with index"
Feature "IndexAcceptance": Scenario "Works with indexed and unindexed property"
Feature "IndexAcceptance": Scenario "Works with two indexed properties"
Feature "IndexAcceptance": Scenario "Should be able to merge using property from match with index"
Feature "IndexAcceptance": Scenario "Merge with an index must properly handle multiple labels"
Feature "IndexAcceptance": Scenario "Should allow AND and OR with index and equality predicates"
Feature "IndexAcceptance": Scenario "Should allow AND and OR with index and inequality predicates"
Feature "IndexAcceptance": Scenario "Should allow AND and OR with index and STARTS WITH predicates"
Feature "IndexAcceptance": Scenario "Should allow AND and OR with index and regex predicates"
Feature "IndexAcceptance": Scenario "Should allow OR with index and regex predicates"
Feature "MatchAcceptance": Scenario "Filter on path nodes"
Feature "MatchAcceptance": Scenario "Filter with AND/OR"
Feature "MatchAcceptance": Scenario "difficult to plan query number 1"
Feature "MatchAcceptance": Scenario "difficult to plan query number 2"
Feature "MatchAcceptance": Scenario "difficult to plan query number 3"
Feature "MatchAcceptance": Scenario "Variable length path with both sides already bound"
Feature "MatchAcceptance": Scenario "Should handle EXISTS on node property when node is null"
Feature "MatchAcceptance": Scenario "Should handle NOT EXISTS on node property when node is null"
Feature "MatchAcceptance": Scenario "Should handle simple IS NOT NULL on node property when node is null"
Feature "MatchAcceptance": Scenario "Should handle complex IS NOT NULL on node property when node is null"
Feature "MergeLegacyAcceptance": Scenario "Using a single bound node"
Feature "MergeLegacyAcceptance": Scenario "Using a longer pattern"
Feature "MergeLegacyAcceptance": Scenario "Using bound nodes in mid-pattern"
Feature "MergeLegacyAcceptance": Scenario "Using bound nodes in mid-pattern when pattern partly matches"
Feature "MergeLegacyAcceptance": Scenario "Introduce named paths"
Feature "MergeLegacyAcceptance": Scenario "Unbound pattern"
Feature "OptionalMatchAcceptance": Scenario "Id on null"
Feature "OptionalMatchAcceptance": Scenario "type on null"
Feature "OptionalMatchAcceptance": Scenario "optional equality with boolean lists"
Feature "OrderByAcceptance": Scenario "ORDER BY nodes should return null results last in ascending order"
Feature "OrderByAcceptance": Scenario "ORDER BY relationships should return null results last in ascending order"
Feature "PatternExpressionAcceptance": Scenario "Returning an `extract()` expression"
Feature "PatternExpressionAcceptance": Scenario "Using an `extract()` expression in a WITH"
Feature "PatternExpressionAcceptance": Scenario "Using an `extract()` expression in a WHERE"
Feature "PatternExpressionAcceptance": Scenario "Using a pattern expression and a CASE expression in a WHERE"
Feature "PatternExpressionAcceptance": Scenario "Pattern expressions and ORDER BY"
Feature "PatternExpressionAcceptance": Scenario "Returning a pattern expression"
Feature "PatternExpressionAcceptance": Scenario "Returning a pattern expression with label predicate"
Feature "PatternExpressionAcceptance": Scenario "Returning a pattern expression with bound nodes"
Feature "PatternExpressionAcceptance": Scenario "Using a pattern expression in a WITH"
Feature "PatternExpressionAcceptance": Scenario "Using a variable-length pattern expression in a WITH"
Feature "PatternExpressionAcceptance": Scenario "Using pattern expression in RETURN"
Feature "PatternExpressionAcceptance": Scenario "Aggregating on pattern expression"
Feature "PatternExpressionAcceptance": Scenario "Pattern expression inside list comprehension"
Feature "PatternExpressionAcceptance": Scenario "Nested pattern comprehensions"
Feature "PatternExpressionAcceptance": Scenario "Nested pattern comprehensions 2"
Feature "PatternExpressionAcceptance": Scenario "Nested pattern comprehensions 3"
Feature "PatternExpressionAcceptance": Scenario "Nested pattern comprehensions 4"
Feature "PatternExpressionAcceptance": Scenario "Nested pattern comprehension with food"
Feature "PatternPredicates": Scenario "Filter relationships with properties using pattern predicate"
Feature "PatternPredicates": Scenario "Filter using negated pattern predicate"
Feature "PatternPredicates": Scenario "Filter using a variable length relationship pattern predicate with properties"
Feature "PatternPredicates": Scenario "Filter using a pattern predicate that is a logical OR between an expression and a subquery"
Feature "PatternPredicates": Scenario "Filter using a pattern predicate that is a logical OR between two expressions and a subquery"
Feature "PatternPredicates": Scenario "Filter using a pattern predicate that is a logical OR between one expression and a negated subquery"
Feature "PatternPredicates": Scenario "Filter using a pattern predicate that is a logical OR between one subquery and a negated subquery"
Feature "PatternPredicates": Scenario "Filter using a pattern predicate that is a logical OR between one negated subquery and a subquery"
Feature "PatternPredicates": Scenario "Filter using a pattern predicate that is a logical OR between two subqueries"
Feature "PatternPredicates": Scenario "Filter using a pattern predicate that is a logical OR between one negated subquery, a subquery, and an equality expression"
Feature "PatternPredicates": Scenario "Filter using a pattern predicate that is a logical OR between one negated subquery, two subqueries, and an equality expression"
Feature "PatternPredicates": Scenario "Filter using a pattern predicate that is a logical OR between one negated subquery, two subqueries, and an equality expression 2"
Feature "PatternPredicates": Scenario "Using a pattern predicate after aggregation 1"
Feature "PatternPredicates": Scenario "Using a pattern predicate after aggregation 2"
Feature "PatternPredicates": Scenario "Returning a relationship from a pattern predicate"
Feature "PatternPredicates": Scenario "Pattern predicate should uphold the relationship uniqueness constraint"
Feature "PatternPredicates": Scenario "Pattern predicates on missing optionally matched nodes should simply evaluate to false"
Feature "PatternPredicates": Scenario "Matching with complex composite pattern predicate"
Feature "PatternPredicates": Scenario "Handling pattern predicates without matches"
Feature "PatternPredicates": Scenario "Handling pattern predicates"
Feature "PatternPredicates": Scenario "Matching named path with variable length pattern and pattern predicates"
Feature "PatternPredicates": Scenario "Undirected NOOP path predicate 1"
Feature "PatternPredicates": Scenario "Undirected NOOP path predicate 2"
Feature "ProcedureCallAcceptance": Scenario "In-query call to procedure that takes no arguments"
Feature "ProcedureCallAcceptance": Scenario "Calling the same procedure twice using the same outputs in each call"
Feature "ProcedureCallAcceptance": Scenario "In-query call to VOID procedure that takes no arguments"
Feature "ProcedureCallAcceptance": Scenario "In-query call to VOID procedure does not consume rows"
Feature "ProcedureCallAcceptance": Scenario "In-query call to procedure with explicit arguments"
Feature "ProcedureCallAcceptance": Scenario "In-query call to procedure with argument of type NUMBER accepts value of type INTEGER"
Feature "ProcedureCallAcceptance": Scenario "In-query call to procedure with argument of type NUMBER accepts value of type FLOAT"
Feature "ProcedureCallAcceptance": Scenario "In-query call to procedure with argument of type FLOAT accepts value of type INTEGER"
Feature "ProcedureCallAcceptance": Scenario "In-query call to procedure with null argument"
Feature "ProcedureCallAcceptance": Scenario "Standalone call to procedure should fail if implicit argument is missing"
Feature "ProcedureCallAcceptance": Scenario "Standalone call to unknown procedure should fail"
Feature "ProcedureCallAcceptance": Scenario "In-query call to unknown procedure should fail"
Feature "ReturnAcceptance": Scenario "Filter should work"
Feature "ReturnAcceptance": Scenario "LIMIT 0 should stop side effects"
Feature "ReturnAcceptance": Scenario "Accessing a non-existing property with string should work"
Feature "ShortestPathAcceptance": Scenario "Find a shortest path among paths that fulfill a predicate on all nodes"
Feature "ShortestPathAcceptance": Scenario "Find a shortest path among paths that fulfill a predicate on all relationships"
Feature "ShortestPathAcceptance": Scenario "Find a shortest path among paths that fulfill a predicate on all relationships 2"
Feature "ShortestPathAcceptance": Scenario "Find a shortest path among paths that fulfill a predicate"
Feature "ShortestPathAcceptance": Scenario "Find a shortest path without loosing context information at runtime"
Feature "ShortestPathAcceptance": Scenario "Find a shortest path in an expression context"
Feature "ShortestPathAcceptance": Scenario "Finds shortest path"
Feature "ShortestPathAcceptance": Scenario "Optionally finds shortest path"
Feature "ShortestPathAcceptance": Scenario "Optionally finds shortest path using previously bound nodes"
Feature "ShortestPathAcceptance": Scenario "Returns null when not finding a shortest path during an OPTIONAL MATCH"
Feature "ShortestPathAcceptance": Scenario "Find relationships of a shortest path"
Feature "ShortestPathAcceptance": Scenario "Find no shortest path when a length limit prunes all candidates"
Feature "ShortestPathAcceptance": Scenario "Find no shortest path when the start node is null"
Feature "ShortestPathAcceptance": Scenario "Find all shortest paths"
Feature "ShortestPathAcceptance": Scenario "Find a combination of a shortest path and a pattern expression"
Feature "SkipLimitAcceptance": Scenario "Negative parameter for LIMIT should not generate errors"
Feature "SkipLimitAcceptance": Scenario "Combining LIMIT and aggregation"
Feature "SkipLimitAcceptance": Scenario "Stand alone limit in the return clause"
Feature "SkipLimitAcceptance": Scenario "Limit in with clause"
Feature "SkipLimitAcceptance": Scenario "Limit before sort"
Feature "SkipLimitAcceptance": Scenario "Limit before top"
Feature "SkipLimitAcceptance": Scenario "Limit before distinct"
Feature "TemporalArithmeticAcceptance": Scenario "Should add or subtract duration to or from date"
Feature "TemporalArithmeticAcceptance": Scenario "Should add or subtract duration to or from local time"
Feature "TemporalArithmeticAcceptance": Scenario "Should add or subtract duration to or from time"
Feature "TemporalArithmeticAcceptance": Scenario "Should add or subtract duration to or from local date time"
Feature "TemporalArithmeticAcceptance": Scenario "Should add or subtract duration to or from date time"
Feature "TemporalCreateAcceptance": Scenario "Should store date"
Feature "TemporalCreateAcceptance": Scenario "Should store local time"
Feature "TemporalCreateAcceptance": Scenario "Should store time"
Feature "TemporalCreateAcceptance": Scenario "Should store local date time"
Feature "TemporalCreateAcceptance": Scenario "Should store date time"
Feature "TemporalCreateAcceptance": Scenario "Should store duration"
Feature "UnwindAcceptance": Scenario "Primitive node type support in list literal"
Feature "UnwindAcceptance": Scenario "Primitive relationship type support in list literal"
Feature "UnwindAcceptance": Scenario "Pattern comprehension in unwind with empty db"
Feature "UnwindAcceptance": Scenario "Pattern comprehension in unwind with hits"
Feature "VarLengthAcceptance": Scenario "Handles checking properties on nodes in path - using in-pattern property value"
Feature "VarLengthAcceptance": Scenario "Handles checking properties on nodes in path - using ALL() function on path node properties"
Feature "VarLengthAcceptance": Scenario "Handles checking properties on nodes in multistep path - using ALL() function on path node properties"
Feature "VarLengthAcceptance": Scenario "Handles checking properties on relationships in path - using in-pattern property value"
Feature "VarLengthAcceptance": Scenario "Handles checking properties on relationships in path - using ALL() function on relationship identifier"
Feature "VarLengthAcceptance": Scenario "Handles checking properties on relationships in path - using ALL() function on path relationship properties"
Feature "VarLengthAcceptance": Scenario "Handles checking properties on relationships in multistep path - using ALL() function on path relationship properties"
