Feature "AggregationAcceptance": Scenario "Using a optional match after aggregation and before an aggregation"
Feature "AggregationAcceptance": Scenario "max() over strings"
Feature "AggregationAcceptance": Scenario "min() over strings"
Feature "AggregationAcceptance": Scenario "max() over integers"
Feature "AggregationAcceptance": Scenario "min() over integers"
Feature "AggregationAcceptance": Scenario "max() over floats"
Feature "AggregationAcceptance": Scenario "min() over floats"
Feature "AggregationAcceptance": Scenario "max() over mixed numeric values"
Feature "AggregationAcceptance": Scenario "min() over mixed numeric values"
Feature "AggregationAcceptance": Scenario "max() over mixed values"
Feature "AggregationAcceptance": Scenario "min() over mixed values"
Feature "AggregationAcceptance": Scenario "max() over list values"
Feature "AggregationAcceptance": Scenario "min() over list values"
Feature "AggregationAcceptance": Scenario "Multiple aggregations should work"
Feature "AggregationAcceptance": Scenario "percentileDisc on empty data should return null"
Feature "BooleanExpression": Scenario "Combining IN predicates intersected with AND"
Feature "BooleanExpression": Scenario "Combining IN predicates intersected with OR"
Feature "CaseExpression": Scenario "Case should handle mixed number types"
Feature "CaseExpression": Scenario "Case should handle mixed types"
Feature "CaseExpression": Scenario "Returning a CASE expression into pattern expression"
Feature "CaseExpression": Scenario "Returning a CASE expression into integer"
Feature "CaseExpression": Scenario "Returning a CASE expression with label predicates"
Feature "CaseExpression": Scenario "Using a CASE expression in a WITH, positive case"
Feature "CaseExpression": Scenario "Using a CASE expression in a WITH, negative case"
Feature "CaseExpression": Scenario "Using a CASE expression with label predicates in a WITH"
Feature "CaseExpression": Scenario "Using a CASE expression in a WHERE, positive case"
Feature "CaseExpression": Scenario "Using a CASE expression in a WHERE, negative case"
Feature "CaseExpression": Scenario "Using a CASE expression in a WHERE, with relationship predicate"
Feature "CaseExpression": Scenario "Using a CASE expression in a WHERE, with label predicate"
Feature "CaseExpression": Scenario "Returning a CASE expression with a pattern expression alternative"
Feature "CaseExpression": Scenario "Shorthand case with filter should work as expected"
Feature "ConstraintAcceptance": Scenario "Merge node with prop and label and unique index"
Feature "ConstraintAcceptance": Scenario "Merge node with prop and label and unique index when no match"
Feature "ConstraintAcceptance": Scenario "Merge using unique constraint should update existing node"
Feature "ConstraintAcceptance": Scenario "Merge using unique constraint should create missing node"
Feature "ConstraintAcceptance": Scenario "Should match on merge using multiple unique indexes if only found single node for both indexes"
Feature "ConstraintAcceptance": Scenario "Should match on merge using multiple unique indexes and labels if only found single node for both indexes"
Feature "ConstraintAcceptance": Scenario "Should match on merge using multiple unique indexes using same key if only found single node for both indexes"
Feature "ConstraintAcceptance": Scenario "Should create on merge using multiple unique indexes if found no nodes"
Feature "ConstraintAcceptance": Scenario "Should create on merge using multiple unique indexes and labels if found no nodes"
Feature "ConstraintAcceptance": Scenario "Should fail on merge using multiple unique indexes using same key if found different nodes"
Feature "ConstraintAcceptance": Scenario "Should fail on merge using multiple unique indexes if found different nodes"
Feature "ConstraintAcceptance": Scenario "Should fail on merge using multiple unique indexes if it found a node matching single property only"
Feature "ConstraintAcceptance": Scenario "Should fail on merge using multiple unique indexes if it found a node matching single property only flipped order"
Feature "ConstraintAcceptance": Scenario "Should fail on merge using multiple unique indexes and labels if found different nodes"
Feature "ConstraintAcceptance": Scenario "Merge with uniqueness constraints must properly handle multiple labels"
Feature "ConstraintAcceptance": Scenario "Unrelated nodes with same property should not clash"
Feature "ConstraintAcceptance": Scenario "Works fine with index and constraint"
Feature "ConstraintAcceptance": Scenario "Works with property repeated in literal map in set"
Feature "ConstraintAcceptance": Scenario "Works with property in map that gets set"
Feature "ConstraintAcceptance": Scenario "Failing when creation would violate constraint"
Feature "DeleteAcceptance": Scenario "Return properties from deleted node"
Feature "ExplainAcceptance": Scenario "Explanation of in-query procedure call"
Feature "ForeachAcceptance": Scenario "Add labels inside FOREACH"
Feature "ForeachAcceptance": Scenario "Merging inside a FOREACH using a previously matched node"
Feature "ForeachAcceptance": Scenario "Merging inside a FOREACH using a previously matched node and a previously merged node"
Feature "ForeachAcceptance": Scenario "Merging inside a FOREACH using two previously merged nodes"
Feature "ForeachAcceptance": Scenario "Merging inside a FOREACH using two previously merged nodes that also depend on WITH"
Feature "ForeachAcceptance": Scenario "Inside nested FOREACH"
Feature "ForeachAcceptance": Scenario "Inside nested FOREACH, nodes inlined"
Feature "ForeachAcceptance": Scenario "Should handle running merge inside a foreach loop"
Feature "ForeachAcceptance": Scenario "Merge inside foreach should see variables introduced by update actions outside foreach"
Feature "IndexAcceptance": Scenario "Handling numerical literal on the left when using an index"
Feature "IndexAcceptance": Scenario "Handling numerical literal on the right when using an index"
Feature "IndexAcceptance": Scenario "Works fine with index"
Feature "IndexAcceptance": Scenario "Works with indexed and unindexed property"
Feature "IndexAcceptance": Scenario "Works with two indexed properties"
Feature "IndexAcceptance": Scenario "Should be able to merge using property from match with index"
Feature "IndexAcceptance": Scenario "Merge with an index must properly handle multiple labels"
Feature "IndexAcceptance": Scenario "Should allow AND and OR with index and equality predicates"
Feature "IndexAcceptance": Scenario "Should allow AND and OR with index and inequality predicates"
Feature "IndexAcceptance": Scenario "Should allow AND and OR with index and STARTS WITH predicates"
Feature "IndexAcceptance": Scenario "Should allow AND and OR with index and regex predicates"
Feature "IndexAcceptance": Scenario "Should allow OR with index and regex predicates"
Feature "IndexAcceptance": Scenario "STARTS WITH should handle null prefix"
Feature "ListComprehensionAcceptance": Scenario "Should find all the variables in list comprehension"
Feature "ListComprehensionAcceptance": Scenario "Should handle list comprehension with AND and one NOT"
Feature "ListComprehensionAcceptance": Scenario "Should handle list comprehension with AND and two NOT"
Feature "ListComprehensionAcceptance": Scenario "Should handle list comprehension with OR and one NOT"
Feature "ListComprehensionAcceptance": Scenario "Should handle list comprehension with OR and two NOT"
Feature "MatchAcceptance": Scenario "Filter on path nodes"
Feature "MatchAcceptance": Scenario "Filter with AND/OR"
Feature "MatchAcceptance": Scenario "Should allow AND and OR with equality predicates"
Feature "MatchAcceptance": Scenario "Should allow AND and OR with inequality predicates"
Feature "MatchAcceptance": Scenario "Should allow AND and OR with STARTS WITH predicates"
Feature "MatchAcceptance": Scenario "Should allow AND and OR with regex predicates"
Feature "MatchAcceptance": Scenario "Should allow OR with regex predicates"
Feature "MatchAcceptance": Scenario "difficult to plan query number 1"
Feature "MatchAcceptance": Scenario "difficult to plan query number 2"
Feature "MatchAcceptance": Scenario "difficult to plan query number 3"
Feature "MatchAcceptance": Scenario "Match on multiple labels with OR"
Feature "MatchAcceptance": Scenario "Variable length path with both sides already bound"
Feature "MatchAcceptance": Scenario "Should handle EXISTS on node property when node is null"
Feature "MatchAcceptance": Scenario "Should handle NOT EXISTS on node property when node is null"
Feature "MatchAcceptance": Scenario "Should handle simple IS NOT NULL on node property when node is null"
Feature "MatchAcceptance": Scenario "Should handle complex IS NOT NULL on node property when node is null"
Feature "MergeLegacyAcceptance": Scenario "Using a single bound node"
Feature "MergeLegacyAcceptance": Scenario "Using a longer pattern"
Feature "MergeLegacyAcceptance": Scenario "Using bound nodes in mid-pattern"
Feature "MergeLegacyAcceptance": Scenario "Using bound nodes in mid-pattern when pattern partly matches"
Feature "MergeLegacyAcceptance": Scenario "Introduce named paths"
Feature "MergeLegacyAcceptance": Scenario "Unbound pattern"
Feature "OperatorChaining": Scenario "Long chains of integer comparisons"
Feature "OperatorChaining": Scenario "Long chains of floating point comparisons"
Feature "OperatorChaining": Scenario "Long chains of string comparisons"
Feature "OptionalMatchAcceptance": Scenario "Id on null"
Feature "OptionalMatchAcceptance": Scenario "type on null"
Feature "OptionalMatchAcceptance": Scenario "optional equality with boolean lists"
Feature "OptionalMatchAcceptance": Scenario "optional match with distinct"
Feature "OptionalMatchAcceptance": Scenario "optional match with OR where clause"
Feature "OrderByAcceptance": Scenario "ORDER BY nodes should return null results last in ascending order"
Feature "OrderByAcceptance": Scenario "ORDER BY relationships should return null results last in ascending order"
Feature "OrderByAcceptance": Scenario "Ordering is well defined across all types, ascending"
Feature "OrderByAcceptance": Scenario "Ordering is well defined across all types, descending"
Feature "OrderByAcceptance": Scenario "Ordering for lists, ascending"
Feature "OrderByAcceptance": Scenario "Ordering for lists, descending"
Feature "PatternExpressionAcceptance": Scenario "Returning an `extract()` expression"
Feature "PatternExpressionAcceptance": Scenario "Using an `extract()` expression in a WITH"
Feature "PatternExpressionAcceptance": Scenario "Using an `extract()` expression in a WHERE"
Feature "PatternExpressionAcceptance": Scenario "Using a pattern expression and a CASE expression in a WHERE"
Feature "PatternExpressionAcceptance": Scenario "Pattern expressions and ORDER BY"
Feature "PatternExpressionAcceptance": Scenario "Returning a pattern expression"
Feature "PatternExpressionAcceptance": Scenario "Returning a pattern expression with label predicate"
Feature "PatternExpressionAcceptance": Scenario "Returning a pattern expression with bound nodes"
Feature "PatternExpressionAcceptance": Scenario "Using a pattern expression in a WITH"
Feature "PatternExpressionAcceptance": Scenario "Using a variable-length pattern expression in a WITH"
Feature "PatternExpressionAcceptance": Scenario "Using pattern expression in RETURN"
Feature "PatternExpressionAcceptance": Scenario "Aggregating on pattern expression"
Feature "PatternExpressionAcceptance": Scenario "Using `length()` on outgoing pattern expression"
Feature "PatternExpressionAcceptance": Scenario "Using `length()` on incoming pattern expression"
Feature "PatternExpressionAcceptance": Scenario "Using `length()` on undirected pattern expression"
Feature "PatternExpressionAcceptance": Scenario "Using `length()` on pattern expression with complex relationship predicate"
Feature "PatternExpressionAcceptance": Scenario "Returning pattern expression in `exists()`"
Feature "PatternExpressionAcceptance": Scenario "Pattern expression inside list comprehension"
Feature "PatternExpressionAcceptance": Scenario "Get node degree via length of pattern expression"
Feature "PatternExpressionAcceptance": Scenario "Get node degree via length of pattern expression that specifies a relationship type"
Feature "PatternExpressionAcceptance": Scenario "Get node degree via length of pattern expression that specifies multiple relationship types"
Feature "PatternExpressionAcceptance": Scenario "Nested pattern comprehensions"
Feature "PatternExpressionAcceptance": Scenario "Nested pattern comprehensions 2"
Feature "PatternExpressionAcceptance": Scenario "Nested pattern comprehensions 3"
Feature "PatternExpressionAcceptance": Scenario "Nested pattern comprehensions 4"
Feature "PatternExpressionAcceptance": Scenario "Nested pattern comprehension with food"
Feature "PatternPredicates": Scenario "Filter relationships with properties using pattern predicate"
Feature "PatternPredicates": Scenario "Filter using negated pattern predicate"
Feature "PatternPredicates": Scenario "Filter using a variable length relationship pattern predicate with properties"
Feature "PatternPredicates": Scenario "Filter using a pattern predicate that is a logical OR between an expression and a subquery"
Feature "PatternPredicates": Scenario "Filter using a pattern predicate that is a logical OR between two expressions and a subquery"
Feature "PatternPredicates": Scenario "Filter using a pattern predicate that is a logical OR between one expression and a negated subquery"
Feature "PatternPredicates": Scenario "Filter using a pattern predicate that is a logical OR between one subquery and a negated subquery"
Feature "PatternPredicates": Scenario "Filter using a pattern predicate that is a logical OR between one negated subquery and a subquery"
Feature "PatternPredicates": Scenario "Filter using a pattern predicate that is a logical OR between two subqueries"
Feature "PatternPredicates": Scenario "Filter using a pattern predicate that is a logical OR between one negated subquery, a subquery, and an equality expression"
Feature "PatternPredicates": Scenario "Filter using a pattern predicate that is a logical OR between one negated subquery, two subqueries, and an equality expression"
Feature "PatternPredicates": Scenario "Filter using a pattern predicate that is a logical OR between one negated subquery, two subqueries, and an equality expression 2"
Feature "PatternPredicates": Scenario "Using a pattern predicate after aggregation 1"
Feature "PatternPredicates": Scenario "Using a pattern predicate after aggregation 2"
Feature "PatternPredicates": Scenario "Returning a relationship from a pattern predicate"
Feature "PatternPredicates": Scenario "Pattern predicate should uphold the relationship uniqueness constraint"
Feature "PatternPredicates": Scenario "Using pattern predicate"
Feature "PatternPredicates": Scenario "Matching using pattern predicate with multiple relationship types"
Feature "PatternPredicates": Scenario "Matching using pattern predicate"
Feature "PatternPredicates": Scenario "Pattern predicates on missing optionally matched nodes should simply evaluate to false"
Feature "PatternPredicates": Scenario "Pattern predicates and parametrised predicate"
Feature "PatternPredicates": Scenario "Matching with complex composite pattern predicate"
Feature "PatternPredicates": Scenario "Handling pattern predicates without matches"
Feature "PatternPredicates": Scenario "Handling pattern predicates"
Feature "PatternPredicates": Scenario "Matching named path with variable length pattern and pattern predicates"
Feature "PatternPredicates": Scenario "Undirected NOOP path predicate 1"
Feature "PatternPredicates": Scenario "Undirected NOOP path predicate 2"
Feature "ProcedureCallAcceptance": Scenario "In-query call to procedure that takes no arguments"
Feature "ProcedureCallAcceptance": Scenario "Calling the same procedure twice using the same outputs in each call"
Feature "ProcedureCallAcceptance": Scenario "In-query call to VOID procedure that takes no arguments"
Feature "ProcedureCallAcceptance": Scenario "In-query call to VOID procedure does not consume rows"
Feature "ProcedureCallAcceptance": Scenario "In-query call to procedure with explicit arguments"
Feature "ProcedureCallAcceptance": Scenario "In-query call to procedure with argument of type NUMBER accepts value of type INTEGER"
Feature "ProcedureCallAcceptance": Scenario "In-query call to procedure with argument of type NUMBER accepts value of type FLOAT"
Feature "ProcedureCallAcceptance": Scenario "In-query call to procedure with argument of type FLOAT accepts value of type INTEGER"
Feature "ProcedureCallAcceptance": Scenario "In-query call to procedure with null argument"
Feature "ProcedureCallAcceptance": Scenario "Standalone call to procedure should fail if implicit argument is missing"
Feature "ReturnAcceptance": Scenario "Filter should work"
Feature "ReturnAcceptance": Scenario "LIMIT 0 should stop side effects"
Feature "ReturnAcceptance": Scenario "Accessing a list with null should return null"
Feature "ReturnAcceptance": Scenario "Accessing a list with null as lower bound should return null"
Feature "ReturnAcceptance": Scenario "Accessing a list with null as upper bound should return null"
Feature "ReturnAcceptance": Scenario "Accessing a map with null should return null"
Feature "ReturnAcceptance": Scenario "Accessing a non-existing property with string should work"
Feature "ReturnAcceptance": Scenario "RETURN true AND list"
Feature "ReturnAcceptance": Scenario "RETURN false OR list"
Feature "ShortestPathAcceptance": Scenario "Find a shortest path among paths that fulfill a predicate on all nodes"
Feature "ShortestPathAcceptance": Scenario "Find a shortest path among paths that fulfill a predicate on all relationships"
Feature "ShortestPathAcceptance": Scenario "Find a shortest path among paths that fulfill a predicate on all relationships 2"
Feature "ShortestPathAcceptance": Scenario "Find a shortest path among paths that fulfill a predicate"
Feature "ShortestPathAcceptance": Scenario "Find a shortest path without loosing context information at runtime"
Feature "ShortestPathAcceptance": Scenario "Find a shortest path in an expression context"
Feature "ShortestPathAcceptance": Scenario "Finds shortest path"
Feature "ShortestPathAcceptance": Scenario "Optionally finds shortest path"
Feature "ShortestPathAcceptance": Scenario "Optionally finds shortest path using previously bound nodes"
Feature "ShortestPathAcceptance": Scenario "Returns null when not finding a shortest path during an OPTIONAL MATCH"
Feature "ShortestPathAcceptance": Scenario "Find relationships of a shortest path"
Feature "ShortestPathAcceptance": Scenario "Find no shortest path when a length limit prunes all candidates"
Feature "ShortestPathAcceptance": Scenario "Find no shortest path when the start node is null"
Feature "ShortestPathAcceptance": Scenario "Find all shortest paths"
Feature "ShortestPathAcceptance": Scenario "Find a combination of a shortest path and a pattern expression"
Feature "ShortestPathAcceptance": Scenario "Find shortest path when there are shorter paths with same start and end node"
Feature "SkipLimitAcceptance": Scenario "Combining LIMIT and aggregation"
Feature "SkipLimitAcceptance": Scenario "Limit before sort"
Feature "SkipLimitAcceptance": Scenario "Limit before top"
Feature "SkipLimitAcceptance": Scenario "Limit before distinct"
Feature "UnwindAcceptance": Scenario "Pattern comprehension in unwind with empty db"
Feature "UnwindAcceptance": Scenario "Pattern comprehension in unwind with hits"
Feature "VarLengthAcceptance": Scenario "Handles checking properties on nodes in path - using in-pattern property value"
Feature "VarLengthAcceptance": Scenario "Handles checking properties on nodes in path - using ALL() function on path node properties"
Feature "VarLengthAcceptance": Scenario "Handles checking properties on nodes in multistep path - using ALL() function on path node properties"
Feature "VarLengthAcceptance": Scenario "Handles checking properties on relationships in path - using in-pattern property value"
Feature "VarLengthAcceptance": Scenario "Handles checking properties on relationships in path - using ALL() function on relationship identifier"
Feature "VarLengthAcceptance": Scenario "Handles checking properties on relationships in path - using ALL() function on path relationship properties"
Feature "VarLengthAcceptance": Scenario "Handles checking properties on relationships in multistep path - using ALL() function on path relationship properties"
