[[query-call]]
= CALL

[abstract]
--
The `CALL` clause is used to call a procedure deployed in the database.
--

Procedures are called using the `CALL` clause.

Each procedure call needs to specify all required procedure arguments.
This may be done either explicitly, by listing them in parenthesis and separated by commas after the procedure name, or implicitly by using available query parameters as procedure call arguments.
The latter form is only available when the whole query consists of a single `CALL` clause (i.e. in a standalone procedure call).

Most procedures return a stream of records with a fixed set of result fields, similar to how running a Cypher query returns a stream of records, too.
The `YIELD` sub clause is used to explicitly select which of these result fields are returned as newly bound variables from the procedure call to the user or for further processing by the remaining query.
Each yielded result field may optionally be renamed using aliasing (i.e. `resultFieldName AS newName`).
All new variables bound by a procedure call are added to the set of variables already bound in the current scope.
It is an error if a procedure call tries to rebind an already bound variable (i.e. a procedure call cannot shadow a variable that is already bound in the current scope).

Inside a larger query, the records returned from a procedure call with explicit `YIELD` may be further filtered using a `WHERE` sub clause followed by a predicate (similar to `WITH ... WHERE ...`).

In a standalone procedure call only, `YIELD` may be omitted.
In this case, all result fields are yielded as newly bound variables from the procedure call to the user or for further processing by the remaining query.

Calling a `VOID` procedures may only have a side effect and will not produce any result records and thus does neither allow nor require the use of `YIELD`.
Calling a `VOID` procedure in the middle of a larger query will simply pass on each input record (i.e. it acts like `WITH *`).

The following examples show how to pass arguments to and how to yield result fields from a procedure call.
All examples use the following procedure:

[snippet,java]
----
component=neo4j-cypher-docs
source=org/neo4j/procedure/example/IndexingProcedure.java
classifier=sources
tag=indexingProcedure
----

[NOTE]
This clause cannot be combined with other clauses.

ifndef::asciidoctor[:leveloffset: 2]

include::call-a-procedure.asciidoc[]

ifndef::asciidoctor[:leveloffset: 2]

include::call-a-procedure-using-a-quoted-namespace-and-name.asciidoc[]

:leveloffset: 2

include::call-a-procedure-with-literal-arguments.asciidoc[]

ifndef::asciidoctor[:leveloffset: 2]

include::call-a-procedure-with-parameter-arguments.asciidoc[]

ifndef::asciidoctor[:leveloffset: 2]

include::call-a-procedure-with-mixed-literal-and-parameter-arguments.asciidoc[]

ifndef::asciidoctor[:leveloffset: 2]

include::call-a-procedure-with-literal-and-default-arguments.asciidoc[]

:leveloffset: 2

include::call-a-procedure-within-a-complex-query.asciidoc[]

ifndef::asciidoctor[:leveloffset: 2]

include::call-a-procedure-and-filter-its-results.asciidoc[]

ifndef::asciidoctor[:leveloffset: 2]

include::call-a-procedure-within-a-complex-query-and-rename-its-outputs.asciidoc[]

