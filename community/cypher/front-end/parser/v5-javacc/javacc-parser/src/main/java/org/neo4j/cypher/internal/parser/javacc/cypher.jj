/*
 * Note: this file has its license header first after PARSER_BEGIN(Cypher).
 * This allows the license header to be automatically added to the generated files.
 */

options {
  LOOKAHEAD = 1;
  CHOICE_AMBIGUITY_CHECK = 2;
  OTHER_AMBIGUITY_CHECK = 1;
  DEBUG_PARSER = false;
  DEBUG_LOOKAHEAD = false;
  DEBUG_TOKEN_MANAGER = false;
  ERROR_REPORTING = true;
  JAVA_UNICODE_ESCAPE = true;
  UNICODE_INPUT = false;
  IGNORE_CASE = false;
  USER_TOKEN_MANAGER = false;
  USER_CHAR_STREAM = true;
  BUILD_PARSER = true;
  BUILD_TOKEN_MANAGER = true;
  SANITY_CHECK = true;
  FORCE_LA_CHECK = false;
  TOKEN_EXTENDS = "WithOffset";
  COMMON_TOKEN_ACTION = true;
}

PARSER_BEGIN(Cypher)

/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [https://neo4j.com]
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.neo4j.cypher.internal.parser.javacc;

import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.Stack;
import org.neo4j.cypher.internal.parser.common.ast.factory.AccessType;
import org.neo4j.cypher.internal.parser.common.ast.factory.ASTExceptionFactory;
import org.neo4j.cypher.internal.ast.factory.ASTFactory;
import org.neo4j.cypher.internal.ast.factory.ASTFactory.StringPos;
import org.neo4j.cypher.internal.parser.common.ast.factory.ActionType;
import org.neo4j.cypher.internal.parser.common.ast.factory.ConstraintType;
import org.neo4j.cypher.internal.parser.common.ast.factory.CallInTxsOnErrorBehaviourType;
import org.neo4j.cypher.internal.parser.common.ast.factory.ConstraintVersion;
import org.neo4j.cypher.internal.parser.common.ast.factory.CreateIndexTypes;
import org.neo4j.cypher.internal.parser.common.ast.factory.HintIndexType;
import org.neo4j.cypher.internal.parser.common.ast.factory.ParameterType;
import org.neo4j.cypher.internal.parser.common.ast.factory.ParserCypherTypeName;
import org.neo4j.cypher.internal.parser.common.ast.factory.ParserNormalForm;
import org.neo4j.cypher.internal.parser.common.ast.factory.ParserTrimSpecification;
import org.neo4j.cypher.internal.parser.common.ast.factory.ScopeType;
import org.neo4j.cypher.internal.parser.common.ast.factory.ShowCommandFilterTypes;
import org.neo4j.cypher.internal.parser.common.ast.factory.SimpleEither;
import org.neo4j.cypher.internal.parser.common.InvalidUnicodeLiteral;
import org.neo4j.cypher.internal.parser.common.deprecation.DeprecatedChars;

public class Cypher<STATEMENTS,
                    STATEMENT,
                    QUERY extends STATEMENT,
                    CLAUSE,
                    FINISH_CLAUSE extends CLAUSE,
                    RETURN_CLAUSE extends CLAUSE,
                    RETURN_ITEM,
                    RETURN_ITEMS,
                    ORDER_ITEM,
                    PATTERN,
                    NODE_PATTERN extends PATTERN_ATOM,
                    REL_PATTERN extends PATTERN_ATOM,
                    PATH_LENGTH,
                    SET_CLAUSE extends CLAUSE,
                    SET_ITEM,
                    REMOVE_ITEM,
                    CALL_RESULT_ITEM,
                    HINT,
                    EXPRESSION,
                    LABEL_EXPRESSION,
                    FUNCTION_INVOCATION extends EXPRESSION,
                    PARAMETER extends EXPRESSION,
                    VARIABLE extends EXPRESSION,
                    PROPERTY extends EXPRESSION,
                    MAP_PROJECTION_ITEM,
                    USE_CLAUSE extends CLAUSE,
                    STATEMENT_WITH_GRAPH extends STATEMENT,
                    ADMINISTRATION_COMMAND extends STATEMENT_WITH_GRAPH,
                    SCHEMA_COMMAND extends STATEMENT_WITH_GRAPH,
                    YIELD extends CLAUSE,
                    WHERE,
                    DATABASE_SCOPE,
                    WAIT_CLAUSE,
                    ADMINISTRATION_ACTION,
                    GRAPH_SCOPE,
                    PRIVILEGE_TYPE,
                    PRIVILEGE_RESOURCE,
                    PRIVILEGE_QUALIFIER,
                    AUTH,
                    AUTH_ATTRIBUTE,
                    SUBQUERY_IN_TRANSACTIONS_PARAMETERS,
                    SUBQUERY_IN_TRANSACTIONS_BATCH_PARAMETERS,
                    SUBQUERY_IN_TRANSACTIONS_CONCURRENCY_PARAMETERS,
                    SUBQUERY_IN_TRANSACTIONS_ERROR_PARAMETERS,
                    SUBQUERY_IN_TRANSACTIONS_REPORT_PARAMETERS,
                    POS,
                    ENTITY_TYPE,
                    PATTERN_QUANTIFIER,
                    PATTERN_ATOM,
                    DATABASE_NAME,
                    PATTERN_SELECTOR,
                    MATCH_MODE,
                    PATTERN_ELEMENT> {

    ASTExceptionFactory exceptionFactory;
    ASTFactory<STATEMENTS,
               STATEMENT,
               QUERY,
               CLAUSE,
               FINISH_CLAUSE,
               RETURN_CLAUSE,
               RETURN_ITEM,
               RETURN_ITEMS,
               ORDER_ITEM,
               PATTERN,
               NODE_PATTERN,
               REL_PATTERN,
               PATH_LENGTH,
               SET_CLAUSE,
               SET_ITEM,
               REMOVE_ITEM,
               CALL_RESULT_ITEM,
               HINT,
               EXPRESSION,
               LABEL_EXPRESSION,
               FUNCTION_INVOCATION,
               PARAMETER,
               VARIABLE,
               PROPERTY,
               MAP_PROJECTION_ITEM,
               USE_CLAUSE,
               STATEMENT_WITH_GRAPH,
               ADMINISTRATION_COMMAND,
               SCHEMA_COMMAND,
               YIELD,
               WHERE,
               DATABASE_SCOPE,
               WAIT_CLAUSE,
               ADMINISTRATION_ACTION,
               GRAPH_SCOPE,
               PRIVILEGE_TYPE,
               PRIVILEGE_RESOURCE,
               PRIVILEGE_QUALIFIER,
               AUTH,
               AUTH_ATTRIBUTE,
               SUBQUERY_IN_TRANSACTIONS_PARAMETERS,
               SUBQUERY_IN_TRANSACTIONS_BATCH_PARAMETERS,
               SUBQUERY_IN_TRANSACTIONS_CONCURRENCY_PARAMETERS,
               SUBQUERY_IN_TRANSACTIONS_ERROR_PARAMETERS,
               SUBQUERY_IN_TRANSACTIONS_REPORT_PARAMETERS,
               POS,
               ENTITY_TYPE,
               PATTERN_QUANTIFIER,
               PATTERN_ATOM,
               DATABASE_NAME,
               PATTERN_SELECTOR,
               MATCH_MODE,
               PATTERN_ELEMENT> astFactory;
    // to distinguish a bar that follows a label expression from the or-operator as part of a label expression, this stack keeps track of the current context
    Stack<ExpectBar> labelExpressionStack = new Stack<>();

    public Cypher(ASTFactory<STATEMENTS,
                             STATEMENT,
                             QUERY,
                             CLAUSE,
                             FINISH_CLAUSE,
                             RETURN_CLAUSE,
                             RETURN_ITEM,
                             RETURN_ITEMS,
                             ORDER_ITEM,
                             PATTERN,
                             NODE_PATTERN,
                             REL_PATTERN,
                             PATH_LENGTH,
                             SET_CLAUSE,
                             SET_ITEM,
                             REMOVE_ITEM,
                             CALL_RESULT_ITEM,
                             HINT,
                             EXPRESSION,
                             LABEL_EXPRESSION,
                             FUNCTION_INVOCATION,
                             PARAMETER,
                             VARIABLE,
                             PROPERTY,
                             MAP_PROJECTION_ITEM,
                             USE_CLAUSE,
                             STATEMENT_WITH_GRAPH,
                             ADMINISTRATION_COMMAND,
                             SCHEMA_COMMAND,
                             YIELD,
                             WHERE,
                             DATABASE_SCOPE,
                             WAIT_CLAUSE,
                             ADMINISTRATION_ACTION,
                             GRAPH_SCOPE,
                             PRIVILEGE_TYPE,
                             PRIVILEGE_RESOURCE,
                             PRIVILEGE_QUALIFIER,
                             AUTH,
                             AUTH_ATTRIBUTE,
                             SUBQUERY_IN_TRANSACTIONS_PARAMETERS,
                             SUBQUERY_IN_TRANSACTIONS_BATCH_PARAMETERS,
                             SUBQUERY_IN_TRANSACTIONS_CONCURRENCY_PARAMETERS,
                             SUBQUERY_IN_TRANSACTIONS_ERROR_PARAMETERS,
                             SUBQUERY_IN_TRANSACTIONS_REPORT_PARAMETERS,
                             POS,
                             ENTITY_TYPE,
                             PATTERN_QUANTIFIER,
                             PATTERN_ATOM,
                             DATABASE_NAME,
                             PATTERN_SELECTOR,
                             MATCH_MODE,
                             PATTERN_ELEMENT> astFactory,
                  ASTExceptionFactory exceptionFactory,
                  CharStream stream) {
        this(stream);
        this.astFactory = astFactory;
        this.exceptionFactory = exceptionFactory;
    }

    private POS pos( Token t )
    {
        return t != null ? astFactory.inputPosition( t.beginOffset, t.beginLine, t.beginColumn ) : null;
    }

    private POS endPos( Token t )
        {
            return t != null ? astFactory.inputPosition( t.endOffset, t.endLine, t.endColumn ) : null;
        }

    private ENTITY_TYPE nodeType()
    {
        return astFactory.nodeType();
    }

    private ENTITY_TYPE relationshipType()
    {
        return astFactory.relationshipType();
    }

    private ENTITY_TYPE nodeOrRelationshipType()
    {
        return astFactory.nodeOrRelationshipType();
    }

    private void assertValidType( Token t, String expected, String actual ) throws Exception
    {
        if ( expected != null && !expected.equals(actual) )
        {
            throw exceptionFactory.syntaxException( new ParseException(
                String.format("Invalid input '%s': expected \"%s\"", t.image, expected ) ), t.beginOffset, t.beginLine, t.beginColumn );
        }
    }

    private void assertNotAlreadySet( Object object, Token token, String errorMessage ) throws Exception
    {
        if ( object != null )
        {
            throw exceptionFactory.syntaxException( new ParseException( errorMessage ), token.beginOffset, token.beginLine, token.beginColumn );
        }
    }
}

PARSER_END(Cypher)

TOKEN_MGR_DECLS :
{
    public void CommonTokenAction( Token t )
    {
        CypherCharStream ccStream = (CypherCharStream) input_stream;
        t.beginOffset = ccStream.getBeginOffset();
        t.endOffset = ccStream.getEndOffset();
    }
}

/*
 * Whitespaces are skipped, and function as a deliminiter.
 * This includes all unicode characters in the categories Zp, Zs, Zl and more selected unicodes as defined in CIP-88 and the GQL standard.
 */
SKIP :
{

    "\u0009"
    | "\n" //can't parse this in unicode
    | "\u000B"
    | "\u000C"
    | "\r" //can't parse this in unicode
    | "\u001C"
    | "\u001D"
    | "\u001E"
    | "\u001F"
    | "\u0020"
    | "\u00A0"
    | "\u1680"
    | "\u2000"
    | "\u2001"
    | "\u2002"
    | "\u2003"
    | "\u2004"
    | "\u2005"
    | "\u2006"
    | "\u2007"
    | "\u2008"
    | "\u2009"
    | "\u200A"
    | "\u2028"
    | "\u2029"
    | "\u202F"
    | "\u205F"
    | "\u3000"
}

/* COMMENTS */

SPECIAL_TOKEN :
{
    < SINGLE_LINE_COMMENT: "//"(~["\n","\r"])* ("\n"|"\r"|"\r\n")? >
}

MORE :
{
    < "/**" ~["/"] > { input_stream.backup( 1 ); } : IN_FORMAL_COMMENT
    | "/*" : IN_MULTI_LINE_COMMENT
}

<IN_FORMAL_COMMENT>
SPECIAL_TOKEN :
{
    < FORMAL_COMMENT: "*/" > : DEFAULT
}

<IN_MULTI_LINE_COMMENT>
SPECIAL_TOKEN :
{
    < MULTI_LINE_COMMENT: "*/" > : DEFAULT
}

<IN_SINGLE_LINE_COMMENT,IN_FORMAL_COMMENT,IN_MULTI_LINE_COMMENT>
MORE :
{
    < ~[] >
}

/* LITERALS */

TOKEN :
{
    < DECIMAL_DOUBLE: ["0"-"9"] ( <INTEGER_PART> )* "." ["0"-"9"] ( <INTEGER_PART> )* ( <DECIMAL_EXPONENT> )? ( <IDENTIFIER> )?
                      | "." ["0"-"9"] ( <INTEGER_PART> )* ( <DECIMAL_EXPONENT> )? ( <IDENTIFIER> )?
                      | ["0"-"9"] ( <INTEGER_PART> )* <DECIMAL_EXPONENT> ( <IDENTIFIER> )? >
    | < UNSIGNED_DECIMAL_INTEGER: ( ( ["1"-"9"] ( <INTEGER_PART> )* ( <PART_LETTER> )* ) | "0" ) > //0 with part letter -> Octal integer?
    | < #DECIMAL_EXPONENT: ["e","E"] ( ["+","-"] )? ( <INTEGER_PART> )+ ( <PART_LETTER> )* >
    | < #INTEGER_PART: ( ("_")? ["0"-"9"] ) >
    | < UNSIGNED_HEX_INTEGER: "0" ["x","X"] ( <PART_LETTER> )* >
    | < UNSIGNED_OCTAL_INTEGER: "0" ( "o" )? ( <PART_LETTER> )* >
}

MORE : { < STRING1_OPEN: "'" > : STRING1 }
<STRING1> MORE: { "\\\\" { image.delete( image.length() - 2, image.length() ); image.append( "\\" ); } }
<STRING1> MORE: { "\\\'" { image.delete( image.length() - 2, image.length() ); image.append( "'" ); } }
<STRING1> MORE: { "\\\"" { image.delete( image.length() - 2, image.length() ); image.append( "\"" ); } }
<STRING1> MORE: { "\\b" { image.delete( image.length() - 2, image.length() ); image.append( "\b" ); } }
<STRING1> MORE: { "\\f" { image.delete( image.length() - 2, image.length() ); image.append( "\f" ); } }
<STRING1> MORE: { "\\n" { image.delete( image.length() - 2, image.length() ); image.append( "\n" ); } }
<STRING1> MORE: { "\\r" { image.delete( image.length() - 2, image.length() ); image.append( "\r" ); } }
<STRING1> MORE: { "\\t" { image.delete( image.length() - 2, image.length() ); image.append( "\t" ); } }
<STRING1> MORE: { "\\u[0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F]" }
<STRING1> MORE: { < ~["'"] > }
<STRING1> TOKEN: { <STRING_LITERAL1: "'"> { matchedToken.image = image.substring( 1, image.length() - 1 ); } : DEFAULT }

MORE : { < STRING2_OPEN: "\"" > : STRING2 }
<STRING2> MORE: { "\\\\" { image.delete( image.length() - 2, image.length() ); image.append( "\\" ); } }
<STRING2> MORE: { "\\\'" { image.delete( image.length() - 2, image.length() ); image.append( "'" ); } }
<STRING2> MORE: { "\\\"" { image.delete( image.length() - 2, image.length() ); image.append( "\"" ); } }
<STRING2> MORE: { "\\b" { image.delete( image.length() - 2, image.length() ); image.append( "\b" ); } }
<STRING2> MORE: { "\\f" { image.delete( image.length() - 2, image.length() ); image.append( "\f" ); } }
<STRING2> MORE: { "\\n" { image.delete( image.length() - 2, image.length() ); image.append( "\n" ); } }
<STRING2> MORE: { "\\r" { image.delete( image.length() - 2, image.length() ); image.append( "\r" ); } }
<STRING2> MORE: { "\\t" { image.delete( image.length() - 2, image.length() ); image.append( "\t" ); } }
<STRING2> MORE: { "\\u[0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F]" }
<STRING2> MORE: { < ~["\""] > }
<STRING2> TOKEN: { <STRING_LITERAL2: "\""> { matchedToken.image = image.substring( 1, image.length() - 1 ); } : DEFAULT }

MORE : { < ESCAPED_SYMBOLIC_NAME_OPEN: "`" > : ESC_SYMB_NAME }
<ESC_SYMB_NAME> MORE: { < ~["`"] > }
<ESC_SYMB_NAME> MORE: { "``" { image.delete( image.length() - 2, image.length() ); image.append( "`" ); } }
<ESC_SYMB_NAME> TOKEN: { <ESCAPED_SYMBOLIC_NAME: "`"> { matchedToken.image = image.substring( 1, image.length() - 1 ); } : DEFAULT }

/**
* add new tokens to SymbolicNameString() if they should be accepted as an identifier as well
* add new tokens to IdentifierTokens.tokens for correct filtering of identifier tokens
*/
TOKEN [IGNORE_CASE] :
{
    < ACCESS: "ACCESS" >
    | < ACTIVE: "ACTIVE" >
    | < ADMIN: "ADMIN" >
    | < ADMINISTRATOR: "ADMINISTRATOR">
    | < ALIAS: "ALIAS" >
    | < ALIASES: "ALIASES" >
    | < ALL_SHORTEST_PATH: "allShortestPaths" >
    | < ALL: "ALL" >
    | < ALTER: "ALTER" >
    | < AND: "AND" >
    | < ANY: "ANY" >
    | < ARRAY: "ARRAY" >
    | < AS: "AS" >
    | < ASC: "ASC" >
    | < ASCENDING: "ASCENDING" >
    | < ASSERT: "ASSERT" >
    | < ASSIGN: "ASSIGN" >
    | < AT: "AT" >
    | < AUTH: "AUTH" >
    | < BAR: "|" >
    | < BINDINGS: "BINDINGS" >
    | < BOOL: "BOOL" >
    | < BOOLEAN: "BOOLEAN" >
    | < BOOSTED: "BOOSTED" >
    | < BOTH: "BOTH" >
    | < BREAK: "BREAK" >
    | < BRIEF: "BRIEF" >
    | < BTREE: "BTREE" >
    | < BUILT: "BUILT" >
    | < BY: "BY" >
    | < CALL: "CALL" >
    | < CASE: "CASE" >
    | < CHANGE: "CHANGE">
    | < CIDR: "CIDR">
    | < COLLECT: "COLLECT">
    | < COLON: ":" >
    | < COLONCOLON: "::" >
    | < COMMA: "," >
    | < COMMAND: "COMMAND">
    | < COMMANDS: "COMMANDS">
    | < COMMIT: "COMMIT" >
    | < COMPOSITE: "COMPOSITE" >
    | < CONCURRENT: "CONCURRENT" >
    | < CONSTRAINT: "CONSTRAINT" >
    | < CONSTRAINTS: "CONSTRAINTS" >
    | < CONTAINS: "CONTAINS" >
    | < COPY: "COPY" >
    | < CONTINUE: "CONTINUE" >
    | < COUNT: "COUNT" >
    | < CREATE: "CREATE" >
    | < CSV: "CSV" >
    | < CURRENT: "CURRENT" >
    | < DATA: "DATA">
    | < DATABASE: "DATABASE">
    | < DATABASES: "DATABASES">
    | < DATE: "DATE">
    | < DATETIME: "DATETIME">
    | < DBMS: "DBMS">
    | < DEALLOCATE: "DEALLOCATE" >
    | < DEFAULT_TOKEN: "DEFAULT">
    | < DEFINED: "DEFINED">
    | < DELETE: "DELETE" >
    | < DENY: "DENY" >
    | < DESC: "DESC" >
    | < DESCENDING: "DESCENDING" >
    | < DESTROY: "DESTROY">
    | < DETACH: "DETACH" >
    | < DOLLAR: "$">
    | < DOUBLEBAR: "||">
    | < DIFFERENT: "DIFFERENT" >
    | < DISTINCT: "DISTINCT" >
    | < DIVIDE: "/" >
    | < DOT: "." >
    | < DOTDOT: ".." >
    | < DRIVER: "DRIVER" >
    | < DROP: "DROP" >
    | < DRYRUN: "DRYRUN" >
    | < DUMP: "DUMP" >
    | < DURATION: "DURATION" >
    | < EACH: "EACH" >
    | < EDGE: "EDGE" >
    | < ENABLE: "ENABLE" >
    | < ELEMENT: "ELEMENT" >
    | < ELEMENTS: "ELEMENTS" >
    | < ELSE: "ELSE" >
    | < ENCRYPTED: "ENCRYPTED" >
    | < END: "END" >
    | < ENDS: "ENDS" >
    | < EQ: "=" >
    | < EXECUTABLE: "EXECUTABLE" >
    | < EXECUTE: "EXECUTE" >
    | < EXIST: "EXIST" >
    | < EXISTENCE: "EXISTENCE" >
    | < EXISTS: "EXISTS" >
    | < ERROR: "ERROR" >
    | < FAIL: "FAIL" >
    | < FALSE: "false" >
    | < FIELDTERMINATOR: "FIELDTERMINATOR" >
    | < FINISH: "FINISH" >
    | < FLOAT: "FLOAT" >
    | < FOR: "FOR" >
    | < FOREACH: "FOREACH" >
    | < FROM: "FROM" >
    | < FULLTEXT: "FULLTEXT" >
    | < FUNCTION: "FUNCTION" >
    | < FUNCTIONS: "FUNCTIONS" >
    | < GE: ">=" >
    | < GRANT: "GRANT">
    | < GRAPH: "GRAPH" >
    | < GRAPHS: "GRAPHS" >
    | < GROUP: "GROUP" >
    | < GROUPS: "GROUPS" >
    | < GT: ">" >
    | < HEADERS: "HEADERS" >
    | < HOME: "HOME">
    | < ID: "ID" >
    | < IF: "IF" >
    | < IMPERSONATE: "IMPERSONATE" >
    | < IMMUTABLE: "IMMUTABLE" >
    | < IN: "IN" >
    | < INDEX: "INDEX" >
    | < INDEXES: "INDEXES" >
    | < INF: "INF" >
    | < INFINITY: "INFINITY" >
    | < INSERT: "INSERT">
    | < INT: "INT" >
    | < INTEGER: "INTEGER" >
    | < IS: "IS" >
    | < JOIN: "JOIN" >
    | < KEY: "KEY" >
    | < LABEL: "LABEL" >
    | < LABELS: "LABELS" >
    | < AMPERSAND: "&" >
    | < EXCLAMATION_MARK: "!" >
    | < LBRACKET: "[" >
    | < LCURLY: "{" >
    | < LE: "<=" >
    | < LEADING: "LEADING" >
    | < LIMITROWS: "LIMIT" >
    | < LIST: "LIST" >
    | < LOAD: "LOAD" >
    | < LOCAL: "LOCAL" >
    | < LOOKUP: "LOOKUP" >
    | < LPAREN: "(" >
    | < LT: "<" >
    | < MANAGEMENT: "MANAGEMENT" >
    | < MAP: "MAP" >
    | < MATCH: "MATCH" >
    | < MERGE: "MERGE" >
    | < MINUS: "-" >
    | < PERCENT: "%" >
    | < NEQ: "!=" >
    | < NEQ2: "<>" >
    | < NAME: "NAME" >
    | < NAMES: "NAMES" >
    | < NAN: "NAN" >
    | < NFC: "NFC" >
    | < NFD: "NFD" >
    | < NFKC: "NFKC" >
    | < NFKD: "NFKD" >
    | < NEW: "NEW" >
    | < NODE: "NODE" >
    | < NODETACH: "NODETACH" >
    | < NODES: "NODES" >
    | < NONE: "NONE" >
    | < NORMALIZE: "NORMALIZE" >
    | < NORMALIZED: "NORMALIZED" >
    | < NOT: "NOT" >
    | < NOTHING: "NOTHING" >
    | < NOWAIT: "NOWAIT">
    | < NULL: "null">
    | < OF: "OF" >
    | < ON: "ON" >
    | < ONLY: "ONLY" >
    | < OPTIONAL: "OPTIONAL" >
    | < OPTIONS: "OPTIONS" >
    | < OPTION: "OPTION" >
    | < OR: "OR" >
    | < ORDER: "ORDER" >
    | < OUTPUT: "OUTPUT" >
    | < PASSWORD: "PASSWORD" >
    | < PASSWORDS: "PASSWORDS" >
    | < PATH: "PATH" >
    | < PATHS: "PATHS" >
    | < PERIODIC: "PERIODIC" >
    | < PLAINTEXT: "PLAINTEXT" >
    | < PLUS: "+" >
    | < PLUSEQUAL: "+=" >
    | < POINT: "POINT">
    | < POPULATED: "POPULATED">
    | < POW: "^" >
    | < REPEATABLE: "REPEATABLE" >
    | < PRIMARY: "PRIMARY" >
    | < PRIMARIES: "PRIMARIES" >
    | < PRIVILEGE: "PRIVILEGE" >
    | < PRIVILEGES: "PRIVILEGES" >
    | < PROCEDURE: "PROCEDURE" >
    | < PROCEDURES: "PROCEDURES" >
    | < PROPERTIES: "PROPERTIES" >
    | < PROPERTY: "PROPERTY" >
    | < PROVIDER: "PROVIDER" >
    | < PROVIDERS: "PROVIDERS" >
    | < QUESTION: "?" >
    | < RANGE: "RANGE" >
    | < RBRACKET: "]" >
    | < RCURLY: "}" >
    | < READ: "READ" >
    | < REALLOCATE: "REALLOCATE" >
    | < REDUCE: "REDUCE" >
    | < RENAME: "RENAME" >
    | < REGEQ: "=~" >
    | < REL: "REL" >
    | < RELATIONSHIP: "RELATIONSHIP" >
    | < RELATIONSHIPS: "RELATIONSHIPS" >
    | < REMOVE: "REMOVE" >
    | < REPLACE: "REPLACE" >
    | < REPORT: "REPORT" >
    | < REQUIRE: "REQUIRE" >
    | < REQUIRED: "REQUIRED" >
    | < RETURN: "RETURN" >
    | < REVOKE: "REVOKE">
    | < ROLE: "ROLE">
    | < ROLES: "ROLES">
    | < ROW: "ROW">
    | < ROWS: "ROWS">
    | < RPAREN: ")" >
    | < SCAN: "SCAN" >
    | < SEC: "SEC">
    | < SECOND: "SECOND">
    | < SECONDARY: "SECONDARY" >
    | < SECONDARIES: "SECONDARIES" >
    | < SECONDS: "SECONDS">
    | < SEEK: "SEEK" >
    | < SEMICOLON: ";" >
    | < SERVER: "SERVER" >
    | < SERVERS: "SERVERS" >
    | < SET: "SET" >
    | < SETTING: "SETTING" >
    | < SETTINGS: "SETTINGS" >
    | < SHORTEST_PATH: "shortestPath" >
    | < SHORTEST: "SHORTEST" >
    | < SHOW: "SHOW">
    | < SIGNED: "SIGNED" >
    | < SINGLE: "SINGLE" >
    | < SKIPROWS: "SKIP" >
    | < START: "START">
    | < STARTS: "STARTS" >
    | < STATUS: "STATUS" >
    | < STOP: "STOP">
    | < STRING: "STRING">
    | < SUPPORTED: "SUPPORTED">
    | < SUSPENDED: "SUSPENDED">
    | < TARGET: "TARGET" >
    | < TERMINATE: "TERMINATE">
    | < TEXT: "TEXT">
    | < THEN: "THEN" >
    | < TIME: "TIME" >
    | < TIMES: "*" >
    | < TIMESTAMP: "TIMESTAMP" >
    | < TIMEZONE: "TIMEZONE" >
    | < TO: "TO" >
    | < TOPOLOGY: "TOPOLOGY" >
    | < TRAILING: "TRAILING" >
    | < TRANSACTION: "TRANSACTION" >
    | < TRANSACTIONS: "TRANSACTIONS" >
    | < TRAVERSE: "TRAVERSE" >
    | < TRIM: "TRIM" >
    | < TRUE: "true">
    | < TYPE: "TYPE">
    | < TYPED: "TYPED">
    | < TYPES: "TYPES">
    | < UNION: "UNION" >
    | < UNIQUE: "UNIQUE" >
    | < UNIQUENESS: "UNIQUENESS" >
    | < UNWIND: "UNWIND" >
    | < URL: "URL" >
    | < USE: "USE" >
    | < USER: "USER">
    | < USERS: "USERS">
    | < USING: "USING" >
    | < VALUE: "VALUE" >
    | < VARCHAR: "VARCHAR" >
    | < VECTOR: "VECTOR" >
    | < VERBOSE: "VERBOSE" >
    | < VERTEX: "VERTEX" >
    | < WAIT: "WAIT">
    | < WHEN: "WHEN" >
    | < WHERE: "WHERE" >
    | < WITH: "WITH" >
    | < WITHOUT: "WITHOUT" >
    | < WRITE: "WRITE" >
    | < XOR: "XOR" >
    | < YIELD: "YIELD" >
    | < ZONED: "ZONED" >
}

/* IDENTIFIERS */

TOKEN :
{
    < IDENTIFIER: <LETTER> (<PART_LETTER>)* >
    | < #LETTER:
        [  // all chars for which Character.isJavaIdentifierStart(c) && Character.getType(c) != Character.CURRENCY_SYMBOL is true (in Java 17)
            "\u0041"-"\u005a",
            "\u005f",
            "\u0061"-"\u007a",
            "\u00aa",
            "\u00b5",
            "\u00ba",
            "\u00c0"-"\u00d6",
            "\u00d8"-"\u00f6",
            "\u00f8"-"\u02c1",
            "\u02c6"-"\u02d1",
            "\u02e0"-"\u02e4",
            "\u02ec",
            "\u02ee",
            "\u0370"-"\u0374",
            "\u0376"-"\u0377",
            "\u037a"-"\u037d",
            "\u037f",
            "\u0386",
            "\u0388"-"\u038a",
            "\u038c",
            "\u038e"-"\u03a1",
            "\u03a3"-"\u03f5",
            "\u03f7"-"\u0481",
            "\u048a"-"\u052f",
            "\u0531"-"\u0556",
            "\u0559",
            "\u0560"-"\u0588",
            "\u05d0"-"\u05ea",
            "\u05ef"-"\u05f2",
            "\u0620"-"\u064a",
            "\u066e"-"\u066f",
            "\u0671"-"\u06d3",
            "\u06d5",
            "\u06e5"-"\u06e6",
            "\u06ee"-"\u06ef",
            "\u06fa"-"\u06fc",
            "\u06ff",
            "\u0710",
            "\u0712"-"\u072f",
            "\u074d"-"\u07a5",
            "\u07b1",
            "\u07ca"-"\u07ea",
            "\u07f4"-"\u07f5",
            "\u07fa",
            "\u0800"-"\u0815",
            "\u081a",
            "\u0824",
            "\u0828",
            "\u0840"-"\u0858",
            "\u0860"-"\u086a",
            "\u08a0"-"\u08b4",
            "\u08b6"-"\u08c7",
            "\u0904"-"\u0939",
            "\u093d",
            "\u0950",
            "\u0958"-"\u0961",
            "\u0971"-"\u0980",
            "\u0985"-"\u098c",
            "\u098f"-"\u0990",
            "\u0993"-"\u09a8",
            "\u09aa"-"\u09b0",
            "\u09b2",
            "\u09b6"-"\u09b9",
            "\u09bd",
            "\u09ce",
            "\u09dc"-"\u09dd",
            "\u09df"-"\u09e1",
            "\u09f0"-"\u09f1",
            "\u09fc",
            "\u0a05"-"\u0a0a",
            "\u0a0f"-"\u0a10",
            "\u0a13"-"\u0a28",
            "\u0a2a"-"\u0a30",
            "\u0a32"-"\u0a33",
            "\u0a35"-"\u0a36",
            "\u0a38"-"\u0a39",
            "\u0a59"-"\u0a5c",
            "\u0a5e",
            "\u0a72"-"\u0a74",
            "\u0a85"-"\u0a8d",
            "\u0a8f"-"\u0a91",
            "\u0a93"-"\u0aa8",
            "\u0aaa"-"\u0ab0",
            "\u0ab2"-"\u0ab3",
            "\u0ab5"-"\u0ab9",
            "\u0abd",
            "\u0ad0",
            "\u0ae0"-"\u0ae1",
            "\u0af9",
            "\u0b05"-"\u0b0c",
            "\u0b0f"-"\u0b10",
            "\u0b13"-"\u0b28",
            "\u0b2a"-"\u0b30",
            "\u0b32"-"\u0b33",
            "\u0b35"-"\u0b39",
            "\u0b3d",
            "\u0b5c"-"\u0b5d",
            "\u0b5f"-"\u0b61",
            "\u0b71",
            "\u0b83",
            "\u0b85"-"\u0b8a",
            "\u0b8e"-"\u0b90",
            "\u0b92"-"\u0b95",
            "\u0b99"-"\u0b9a",
            "\u0b9c",
            "\u0b9e"-"\u0b9f",
            "\u0ba3"-"\u0ba4",
            "\u0ba8"-"\u0baa",
            "\u0bae"-"\u0bb9",
            "\u0bd0",
            "\u0c05"-"\u0c0c",
            "\u0c0e"-"\u0c10",
            "\u0c12"-"\u0c28",
            "\u0c2a"-"\u0c39",
            "\u0c3d",
            "\u0c58"-"\u0c5a",
            "\u0c60"-"\u0c61",
            "\u0c80",
            "\u0c85"-"\u0c8c",
            "\u0c8e"-"\u0c90",
            "\u0c92"-"\u0ca8",
            "\u0caa"-"\u0cb3",
            "\u0cb5"-"\u0cb9",
            "\u0cbd",
            "\u0cde",
            "\u0ce0"-"\u0ce1",
            "\u0cf1"-"\u0cf2",
            "\u0d04"-"\u0d0c",
            "\u0d0e"-"\u0d10",
            "\u0d12"-"\u0d3a",
            "\u0d3d",
            "\u0d4e",
            "\u0d54"-"\u0d56",
            "\u0d5f"-"\u0d61",
            "\u0d7a"-"\u0d7f",
            "\u0d85"-"\u0d96",
            "\u0d9a"-"\u0db1",
            "\u0db3"-"\u0dbb",
            "\u0dbd",
            "\u0dc0"-"\u0dc6",
            "\u0e01"-"\u0e30",
            "\u0e32"-"\u0e33",
            "\u0e40"-"\u0e46",
            "\u0e81"-"\u0e82",
            "\u0e84",
            "\u0e86"-"\u0e8a",
            "\u0e8c"-"\u0ea3",
            "\u0ea5",
            "\u0ea7"-"\u0eb0",
            "\u0eb2"-"\u0eb3",
            "\u0ebd",
            "\u0ec0"-"\u0ec4",
            "\u0ec6",
            "\u0edc"-"\u0edf",
            "\u0f00",
            "\u0f40"-"\u0f47",
            "\u0f49"-"\u0f6c",
            "\u0f88"-"\u0f8c",
            "\u1000"-"\u102a",
            "\u103f",
            "\u1050"-"\u1055",
            "\u105a"-"\u105d",
            "\u1061",
            "\u1065"-"\u1066",
            "\u106e"-"\u1070",
            "\u1075"-"\u1081",
            "\u108e",
            "\u10a0"-"\u10c5",
            "\u10c7",
            "\u10cd",
            "\u10d0"-"\u10fa",
            "\u10fc"-"\u1248",
            "\u124a"-"\u124d",
            "\u1250"-"\u1256",
            "\u1258",
            "\u125a"-"\u125d",
            "\u1260"-"\u1288",
            "\u128a"-"\u128d",
            "\u1290"-"\u12b0",
            "\u12b2"-"\u12b5",
            "\u12b8"-"\u12be",
            "\u12c0",
            "\u12c2"-"\u12c5",
            "\u12c8"-"\u12d6",
            "\u12d8"-"\u1310",
            "\u1312"-"\u1315",
            "\u1318"-"\u135a",
            "\u1380"-"\u138f",
            "\u13a0"-"\u13f5",
            "\u13f8"-"\u13fd",
            "\u1401"-"\u166c",
            "\u166f"-"\u167f",
            "\u1681"-"\u169a",
            "\u16a0"-"\u16ea",
            "\u16ee"-"\u16f8",
            "\u1700"-"\u170c",
            "\u170e"-"\u1711",
            "\u1720"-"\u1731",
            "\u1740"-"\u1751",
            "\u1760"-"\u176c",
            "\u176e"-"\u1770",
            "\u1780"-"\u17b3",
            "\u17d7",
            "\u17dc",
            "\u1820"-"\u1878",
            "\u1880"-"\u1884",
            "\u1887"-"\u18a8",
            "\u18aa",
            "\u18b0"-"\u18f5",
            "\u1900"-"\u191e",
            "\u1950"-"\u196d",
            "\u1970"-"\u1974",
            "\u1980"-"\u19ab",
            "\u19b0"-"\u19c9",
            "\u1a00"-"\u1a16",
            "\u1a20"-"\u1a54",
            "\u1aa7",
            "\u1b05"-"\u1b33",
            "\u1b45"-"\u1b4b",
            "\u1b83"-"\u1ba0",
            "\u1bae"-"\u1baf",
            "\u1bba"-"\u1be5",
            "\u1c00"-"\u1c23",
            "\u1c4d"-"\u1c4f",
            "\u1c5a"-"\u1c7d",
            "\u1c80"-"\u1c88",
            "\u1c90"-"\u1cba",
            "\u1cbd"-"\u1cbf",
            "\u1ce9"-"\u1cec",
            "\u1cee"-"\u1cf3",
            "\u1cf5"-"\u1cf6",
            "\u1cfa",
            "\u1d00"-"\u1dbf",
            "\u1e00"-"\u1f15",
            "\u1f18"-"\u1f1d",
            "\u1f20"-"\u1f45",
            "\u1f48"-"\u1f4d",
            "\u1f50"-"\u1f57",
            "\u1f59",
            "\u1f5b",
            "\u1f5d",
            "\u1f5f"-"\u1f7d",
            "\u1f80"-"\u1fb4",
            "\u1fb6"-"\u1fbc",
            "\u1fbe",
            "\u1fc2"-"\u1fc4",
            "\u1fc6"-"\u1fcc",
            "\u1fd0"-"\u1fd3",
            "\u1fd6"-"\u1fdb",
            "\u1fe0"-"\u1fec",
            "\u1ff2"-"\u1ff4",
            "\u1ff6"-"\u1ffc",
            "\u203f"-"\u2040",
            "\u2054",
            "\u2071",
            "\u207f",
            "\u2090"-"\u209c",
            "\u2102",
            "\u2107",
            "\u210a"-"\u2113",
            "\u2115",
            "\u2119"-"\u211d",
            "\u2124",
            "\u2126",
            "\u2128",
            "\u212a"-"\u212d",
            "\u212f"-"\u2139",
            "\u213c"-"\u213f",
            "\u2145"-"\u2149",
            "\u214e",
            "\u2160"-"\u2188",
            "\u2c00"-"\u2c2e",
            "\u2c30"-"\u2c5e",
            "\u2c60"-"\u2ce4",
            "\u2ceb"-"\u2cee",
            "\u2cf2"-"\u2cf3",
            "\u2d00"-"\u2d25",
            "\u2d27",
            "\u2d2d",
            "\u2d30"-"\u2d67",
            "\u2d6f",
            "\u2d80"-"\u2d96",
            "\u2da0"-"\u2da6",
            "\u2da8"-"\u2dae",
            "\u2db0"-"\u2db6",
            "\u2db8"-"\u2dbe",
            "\u2dc0"-"\u2dc6",
            "\u2dc8"-"\u2dce",
            "\u2dd0"-"\u2dd6",
            "\u2dd8"-"\u2dde",
            "\u2e2f",
            "\u3005"-"\u3007",
            "\u3021"-"\u3029",
            "\u3031"-"\u3035",
            "\u3038"-"\u303c",
            "\u3041"-"\u3096",
            "\u309d"-"\u309f",
            "\u30a1"-"\u30fa",
            "\u30fc"-"\u30ff",
            "\u3105"-"\u312f",
            "\u3131"-"\u318e",
            "\u31a0"-"\u31bf",
            "\u31f0"-"\u31ff",
            "\u3400"-"\u4dbf",
            "\u4e00"-"\u9ffc",
            "\ua000"-"\ua48c",
            "\ua4d0"-"\ua4fd",
            "\ua500"-"\ua60c",
            "\ua610"-"\ua61f",
            "\ua62a"-"\ua62b",
            "\ua640"-"\ua66e",
            "\ua67f"-"\ua69d",
            "\ua6a0"-"\ua6ef",
            "\ua717"-"\ua71f",
            "\ua722"-"\ua788",
            "\ua78b"-"\ua7bf",
            "\ua7c2"-"\ua7ca",
            "\ua7f5"-"\ua801",
            "\ua803"-"\ua805",
            "\ua807"-"\ua80a",
            "\ua80c"-"\ua822",
            "\ua840"-"\ua873",
            "\ua882"-"\ua8b3",
            "\ua8f2"-"\ua8f7",
            "\ua8fb",
            "\ua8fd"-"\ua8fe",
            "\ua90a"-"\ua925",
            "\ua930"-"\ua946",
            "\ua960"-"\ua97c",
            "\ua984"-"\ua9b2",
            "\ua9cf",
            "\ua9e0"-"\ua9e4",
            "\ua9e6"-"\ua9ef",
            "\ua9fa"-"\ua9fe",
            "\uaa00"-"\uaa28",
            "\uaa40"-"\uaa42",
            "\uaa44"-"\uaa4b",
            "\uaa60"-"\uaa76",
            "\uaa7a",
            "\uaa7e"-"\uaaaf",
            "\uaab1",
            "\uaab5"-"\uaab6",
            "\uaab9"-"\uaabd",
            "\uaac0",
            "\uaac2",
            "\uaadb"-"\uaadd",
            "\uaae0"-"\uaaea",
            "\uaaf2"-"\uaaf4",
            "\uab01"-"\uab06",
            "\uab09"-"\uab0e",
            "\uab11"-"\uab16",
            "\uab20"-"\uab26",
            "\uab28"-"\uab2e",
            "\uab30"-"\uab5a",
            "\uab5c"-"\uab69",
            "\uab70"-"\uabe2",
            "\uac00"-"\ud7a3",
            "\ud7b0"-"\ud7c6",
            "\ud7cb"-"\ud7fb",
            "\uf900"-"\ufa6d",
            "\ufa70"-"\ufad9",
            "\ufb00"-"\ufb06",
            "\ufb13"-"\ufb17",
            "\ufb1d",
            "\ufb1f"-"\ufb28",
            "\ufb2a"-"\ufb36",
            "\ufb38"-"\ufb3c",
            "\ufb3e",
            "\ufb40"-"\ufb41",
            "\ufb43"-"\ufb44",
            "\ufb46"-"\ufbb1",
            "\ufbd3"-"\ufd3d",
            "\ufd50"-"\ufd8f",
            "\ufd92"-"\ufdc7",
            "\ufdf0"-"\ufdfb",
            "\ufe33"-"\ufe34",
            "\ufe4d"-"\ufe4f",
            "\ufe70"-"\ufe74",
            "\ufe76"-"\ufefc",
            "\uff21"-"\uff3a",
            "\uff3f",
            "\uff41"-"\uff5a",
            "\uff66"-"\uffbe",
            "\uffc2"-"\uffc7",
            "\uffca"-"\uffcf",
            "\uffd2"-"\uffd7",
            "\uffda"-"\uffdc"
        ] >
    | < #PART_LETTER:
        [  // all chars for which Character.isIdentifierPart is true (in Java 17)
            "\u0000"-"\u0008",
            "\u000e"-"\u001b",
            "\u0024",
            "\u0030"-"\u0039",
            "\u0041"-"\u005a",
            "\u005f",
            "\u0061"-"\u007a",
            "\u007f"-"\u009f",
            "\u00a2"-"\u00a5",
            "\u00aa",
            "\u00ad",
            "\u00b5",
            "\u00ba",
            "\u00c0"-"\u00d6",
            "\u00d8"-"\u00f6",
            "\u00f8"-"\u02c1",
            "\u02c6"-"\u02d1",
            "\u02e0"-"\u02e4",
            "\u02ec",
            "\u02ee",
            "\u0300"-"\u0374",
            "\u0376"-"\u0377",
            "\u037a"-"\u037d",
            "\u037f",
            "\u0386",
            "\u0388"-"\u038a",
            "\u038c",
            "\u038e"-"\u03a1",
            "\u03a3"-"\u03f5",
            "\u03f7"-"\u0481",
            "\u0483"-"\u0487",
            "\u048a"-"\u052f",
            "\u0531"-"\u0556",
            "\u0559",
            "\u0560"-"\u0588",
            "\u058f",
            "\u0591"-"\u05bd",
            "\u05bf",
            "\u05c1"-"\u05c2",
            "\u05c4"-"\u05c5",
            "\u05c7",
            "\u05d0"-"\u05ea",
            "\u05ef"-"\u05f2",
            "\u0600"-"\u0605",
            "\u060b",
            "\u0610"-"\u061a",
            "\u061c",
            "\u0620"-"\u0669",
            "\u066e"-"\u06d3",
            "\u06d5"-"\u06dd",
            "\u06df"-"\u06e8",
            "\u06ea"-"\u06fc",
            "\u06ff",
            "\u070f"-"\u074a",
            "\u074d"-"\u07b1",
            "\u07c0"-"\u07f5",
            "\u07fa",
            "\u07fd"-"\u082d",
            "\u0840"-"\u085b",
            "\u0860"-"\u086a",
            "\u08a0"-"\u08b4",
            "\u08b6"-"\u08c7",
            "\u08d3"-"\u0963",
            "\u0966"-"\u096f",
            "\u0971"-"\u0983",
            "\u0985"-"\u098c",
            "\u098f"-"\u0990",
            "\u0993"-"\u09a8",
            "\u09aa"-"\u09b0",
            "\u09b2",
            "\u09b6"-"\u09b9",
            "\u09bc"-"\u09c4",
            "\u09c7"-"\u09c8",
            "\u09cb"-"\u09ce",
            "\u09d7",
            "\u09dc"-"\u09dd",
            "\u09df"-"\u09e3",
            "\u09e6"-"\u09f3",
            "\u09fb"-"\u09fc",
            "\u09fe",
            "\u0a01"-"\u0a03",
            "\u0a05"-"\u0a0a",
            "\u0a0f"-"\u0a10",
            "\u0a13"-"\u0a28",
            "\u0a2a"-"\u0a30",
            "\u0a32"-"\u0a33",
            "\u0a35"-"\u0a36",
            "\u0a38"-"\u0a39",
            "\u0a3c",
            "\u0a3e"-"\u0a42",
            "\u0a47"-"\u0a48",
            "\u0a4b"-"\u0a4d",
            "\u0a51",
            "\u0a59"-"\u0a5c",
            "\u0a5e",
            "\u0a66"-"\u0a75",
            "\u0a81"-"\u0a83",
            "\u0a85"-"\u0a8d",
            "\u0a8f"-"\u0a91",
            "\u0a93"-"\u0aa8",
            "\u0aaa"-"\u0ab0",
            "\u0ab2"-"\u0ab3",
            "\u0ab5"-"\u0ab9",
            "\u0abc"-"\u0ac5",
            "\u0ac7"-"\u0ac9",
            "\u0acb"-"\u0acd",
            "\u0ad0",
            "\u0ae0"-"\u0ae3",
            "\u0ae6"-"\u0aef",
            "\u0af1",
            "\u0af9"-"\u0aff",
            "\u0b01"-"\u0b03",
            "\u0b05"-"\u0b0c",
            "\u0b0f"-"\u0b10",
            "\u0b13"-"\u0b28",
            "\u0b2a"-"\u0b30",
            "\u0b32"-"\u0b33",
            "\u0b35"-"\u0b39",
            "\u0b3c"-"\u0b44",
            "\u0b47"-"\u0b48",
            "\u0b4b"-"\u0b4d",
            "\u0b55"-"\u0b57",
            "\u0b5c"-"\u0b5d",
            "\u0b5f"-"\u0b63",
            "\u0b66"-"\u0b6f",
            "\u0b71",
            "\u0b82"-"\u0b83",
            "\u0b85"-"\u0b8a",
            "\u0b8e"-"\u0b90",
            "\u0b92"-"\u0b95",
            "\u0b99"-"\u0b9a",
            "\u0b9c",
            "\u0b9e"-"\u0b9f",
            "\u0ba3"-"\u0ba4",
            "\u0ba8"-"\u0baa",
            "\u0bae"-"\u0bb9",
            "\u0bbe"-"\u0bc2",
            "\u0bc6"-"\u0bc8",
            "\u0bca"-"\u0bcd",
            "\u0bd0",
            "\u0bd7",
            "\u0be6"-"\u0bef",
            "\u0bf9",
            "\u0c00"-"\u0c0c",
            "\u0c0e"-"\u0c10",
            "\u0c12"-"\u0c28",
            "\u0c2a"-"\u0c39",
            "\u0c3d"-"\u0c44",
            "\u0c46"-"\u0c48",
            "\u0c4a"-"\u0c4d",
            "\u0c55"-"\u0c56",
            "\u0c58"-"\u0c5a",
            "\u0c60"-"\u0c63",
            "\u0c66"-"\u0c6f",
            "\u0c80"-"\u0c83",
            "\u0c85"-"\u0c8c",
            "\u0c8e"-"\u0c90",
            "\u0c92"-"\u0ca8",
            "\u0caa"-"\u0cb3",
            "\u0cb5"-"\u0cb9",
            "\u0cbc"-"\u0cc4",
            "\u0cc6"-"\u0cc8",
            "\u0cca"-"\u0ccd",
            "\u0cd5"-"\u0cd6",
            "\u0cde",
            "\u0ce0"-"\u0ce3",
            "\u0ce6"-"\u0cef",
            "\u0cf1"-"\u0cf2",
            "\u0d00"-"\u0d0c",
            "\u0d0e"-"\u0d10",
            "\u0d12"-"\u0d44",
            "\u0d46"-"\u0d48",
            "\u0d4a"-"\u0d4e",
            "\u0d54"-"\u0d57",
            "\u0d5f"-"\u0d63",
            "\u0d66"-"\u0d6f",
            "\u0d7a"-"\u0d7f",
            "\u0d81"-"\u0d83",
            "\u0d85"-"\u0d96",
            "\u0d9a"-"\u0db1",
            "\u0db3"-"\u0dbb",
            "\u0dbd",
            "\u0dc0"-"\u0dc6",
            "\u0dca",
            "\u0dcf"-"\u0dd4",
            "\u0dd6",
            "\u0dd8"-"\u0ddf",
            "\u0de6"-"\u0def",
            "\u0df2"-"\u0df3",
            "\u0e01"-"\u0e3a",
            "\u0e3f"-"\u0e4e",
            "\u0e50"-"\u0e59",
            "\u0e81"-"\u0e82",
            "\u0e84",
            "\u0e86"-"\u0e8a",
            "\u0e8c"-"\u0ea3",
            "\u0ea5",
            "\u0ea7"-"\u0ebd",
            "\u0ec0"-"\u0ec4",
            "\u0ec6",
            "\u0ec8"-"\u0ecd",
            "\u0ed0"-"\u0ed9",
            "\u0edc"-"\u0edf",
            "\u0f00",
            "\u0f18"-"\u0f19",
            "\u0f20"-"\u0f29",
            "\u0f35",
            "\u0f37",
            "\u0f39",
            "\u0f3e"-"\u0f47",
            "\u0f49"-"\u0f6c",
            "\u0f71"-"\u0f84",
            "\u0f86"-"\u0f97",
            "\u0f99"-"\u0fbc",
            "\u0fc6",
            "\u1000"-"\u1049",
            "\u1050"-"\u109d",
            "\u10a0"-"\u10c5",
            "\u10c7",
            "\u10cd",
            "\u10d0"-"\u10fa",
            "\u10fc"-"\u1248",
            "\u124a"-"\u124d",
            "\u1250"-"\u1256",
            "\u1258",
            "\u125a"-"\u125d",
            "\u1260"-"\u1288",
            "\u128a"-"\u128d",
            "\u1290"-"\u12b0",
            "\u12b2"-"\u12b5",
            "\u12b8"-"\u12be",
            "\u12c0",
            "\u12c2"-"\u12c5",
            "\u12c8"-"\u12d6",
            "\u12d8"-"\u1310",
            "\u1312"-"\u1315",
            "\u1318"-"\u135a",
            "\u135d"-"\u135f",
            "\u1380"-"\u138f",
            "\u13a0"-"\u13f5",
            "\u13f8"-"\u13fd",
            "\u1401"-"\u166c",
            "\u166f"-"\u167f",
            "\u1681"-"\u169a",
            "\u16a0"-"\u16ea",
            "\u16ee"-"\u16f8",
            "\u1700"-"\u170c",
            "\u170e"-"\u1714",
            "\u1720"-"\u1734",
            "\u1740"-"\u1753",
            "\u1760"-"\u176c",
            "\u176e"-"\u1770",
            "\u1772"-"\u1773",
            "\u1780"-"\u17d3",
            "\u17d7",
            "\u17db"-"\u17dd",
            "\u17e0"-"\u17e9",
            "\u180b"-"\u180e",
            "\u1810"-"\u1819",
            "\u1820"-"\u1878",
            "\u1880"-"\u18aa",
            "\u18b0"-"\u18f5",
            "\u1900"-"\u191e",
            "\u1920"-"\u192b",
            "\u1930"-"\u193b",
            "\u1946"-"\u196d",
            "\u1970"-"\u1974",
            "\u1980"-"\u19ab",
            "\u19b0"-"\u19c9",
            "\u19d0"-"\u19d9",
            "\u1a00"-"\u1a1b",
            "\u1a20"-"\u1a5e",
            "\u1a60"-"\u1a7c",
            "\u1a7f"-"\u1a89",
            "\u1a90"-"\u1a99",
            "\u1aa7",
            "\u1ab0"-"\u1abd",
            "\u1abf"-"\u1ac0",
            "\u1b00"-"\u1b4b",
            "\u1b50"-"\u1b59",
            "\u1b6b"-"\u1b73",
            "\u1b80"-"\u1bf3",
            "\u1c00"-"\u1c37",
            "\u1c40"-"\u1c49",
            "\u1c4d"-"\u1c7d",
            "\u1c80"-"\u1c88",
            "\u1c90"-"\u1cba",
            "\u1cbd"-"\u1cbf",
            "\u1cd0"-"\u1cd2",
            "\u1cd4"-"\u1cfa",
            "\u1d00"-"\u1df9",
            "\u1dfb"-"\u1f15",
            "\u1f18"-"\u1f1d",
            "\u1f20"-"\u1f45",
            "\u1f48"-"\u1f4d",
            "\u1f50"-"\u1f57",
            "\u1f59",
            "\u1f5b",
            "\u1f5d",
            "\u1f5f"-"\u1f7d",
            "\u1f80"-"\u1fb4",
            "\u1fb6"-"\u1fbc",
            "\u1fbe",
            "\u1fc2"-"\u1fc4",
            "\u1fc6"-"\u1fcc",
            "\u1fd0"-"\u1fd3",
            "\u1fd6"-"\u1fdb",
            "\u1fe0"-"\u1fec",
            "\u1ff2"-"\u1ff4",
            "\u1ff6"-"\u1ffc",
            "\u200b"-"\u200f",
            "\u202a"-"\u202e",
            "\u203f"-"\u2040",
            "\u2054",
            "\u2060"-"\u2064",
            "\u2066"-"\u206f",
            "\u2071",
            "\u207f",
            "\u2090"-"\u209c",
            "\u20a0"-"\u20bf",
            "\u20d0"-"\u20dc",
            "\u20e1",
            "\u20e5"-"\u20f0",
            "\u2102",
            "\u2107",
            "\u210a"-"\u2113",
            "\u2115",
            "\u2119"-"\u211d",
            "\u2124",
            "\u2126",
            "\u2128",
            "\u212a"-"\u212d",
            "\u212f"-"\u2139",
            "\u213c"-"\u213f",
            "\u2145"-"\u2149",
            "\u214e",
            "\u2160"-"\u2188",
            "\u2c00"-"\u2c2e",
            "\u2c30"-"\u2c5e",
            "\u2c60"-"\u2ce4",
            "\u2ceb"-"\u2cf3",
            "\u2d00"-"\u2d25",
            "\u2d27",
            "\u2d2d",
            "\u2d30"-"\u2d67",
            "\u2d6f",
            "\u2d7f"-"\u2d96",
            "\u2da0"-"\u2da6",
            "\u2da8"-"\u2dae",
            "\u2db0"-"\u2db6",
            "\u2db8"-"\u2dbe",
            "\u2dc0"-"\u2dc6",
            "\u2dc8"-"\u2dce",
            "\u2dd0"-"\u2dd6",
            "\u2dd8"-"\u2dde",
            "\u2de0"-"\u2dff",
            "\u2e2f",
            "\u3005"-"\u3007",
            "\u3021"-"\u302f",
            "\u3031"-"\u3035",
            "\u3038"-"\u303c",
            "\u3041"-"\u3096",
            "\u3099"-"\u309a",
            "\u309d"-"\u309f",
            "\u30a1"-"\u30fa",
            "\u30fc"-"\u30ff",
            "\u3105"-"\u312f",
            "\u3131"-"\u318e",
            "\u31a0"-"\u31bf",
            "\u31f0"-"\u31ff",
            "\u3400"-"\u4dbf",
            "\u4e00"-"\u9ffc",
            "\ua000"-"\ua48c",
            "\ua4d0"-"\ua4fd",
            "\ua500"-"\ua60c",
            "\ua610"-"\ua62b",
            "\ua640"-"\ua66f",
            "\ua674"-"\ua67d",
            "\ua67f"-"\ua6f1",
            "\ua717"-"\ua71f",
            "\ua722"-"\ua788",
            "\ua78b"-"\ua7bf",
            "\ua7c2"-"\ua7ca",
            "\ua7f5"-"\ua827",
            "\ua82c",
            "\ua838",
            "\ua840"-"\ua873",
            "\ua880"-"\ua8c5",
            "\ua8d0"-"\ua8d9",
            "\ua8e0"-"\ua8f7",
            "\ua8fb",
            "\ua8fd"-"\ua92d",
            "\ua930"-"\ua953",
            "\ua960"-"\ua97c",
            "\ua980"-"\ua9c0",
            "\ua9cf"-"\ua9d9",
            "\ua9e0"-"\ua9fe",
            "\uaa00"-"\uaa36",
            "\uaa40"-"\uaa4d",
            "\uaa50"-"\uaa59",
            "\uaa60"-"\uaa76",
            "\uaa7a"-"\uaac2",
            "\uaadb"-"\uaadd",
            "\uaae0"-"\uaaef",
            "\uaaf2"-"\uaaf6",
            "\uab01"-"\uab06",
            "\uab09"-"\uab0e",
            "\uab11"-"\uab16",
            "\uab20"-"\uab26",
            "\uab28"-"\uab2e",
            "\uab30"-"\uab5a",
            "\uab5c"-"\uab69",
            "\uab70"-"\uabea",
            "\uabec"-"\uabed",
            "\uabf0"-"\uabf9",
            "\uac00"-"\ud7a3",
            "\ud7b0"-"\ud7c6",
            "\ud7cb"-"\ud7fb",
            "\uf900"-"\ufa6d",
            "\ufa70"-"\ufad9",
            "\ufb00"-"\ufb06",
            "\ufb13"-"\ufb17",
            "\ufb1d"-"\ufb28",
            "\ufb2a"-"\ufb36",
            "\ufb38"-"\ufb3c",
            "\ufb3e",
            "\ufb40"-"\ufb41",
            "\ufb43"-"\ufb44",
            "\ufb46"-"\ufbb1",
            "\ufbd3"-"\ufd3d",
            "\ufd50"-"\ufd8f",
            "\ufd92"-"\ufdc7",
            "\ufdf0"-"\ufdfc",
            "\ufe00"-"\ufe0f",
            "\ufe20"-"\ufe2f",
            "\ufe33"-"\ufe34",
            "\ufe4d"-"\ufe4f",
            "\ufe69",
            "\ufe70"-"\ufe74",
            "\ufe76"-"\ufefc",
            "\ufeff",
            "\uff04",
            "\uff10"-"\uff19",
            "\uff21"-"\uff3a",
            "\uff3f",
            "\uff41"-"\uff5a",
            "\uff66"-"\uffbe",
            "\uffc2"-"\uffc7",
            "\uffca"-"\uffcf",
            "\uffd2"-"\uffd7",
            "\uffda"-"\uffdc",
            "\uffe0"-"\uffe1",
            "\uffe5"-"\uffe6",
            "\ufff9"-"\ufffb"
        ] >
}

TOKEN :
{
    < ARROW_LINE: ["\u002d", "\u00ad", "\u2010", "\u2011", "\u2012", "\u2013", "\u2014", "\u2015", "\ufe58", "\ufe63", "\uff0d"] >
    | < ARROW_LEFT_HEAD: ["\u27e8", "\u3008", "\ufe64", "\uff1c"] >
    | < ARROW_RIGHT_HEAD: ["\u27e9", "\u3009", "\ufe65", "\uff1e"] >
}

<*> TOKEN :
{
    < UNKNOWN: ~[] >
}

/** Root production. */
STATEMENTS Statements() throws Exception:
{
    STATEMENT x;
    List<STATEMENT> stmts = new ArrayList<>();
}
{
    try {
        x=Statement() { stmts.add( x ); }
        ( LOOKAHEAD(2) <SEMICOLON> x=Statement() { stmts.add( x ); } )* ( LOOKAHEAD(2) <SEMICOLON> )? <EOF>
        {
            return astFactory.statements(stmts);
        }
    } catch ( ParseException e ) {
        Token t = e.currentToken.next;
        if ( e.getMessage().contains( "Encountered \"<EOF>\"" ) )
        {
            throw exceptionFactory.syntaxException( t.image, ParseExceptions.expected( e.expectedTokenSequences, e.tokenImage ), e,
                                                   t.endOffset + 1, t.endLine, t.endColumn + 1 );
        }
        else
        {
            throw exceptionFactory.syntaxException( t.image, ParseExceptions.expected( e.expectedTokenSequences, e.tokenImage ), e,
                                                   t.beginOffset, t.beginLine, t.beginColumn );
        }
    } catch ( InvalidUnicodeLiteral e ) {
        throw exceptionFactory.syntaxException( e, e.offset, e.line, e.column );
    }
}

STATEMENT Statement() throws Exception:
{
    STATEMENT statement;
    USE_CLAUSE useClause = null;
}
{
    [ PeriodicCommitQueryHintFailure() ]
    (
        useClause=UseClause() statement=SingleQueryOrCommandWithUseClause(useClause)
        | statement=SingleQueryOrCommand()
    )
    {
        return statement;
    }
}

STATEMENT SingleQueryOrCommand() throws Exception:
{
    STATEMENT statement = null;
    QUERY query = null;
}
{
    (
        LOOKAHEAD(2) statement=CreateCommand( null ) // CREATE admin thing vs CREATE graph thing
        | statement=Command( null )
        | query=SingleQuery() ( query=Union(query) )*
    )
    {
        if ( query != null )
        {
            return query;
        }
        return statement;
    }
}

STATEMENT SingleQueryOrCommandWithUseClause( USE_CLAUSE useClause ) throws Exception:
{
    STATEMENT statement = null;
    QUERY query = null;
}
{
    (
        LOOKAHEAD(2) statement=CreateCommand( useClause ) // CREATE admin thing vs CREATE graph thing
        | statement=Command( useClause )
        | query=SingleQueryWithUseClause( useClause ) ( query=Union(query) )*
    )
    {
        if ( query != null )
        {
            return query;
        }
        return statement;
    }
}

void PeriodicCommitQueryHintFailure() throws Exception:
{
    Token tPeriodicCommit;
}
{
    <USING> tPeriodicCommit=<PERIODIC> <COMMIT> ( <UNSIGNED_DECIMAL_INTEGER> )?
    {
        throw exceptionFactory.syntaxException(
            new ParseException( ASTExceptionFactory.periodicCommitNotSupported ),
            tPeriodicCommit.beginOffset, tPeriodicCommit.beginLine, tPeriodicCommit.beginColumn );
    }
}

QUERY RegularQuery() throws Exception:
{
    QUERY x;
}
{
    x=SingleQuery() ( x=Union(x) )*
    {
        return x;
    }
}

QUERY Union( QUERY lhs ) throws Exception :
{
    Token t;
    QUERY rhs;
    boolean all = false;
}
{
    t=<UNION> ( <ALL> { all = true; } | <DISTINCT> )? rhs=SingleQuery()
    {
        return astFactory.newUnion( pos( t ), lhs, rhs, all );
    }
}

QUERY SingleQuery() throws Exception:
{
    CLAUSE x;
    List<CLAUSE> clauses = new ArrayList<>();
}
{
    ( x=Clause() { clauses.add( x ); } )+
    {
        return astFactory.newSingleQuery( clauses );
    }
}

QUERY SingleQueryWithUseClause( CLAUSE useClause ) throws Exception:
{
    CLAUSE x;
    List<CLAUSE> clauses = new ArrayList<>();
    if ( useClause != null )
    {
      clauses.add( useClause );
    }
}
{
    ( x=Clause() { clauses.add( x ); } )*
    {
        return astFactory.newSingleQuery( clauses );
    }
}

CLAUSE Clause() throws Exception:
{
    CLAUSE x = null;
}
{
    (
        x=UseClause()
        | x=FinishClause()
        | x=ReturnClause()
        | x=CreateClause() // because create index/constraint
        | x=InsertClause()
        | x=DeleteClause()
        | x=SetClause()
        | x=RemoveClause()
        | x=MatchClause()
        | x=MergeClause()
        | x=WithClause()
        | x=UnwindClause()
        | LOOKAHEAD(2) x=CallClause() // because subqueries also start with CALL
        | x=SubqueryClause()
        | x=LoadCSVClause()
        | x=ForeachClause()
    )
    {
        return x;
    }
}

// USE

USE_CLAUSE UseClause() throws Exception:
{
    Token t;
    USE_CLAUSE useClause;
}
{
    t=<USE> (
        LOOKAHEAD( 2 ) <GRAPH> (useClause=graphReference(t))
        | useClause=graphReference(t)
        )
    {
        return useClause;
    }
}

USE_CLAUSE graphReference(Token t) throws Exception:
{
    AliasName<DATABASE_NAME, PARAMETER> aliasName;
    FUNCTION_INVOCATION functionInvocation;
    USE_CLAUSE useClause;
}
{
    <LPAREN> useClause=graphReference(t) <RPAREN> { return useClause; }
    | LOOKAHEAD(FunctionInvocation()) functionInvocation = FunctionInvocation(true)  { return astFactory.functionUseClause(pos(t), functionInvocation); }
    | aliasName = SymbolicAliasName()  { return astFactory.directUseClause(pos(t), aliasName.getLocalAliasName(astFactory));}
}

// FINISH

FINISH_CLAUSE FinishClause() throws Exception:
{
    Token t;
}
{
    t=<FINISH>
    {
        return astFactory.newFinishClause( pos( t ) );
    }
}

// RETURN

RETURN_CLAUSE ReturnClause() throws Exception:
{
    Token t;
    RETURN_CLAUSE clause = null;
}
{
    t=<RETURN>
    clause=ReturnBody( t )
    {
        return clause;
    }
}

RETURN_CLAUSE ReturnBody( Token t ) throws Exception:
{
    Token skipPosition = null;
    Token limitPosition = null;
    boolean distinct = false;
    List<ORDER_ITEM> order = new ArrayList<>();
    Token orderPos = null;
    EXPRESSION skip = null;
    EXPRESSION limit = null;
    ORDER_ITEM o = null;
    RETURN_ITEM x;
    RETURN_ITEMS returnItems;
}
{
    ( LOOKAHEAD( 2 ) <DISTINCT> { distinct = true; } )?
    ( returnItems=ReturnItems() )
    ( orderPos=<ORDER> <BY> o=OrderItem() { order.add( o ); } ( <COMMA> o=OrderItem() {order.add( o ); } )* )? ( { skipPosition=token.next; } skip=Skip() )? ( { limitPosition=token.next; } limit=Limit() )?
    {
        return astFactory.newReturnClause(  pos( t ), distinct, returnItems, order, pos( orderPos ), skip, pos( skipPosition ), limit, pos( limitPosition ) );
    }
}

RETURN_ITEM ReturnItem() throws Exception:
{
    EXPRESSION e;
    VARIABLE v = null;
    Token eStart;
    Token eEnd;
}
{
    { eStart = token; }
    e=Expression() { eEnd = token; } ( <AS> v=Variable() )?
    {
        if ( v != null )
        {
            return astFactory.newReturnItem( pos( eStart.next ), e, v );
        }
        else
        {
            return astFactory.newReturnItem( pos( eStart.next ), e, eStart.next.beginOffset, eEnd.endOffset );
        }
    }
}

RETURN_ITEMS ReturnItems() throws Exception:
{
    Token returnItemsPosition;
    RETURN_ITEM x;
    List<RETURN_ITEM> returnItems = new ArrayList<>();
    boolean returnAll = false;
}
{
    { returnItemsPosition = token; }
    (
        <TIMES> { returnAll = true; } ( <COMMA> x=ReturnItem() { returnItems.add( x ); } )*
        | x=ReturnItem() { returnItems.add( x ); } ( <COMMA> x=ReturnItem() { returnItems.add( x ); } )*
    ) {
        return astFactory.newReturnItems( pos( returnItemsPosition.next ), returnAll, returnItems );
    }
}

ORDER_ITEM OrderItem() throws Exception:
{
    Token t;
    EXPRESSION e;
}
{
    {t = token;}
    e=Expression()
    (
        (<DESC> | <DESCENDING>) { return astFactory.orderDesc( pos( t.next ), e ); }
        | ( <ASC> | <ASCENDING> )? { return astFactory.orderAsc( pos( t.next ), e ); }
    )
}

EXPRESSION Skip() throws Exception:
{
    EXPRESSION e;
}
{
    <SKIPROWS> e=Expression()
    {
        return e;
    }
}

EXPRESSION Limit() throws Exception:
{
    EXPRESSION e; }
{
    <LIMITROWS> e=Expression()
    {
        return e;
    }
}

// WHERE

WHERE WhereClause() throws Exception:
{
    Token t;
    EXPRESSION e;
}
{
    t=<WHERE> e=Expression()
    {
        return astFactory.whereClause( pos( t ), e );
    }
}

// WITH

CLAUSE WithClause() throws Exception:
{
    Token t;
    RETURN_CLAUSE returnClause;
    WHERE where = null;
}
{
    t=<WITH> returnClause=ReturnBody( t ) ( where=WhereClause() )?
    {
        return astFactory.withClause( pos( t ), returnClause, where );
    }
}

// CREATE

CLAUSE CreateClause() throws Exception:
{
    Token t;
    List<PATTERN> patterns;
}
{
    t=<CREATE> patterns=PatternList()
    {
        return astFactory.createClause( pos( t ), patterns );
    }
}

// INSERT

CLAUSE InsertClause() throws Exception:
{
    Token t;
    List<PATTERN> patterns;
}
{
    t=<INSERT> patterns=InsertPatternList()
    {
        return astFactory.insertClause( pos( t ), patterns );
    }
}

// SET

SET_CLAUSE SetClause() throws Exception:
{
    Token t;
    SET_ITEM item;
    List<SET_ITEM> items = new ArrayList<>();
}
{
    t=<SET> item=SetItem() { items.add( item ); } ( <COMMA> item=SetItem() { items.add( item ); } )*
    {
        return astFactory.setClause( pos( t ), items );
    }
}

SET_ITEM SetItem() throws Exception:
{
    EXPRESSION e;
    PROPERTY p;
    EXPRESSION d;
    VARIABLE v;
    SET_ITEM setItem = null;
}
{
    LOOKAHEAD( Expression1() <DOT> ) p=PropertyExpression() <EQ> e=Expression() { return astFactory.setProperty( p, e ); }
    | LOOKAHEAD( Expression1() <LBRACKET> ) d=DynamicPropertyExpression() <EQ> e=Expression() { return astFactory.setDynamicProperty( d, e ); }
    | LOOKAHEAD( 2 ) v=Variable() <EQ> e=Expression() { return astFactory.setVariable( v, e ); }
    | LOOKAHEAD( 2 ) v = Variable() <PLUSEQUAL> e=Expression() { return astFactory.addAndSetVariable( v, e ); }
    | LOOKAHEAD( 2 ) v = Variable() setItem = SetNodeLabels(v) { return setItem; }
    | v = Variable() setItem = SetNodeLabelsIs(v) { return setItem; }
}

// REMOVE

CLAUSE RemoveClause() throws Exception:
{
    Token t;
    REMOVE_ITEM item;
    List<REMOVE_ITEM> items = new ArrayList<>();
}
{
    t=<REMOVE> item=RemoveItem() { items.add( item ); } ( <COMMA> item=RemoveItem() { items.add( item ); })*
    {
        return astFactory.removeClause( pos( t ), items );
    }
}

REMOVE_ITEM RemoveItem() throws Exception:
{
    EXPRESSION e;
    PROPERTY p;
    VARIABLE v;
    REMOVE_ITEM removeItem = null;
}
{
    LOOKAHEAD( Expression1() <DOT> ) p=PropertyExpression() { return astFactory.removeProperty( p ); }
    | LOOKAHEAD( Expression1() <LBRACKET> ) e=DynamicPropertyExpression() { return astFactory.removeDynamicProperty( e ); }
    | LOOKAHEAD( 2 ) v=Variable() removeItem=RemoveNodeLabelsColon(v) { return removeItem; }
    | v=Variable() removeItem=RemoveNodeLabelsIs(v) { return removeItem; }
}

// DELETE

CLAUSE DeleteClause() throws Exception:
{
    Token detachT = null;
    Token t;
    boolean detach = false;
    EXPRESSION e;
    List<EXPRESSION> list = new ArrayList<>();
}
{
    ( detachT=<DETACH> { detach = true; } | detachT=<NODETACH> )? t=<DELETE> e=Expression() {list.add( e );} ( <COMMA> e=Expression() { list.add( e ); } )*
    {
        return astFactory.deleteClause( pos( detachT != null ? detachT : t ), detach, list );
    }
}

// MATCH

CLAUSE MatchClause() throws Exception:
{
    Token optionalT = null;
    Token t;
    Token whereToken = null;
    boolean optional = false;
    MATCH_MODE matchMode = null;
    List<PATTERN> patterns;
    List<HINT> hints;
    WHERE where = null;
}
{
    ( optionalT=<OPTIONAL> { optional = true; } )? t=<MATCH> (LOOKAHEAD(2) matchMode = MatchMode() )? patterns=PatternList() hints=Hints() ( where=WhereClause() )?
    {
        return astFactory.matchClause( pos( optionalT != null ? optionalT : t ), optional, matchMode, patterns, pos( t.next ), hints, where );
    }
}

MATCH_MODE MatchMode():
{
    Token t;
    MATCH_MODE matchMode;
}
{
    (
        t = <REPEATABLE> (LOOKAHEAD(2) <ELEMENT> <BINDINGS> | <ELEMENT> |  <ELEMENTS> ) { matchMode = astFactory.repeatableElements(pos(t)); } |
        t = <DIFFERENT> (LOOKAHEAD(2) <RELATIONSHIP> <BINDINGS> | <RELATIONSHIP> | <RELATIONSHIPS> ) { matchMode = astFactory.differentRelationships(pos(t)); }
    )
    {
        return matchMode;
    }
}

List<HINT> Hints() :
{
    Token t;
    boolean seek;
    VARIABLE v;
    Token labelOrRelType;
    List<VARIABLE> joinVariables;
    HINT hint;
    List<HINT> hints = null;
}
{
    ( t=<USING>
        (
              <INDEX> hint = IndexHintBody( HintIndexType.ANY, pos( t ) )
            | <BTREE> <INDEX> hint = IndexHintBody( HintIndexType.BTREE, pos( t ) )
            | <TEXT> <INDEX> hint = IndexHintBody( HintIndexType.TEXT, pos( t ) )
            | <RANGE> <INDEX> hint = IndexHintBody( HintIndexType.RANGE, pos( t ) )
            | <POINT> <INDEX> hint = IndexHintBody( HintIndexType.POINT, pos( t ) )
            | <JOIN> <ON> joinVariables=VariableList1() { hint = astFactory.usingJoin( pos( t ), joinVariables ); }
            | <SCAN> v=Variable() labelOrRelType=LabelOrRelType() { hint = astFactory.usingScan( pos( t ), v, labelOrRelType.image ); }
        )
        {
            if ( hints == null )
            {
                hints = new ArrayList<>();
            }
            hints.add( hint );
        }
    )*
    {
        return hints;
    }
}

HINT IndexHintBody( HintIndexType indexType, POS p ) :
{
    boolean seek = false;
    VARIABLE v;
    Token labelOrRelType;
    List<String> propNames;
}
{
    ( LOOKAHEAD( 2 ) <SEEK> { seek = true; } )? v=Variable() labelOrRelType=LabelOrRelType() <LPAREN> propNames=SymbolicNameList1() <RPAREN>
    {
        return astFactory.usingIndexHint( p, v, labelOrRelType.image, propNames, seek, indexType);
    }
}

// MERGE

CLAUSE MergeClause() throws Exception:
{
    Token t;
    Token onToken;
    PATTERN p;
    SET_CLAUSE c;
    ArrayList<SET_CLAUSE> clauses = new ArrayList<>();
    ArrayList<POS> positions = new ArrayList<>();
    ArrayList<ASTFactory.MergeActionType> actionTypes = new ArrayList<>();
}
{
    t=<MERGE> p=Pattern()
    (
        onToken = <ON> (
            <MATCH> c=SetClause() { clauses.add( c ); actionTypes.add( ASTFactory.MergeActionType.OnMatch ); positions.add( pos( onToken ) ); }
            | <CREATE> c=SetClause() { clauses.add( c ); actionTypes.add( ASTFactory.MergeActionType.OnCreate ); positions.add( pos( onToken ) ); }
        )
    )*
    {
        return astFactory.mergeClause( pos( t ), p, clauses, actionTypes, positions );
    }
}

// UNWIND

CLAUSE UnwindClause() throws Exception:
{
    Token t;
    EXPRESSION e;
    VARIABLE v;}
{
    t=<UNWIND> e=Expression() <AS> v=Variable()
    {
        return astFactory.unwindClause( pos( t ), e, v );
    }
}

// CALL

CLAUSE CallClause() throws Exception:
{
    Token t;
    Token procedureNamePosition;
    Token procedureResultPosition = null;
    List<String> namespace;
    String name;
    EXPRESSION e;
    List<EXPRESSION> arguments = null;
    boolean yieldAll = false;
    CALL_RESULT_ITEM x;
    List<CALL_RESULT_ITEM> items = null;
    WHERE where = null;
}
{
    t=<CALL> namespace=Namespace() {procedureNamePosition = token;} name=ProcedureName()
    ( <LPAREN> { arguments = new ArrayList<>(); }
        ( e=Expression() { arguments.add( e ); } ( <COMMA> e=Expression() { arguments.add( e ); })* )?
        <RPAREN>
    )?
    ( procedureResultPosition=<YIELD> (
        <TIMES> { yieldAll = true; }
        | { items = new ArrayList<>(); }
            x=ProcedureResultItem() { items.add( x ); }
            ( <COMMA> x=ProcedureResultItem() { items.add( x ); })*
            ( where=WhereClause() )?
        )
    )?
    {
        return astFactory.callClause( pos( t ),
                                     pos( t.next ),
                                     pos( procedureNamePosition.next ),
                                     pos( procedureResultPosition ),
                                     namespace,
                                     name,
                                     arguments,
                                     yieldAll,
                                     items,
                                     where );
    }
}

String ProcedureName() :
{
    Token t;
}
{
    t=SymbolicNameString()
    {
        return t.image;
    }
}

CALL_RESULT_ITEM ProcedureResultItem() :
{
    Token t;
    VARIABLE v = null;
}
{
    t=SymbolicNameString() ( <AS> v=Variable() )?
    {
        return astFactory.callResultItem( pos( t ), t.image,  v );
    }
}

// LOAD CSV

CLAUSE LoadCSVClause() throws Exception:
{
    Token t;
    boolean headers = false;
    EXPRESSION source;
    VARIABLE v;
    Token sep = null;
}
{
    t=<LOAD> <CSV>
    ( <WITH> <HEADERS> { headers = true; } )?
    <FROM>
    try {
        source=Expression()
    } catch (Exception e) {
       throw new ParseException( exceptionFactory.failedToParseFile + " " + e.getMessage() );
    }
    <AS> v=Variable()
    ( <FIELDTERMINATOR> ( sep=StringToken() ) )?
    {
        return astFactory.loadCsvClause( pos( t ), headers, source, v, sep == null ? null : sep.image );
    }
}

// FOREACH

CLAUSE ForeachClause() throws Exception:
{
    Token t;
    VARIABLE v;
    EXPRESSION list;
    CLAUSE c;
    List<CLAUSE> clauses = new ArrayList<>();
}
{
    t=<FOREACH> <LPAREN> v=Variable() <IN> list=Expression() <BAR>
    ( c=Clause() { clauses.add( c ); } )+
    <RPAREN>
    {
        return astFactory.foreachClause( pos( t ), v, list, clauses );
    }
}

CLAUSE SubqueryClause() throws Exception :
{
    Token t;
    QUERY q;
    SUBQUERY_IN_TRANSACTIONS_PARAMETERS inTransactionsParams = null;
}
{
    t=<CALL>
    <LCURLY>
    q=RegularQuery()
    <RCURLY>
    ( inTransactionsParams = SubqueryInTransactionsParameters() )?
    {
        return astFactory.subqueryClause( pos( t ), q, inTransactionsParams );
    }
}

SUBQUERY_IN_TRANSACTIONS_PARAMETERS SubqueryInTransactionsParameters() throws Exception:
{
    Token t;
    SUBQUERY_IN_TRANSACTIONS_BATCH_PARAMETERS batchParams = null;
    SUBQUERY_IN_TRANSACTIONS_CONCURRENCY_PARAMETERS concurrencyParams = null;
    SUBQUERY_IN_TRANSACTIONS_ERROR_PARAMETERS errorParams = null;
    SUBQUERY_IN_TRANSACTIONS_REPORT_PARAMETERS reportParams = null;
    EXPRESSION c = null;
    String repeatedBatch = "Duplicated OF ROWS parameter";
    String repeatedOnError = "Duplicated ON ERROR parameter";
    String repeatedReport = "Duplicated REPORT STATUS parameter";
}
{
    t=<IN>
    (
        LOOKAHEAD(2) c=Expression() <CONCURRENT> { concurrencyParams = astFactory.subqueryInTransactionsConcurrencyParameters(pos( t ), c); }
      | LOOKAHEAD(1) <CONCURRENT>                { concurrencyParams = astFactory.subqueryInTransactionsConcurrencyParameters(pos( t ), null); }
      |                                          { concurrencyParams = null; }
    )
    t=<TRANSACTIONS>
    // The 3 parameters for CALL IN TRANSACTIONS:
    // ON ERROR CONTINUE / BREAK / FAIL, OF ROWS, and REPORT STATUS, can appear
    // in any order and shouldn't be duplicated
    (
        (
            { assertNotAlreadySet( batchParams, t, repeatedBatch ); } batchParams=SubqueryInTransactionsBatchParameters() |
            { assertNotAlreadySet( errorParams, t, repeatedOnError ); } errorParams=SubqueryInTransactionsErrorParameters() |
            { assertNotAlreadySet( reportParams, t, repeatedReport ); } reportParams=SubqueryInTransactionsReportParameters()
        )
    )*
    {
        return astFactory.subqueryInTransactionsParams( pos( t ), batchParams, concurrencyParams, errorParams, reportParams);
    }
}

SUBQUERY_IN_TRANSACTIONS_BATCH_PARAMETERS SubqueryInTransactionsBatchParameters() throws Exception:
{
    Token t;
    EXPRESSION batchSize;
}
{
    t=<OF> batchSize=Expression() (<ROW>|<ROWS>)
    {
        return astFactory.subqueryInTransactionsBatchParameters( pos( t ), batchSize);
    }
}

SUBQUERY_IN_TRANSACTIONS_ERROR_PARAMETERS SubqueryInTransactionsErrorParameters() :
{
    Token t;
    CallInTxsOnErrorBehaviourType onErrorBehaviour = CallInTxsOnErrorBehaviourType.ON_ERROR_FAIL;
}
{
    t=<ON> <ERROR> (<CONTINUE> { onErrorBehaviour = CallInTxsOnErrorBehaviourType.ON_ERROR_CONTINUE; } | <BREAK> { onErrorBehaviour = CallInTxsOnErrorBehaviourType.ON_ERROR_BREAK; }  | <FAIL>)
    {
        return astFactory.subqueryInTransactionsErrorParameters( pos( t ), onErrorBehaviour );
    }
}

SUBQUERY_IN_TRANSACTIONS_REPORT_PARAMETERS SubqueryInTransactionsReportParameters() :
{
    Token t;
    VARIABLE v;
}
{
    t=<REPORT> <STATUS> <AS> v=Variable()
    {
        return astFactory.subqueryInTransactionsReportParameters( pos( t ), v );
    }
}

// PATTERN

List<PATTERN> PatternList() throws Exception:
{
    PATTERN p;
    List<PATTERN> patterns = new ArrayList<>();
}
{
    p=Pattern() { patterns.add( p ); } ( <COMMA> p=Pattern() { patterns.add( p ); } )*
    {
        return patterns;
    }
}

List<PATTERN> InsertPatternList() throws Exception:
{
    PATTERN p;
    List<PATTERN> patterns = new ArrayList<>();
}
{
    p=InsertPattern() { patterns.add( p ); } ( <COMMA> p=InsertPattern() { patterns.add( p ); } )*
    {
        return patterns;
    }
}

PATTERN Pattern() throws Exception:
{
    VARIABLE v = null;
    PATTERN p;
    PATTERN_SELECTOR s = null;
}
{
     ( LOOKAHEAD(2)
       v=Variable() <EQ> [s=Selector()]
     | [s=Selector()]
     )
     p=AnonymousPattern()
    {
        if (v != null) p = astFactory.namedPattern( v, p );
        if (s != null) p = astFactory.patternWithSelector( s, p );
        return p;
    }
}

PATTERN InsertPattern() throws Exception:
{
    Token errorStart = null;
    List<PATTERN_ATOM> patternAtoms = new ArrayList<>();
}
{
     ( LOOKAHEAD(2) errorStart = SymbolicNameString() <EQ>)?
     patternAtoms = InsertPathPatternAtoms()
    {
        if (errorStart != null)
        {
            throw exceptionFactory.syntaxException(
                new ParseException( ASTExceptionFactory.namedPatternInInsertNotSupported ),
                errorStart.beginOffset, errorStart.beginLine, errorStart.beginColumn );
        }
        return astFactory.insertPathPattern( patternAtoms );
    }
}

PATTERN_QUANTIFIER Quantifier() :
{
    Token range;
    Token l = null;
    Token u = null;
}
{
    LOOKAHEAD(3)
    range = <LCURLY> l=<UNSIGNED_DECIMAL_INTEGER> <RCURLY> {
        return astFactory.fixedPathQuantifier(pos(range), pos(l), l.image);
    }
    | range = <LCURLY> ( l=<UNSIGNED_DECIMAL_INTEGER> )? <COMMA> ( u=<UNSIGNED_DECIMAL_INTEGER> )? <RCURLY> {
        return astFactory.intervalPathQuantifier(pos(range), pos(l), pos(u), l == null ? null : l.image, u == null ? null : u.image);
    }
    | range = <PLUS> { return astFactory.plusPathQuantifier(pos(range)); }
    | range = <TIMES> { return astFactory.starPathQuantifier(pos(range)); }
}

PATTERN AnonymousPattern() throws Exception:
{
    PATTERN p;
    PATTERN_ELEMENT pe;
}
{
    LOOKAHEAD( 3 ) p=ShortestPathPattern() { return p; }
    | pe=PatternElement() { return astFactory.pathPattern( pe ); }
}

PATTERN ShortestPathPattern() throws Exception:
{
    Token t;
    PATTERN_ELEMENT pe;
}
{
    t=<SHORTEST_PATH> <LPAREN> pe=PatternElement() <RPAREN> { return astFactory.shortestPathPattern( pos( t ), pe ); }
    | t=<ALL_SHORTEST_PATH> <LPAREN> pe=PatternElement() <RPAREN> { return astFactory.allShortestPathsPattern( pos( t ), pe ); }
}

PATTERN_ATOM MaybeQuantifiedRelationshipPattern() throws Exception:
{
  REL_PATTERN rel;
  PATTERN_QUANTIFIER q = null;
}
{
    rel=RelationshipPattern() [q=Quantifier()]
    {
        if ( q == null )
        {
            return rel;
        }
        else
        {
            return astFactory.quantifiedRelationship(rel, q);
        }
    }
}

PATTERN_ELEMENT PatternElement() throws Exception:
{
    List<PATTERN_ATOM> patternAtoms = new ArrayList<>();
}
{
    patternAtoms = PathPatternAtoms()
    {
    return astFactory.patternElement( patternAtoms );
    }
}

List<PATTERN_ATOM> PathPatternAtoms() throws Exception:
{
     NODE_PATTERN n;
     PATTERN_ATOM r;
     PATTERN_ATOM parenthesizedAtom;
     List<PATTERN_ATOM> patternAtoms = new ArrayList<>();
     labelExpressionStack.push(ExpectBar.DO_NOT_EXPECT_BAR);
}
{
     (
         (
             LOOKAHEAD(3)
             (
                 n=NodePattern() { patternAtoms.add( n ); }
                 (
                     LOOKAHEAD( 2 ) r=MaybeQuantifiedRelationshipPattern() { patternAtoms.add( r ); }
                     n=NodePattern() { patternAtoms.add( n ); }
                 )*
             ) |
             (
                 parenthesizedAtom = ParenthesizedPath() { patternAtoms.add( parenthesizedAtom ); }
             )
         )+
     )
     {
        labelExpressionStack.pop();
         return patternAtoms;
     }
}

List<PATTERN_ATOM> InsertPathPatternAtoms() throws Exception:
{
     NODE_PATTERN n;
     REL_PATTERN r;
     List<PATTERN_ATOM> patternAtoms = new ArrayList<>();
}
{
     (
         n=InsertNodePattern() { patternAtoms.add( n ); }
         (
            LOOKAHEAD( 2 ) r=InsertRelationshipPattern() { patternAtoms.add( r ); }
            n=InsertNodePattern() { patternAtoms.add( n ); }
         )*
     )
     {
         return patternAtoms;
     }
}

PATTERN_SELECTOR Selector() throws Exception:
{
    Token k = null;
    Token s;
    PATTERN_SELECTOR selector = null;
}
{
    ( LOOKAHEAD( 2 ) s = <ANY> <SHORTEST> (<PATH>|<PATHS>)? { selector = astFactory.anyShortestPathSelector(null, null, pos(s)); }
    | LOOKAHEAD( 2 ) s = <ALL> <SHORTEST> (<PATH>|<PATHS>)? { selector = astFactory.allShortestPathSelector(pos(s)); }
    | LOOKAHEAD( 2 ) s = <ANY> (k = <UNSIGNED_DECIMAL_INTEGER>)? (<PATH>|<PATHS>)? { selector = astFactory.anyPathSelector(k != null ? k.image : null, pos(k), pos(s)); }
    | LOOKAHEAD( 2 ) s = <ALL> (<PATH>|<PATHS>)? { selector = astFactory.allPathSelector(pos(s)); }
    | LOOKAHEAD( 4 ) s = <SHORTEST> (k = <UNSIGNED_DECIMAL_INTEGER>)? (<PATH>|<PATHS>)? (<GROUP>|<GROUPS>) { selector = astFactory.shortestGroupsSelector(k != null ? k.image : null, pos(k), pos(s)); }
    | s = <SHORTEST> k = <UNSIGNED_DECIMAL_INTEGER> (<PATH>|<PATHS>)? { selector = astFactory.anyShortestPathSelector(k.image, pos(k), pos(s)); }
    )
    {
        return selector;
    }
}

PATTERN PathPatternNonEmpty() throws Exception:
{
    NODE_PATTERN n;
    REL_PATTERN r;
    List<PATTERN_ATOM> patternAtoms = new ArrayList<>();
    labelExpressionStack.push(ExpectBar.DO_NOT_EXPECT_BAR);
}
{
      n=NodePattern() { patternAtoms.add( n ); }
      (
        LOOKAHEAD( 2 ) r=RelationshipPattern() {patternAtoms.add( r );}
        n=NodePattern() { patternAtoms.add( n ); }
      )+
      {
        labelExpressionStack.pop();
        return astFactory.pathPattern( astFactory.patternElement( patternAtoms ) );
      }
}

NODE_PATTERN NodePattern() throws Exception:
{
    Token t;
    NODE_PATTERN n;
}
{
    t=<LPAREN>
    (
        // Shortcuts for node patterns not containing IS keyword or ambigious inlined WHERE
        LOOKAHEAD(<RPAREN>) n=NodePatternEmpty(t)
        | LOOKAHEAD(Variable() <RPAREN>) n=NodePatternOnlyVariable(t)
        | LOOKAHEAD(<COLON>) n=NodePatternColon(t)
        | LOOKAHEAD(Variable() <COLON>) n=NodePatternVariableColon(t)
        | LOOKAHEAD(<LCURLY>|<DOLLAR>) n=NodePatternProperties(t)
        | n=NodePatternComplex(t)
    )
    { return n; }
}

NODE_PATTERN NodePatternEmpty(Token t) throws Exception:
{}
{
    <RPAREN>
    {
        return astFactory.nodePattern( pos( t ), null, null, null, null );
    }
}

NODE_PATTERN NodePatternOnlyVariable(Token t) throws Exception:
{
    VARIABLE v = null;
}
{
    v = Variable()
    <RPAREN>
    {
        return astFactory.nodePattern( pos( t ), v, null, null, null );
    }
}

NODE_PATTERN NodePatternColon(Token t) throws Exception:
{
    LABEL_EXPRESSION labelExpression = null;
    EXPRESSION properties = null;
    EXPRESSION predicate = null;
}
{
    // From the LOOKAHEAD outside, we know this node pattern started with a colon,
    // so it must be of the form (labelExpression properties? WHERE?).
    labelExpression = LabelExpression(astFactory.nodeType())
    ( properties=Properties() )?
    ( <WHERE> predicate=Expression() )?
    <RPAREN>
    {
        return astFactory.nodePattern( pos( t ), null, labelExpression, properties, predicate );
    }
}

NODE_PATTERN NodePatternVariableColon(Token t) throws Exception:
{
    VARIABLE v = null;
    LABEL_EXPRESSION labelExpression = null;
    EXPRESSION properties = null;
    EXPRESSION predicate = null;
}
{
    // From the LOOKAHEAD outside, we know this node pattern started with variable followed by a colon,
    // so it must be of the form (variable labelExpression properties? WHERE?).
    v = Variable()
    labelExpression = LabelExpression(astFactory.nodeType())
    ( properties=Properties() )?
    ( <WHERE> predicate=Expression() )?
    <RPAREN>
    {
        return astFactory.nodePattern( pos( t ), v, labelExpression, properties, predicate );
    }
}

NODE_PATTERN NodePatternProperties(Token t) throws Exception:
{
    EXPRESSION properties = null;
    EXPRESSION predicate = null;
}
{
    // From the LOOKAHEAD outside, we know this node pattern started with a {,
    // so it must be of the form (properties WHERE?).
    properties=Properties()
    ( <WHERE> predicate=Expression() )?
    <RPAREN>
    {
        return astFactory.nodePattern( pos( t ), null, null, properties, predicate );
    }
}

NODE_PATTERN NodePatternComplex(Token t) throws Exception:
{
    VARIABLE v = null;
    LABEL_EXPRESSION labelExpression = null;
    EXPRESSION properties = null;
    EXPRESSION predicate = null;
}
{
    (
       // The general node pattern is  (variable? labelExpression? properties? WHERE?),
       // but since 'IS' and 'WHERE' can be both node variables, labels and keywords,
       // we must check all of the 2^4 combinations that has not been covered earlier
       // in a certain order to avoid ambiguity.
       // The below is a trial and error solution to make all tests in IsWhereNodePatternParserTest work
       // while also have each combination in exactly one branch below.
       (
       LOOKAHEAD(LabelExpression(astFactory.nodeType()) <WHERE> Expression() <RPAREN>)
            labelExpression = LabelExpression(astFactory.nodeType())
            <WHERE> predicate=Expression()
       | LOOKAHEAD(2) v=Variable() properties=Properties() ( <WHERE> predicate=Expression() )?
       | LOOKAHEAD(Variable() <WHERE> Expression() <RPAREN>) v=Variable() <WHERE> predicate=Expression()
       | LOOKAHEAD(<WHERE> Expression() <RPAREN>) <WHERE> predicate=Expression()
       | LOOKAHEAD(3) v=Variable()
            labelExpression = LabelExpression(astFactory.nodeType())
            ( properties=Properties() )?
            ( <WHERE> predicate=Expression() )?
       | LOOKAHEAD(LabelExpression(astFactory.nodeType()) Properties())
         labelExpression = LabelExpression(astFactory.nodeType())
            properties=Properties()
            ( <WHERE> predicate=Expression() )?
       | labelExpression = LabelExpression(astFactory.nodeType())
       )
    )
    <RPAREN>
    {
        return astFactory.nodePattern( pos( t ), v, labelExpression, properties, predicate );
    }
}

NODE_PATTERN InsertNodePattern() throws Exception:
{
    Token t;
    VARIABLE v = null;
    LABEL_EXPRESSION labelExpression = null;
    EXPRESSION properties = null;
}
{
    t=<LPAREN>
    (
       LOOKAHEAD(3) v=Variable() labelExpression = InsertNodeLabelExpression() ( properties=MapLiteral() )?
       | LOOKAHEAD(2) v=Variable() properties=MapLiteral()
       | LOOKAHEAD(2) labelExpression = InsertNodeLabelExpression() ( properties=MapLiteral() )?
       | properties=MapLiteral()
       | ( v = Variable() )?
    )
    <RPAREN>

    { return astFactory.nodePattern( pos( t ), v, labelExpression, properties, null); }
}

PATTERN_ATOM ParenthesizedPath() throws Exception:
{
    Token t;
    PATTERN p;
    VARIABLE v;
    EXPRESSION where = null;
    PATTERN_QUANTIFIER quantifier = null;
}
{
    t = <LPAREN> p = Pattern() ( <WHERE> where=Expression() )? <RPAREN> ( quantifier=Quantifier() )?
    {
        return astFactory.parenthesizedPathPattern( pos(t), p, where, quantifier );
    }
}

SET_ITEM SetNodeLabels(VARIABLE v) throws Exception:
{
    Token label;
    List<StringPos<POS>> labels = new ArrayList<>();
    List<EXPRESSION> dynamicLabels = new ArrayList<>();
    EXPRESSION e = null;
}
{
    (
        LOOKAHEAD( 2 ) label=LabelOrRelType() { labels.add( new StringPos<>( label.image, pos( label ) ) ); }
        | <COLON> <DOLLAR> <LPAREN> e=Expression() <RPAREN> { dynamicLabels.add( e ); }
    )+
    {
        return astFactory.setLabels( v, labels, dynamicLabels, false );
    }
}

SET_ITEM SetNodeLabelsIs(VARIABLE v) throws Exception:
{
    Token label;
    List<StringPos<POS>> labels = new ArrayList<>();
    List<EXPRESSION> dynamicLabels = new ArrayList<>();
    EXPRESSION e = null;
}
{
    <IS> (LOOKAHEAD( 2 ) label=SymbolicNameString() { labels.add( new StringPos<>( label.image, pos( label ) ) ); }
        | <DOLLAR> <LPAREN> e=Expression() <RPAREN> { dynamicLabels.add( e ); })
    (
        LOOKAHEAD( 2 ) label=LabelOrRelType() { labels.add( new StringPos<>( label.image, pos( label ) ) ); }
        | <COLON> <DOLLAR> <LPAREN> e=Expression() <RPAREN> { dynamicLabels.add( e ); }
    )*
    {
        return astFactory.setLabels( v, labels, dynamicLabels, true );
    }
}

REMOVE_ITEM RemoveNodeLabelsColon(VARIABLE v) throws Exception:
{
    Token label;
    List<StringPos<POS>> labels = new ArrayList<>();
    List<EXPRESSION> dynamicLabels = new ArrayList<>();
    EXPRESSION e = null;
}
{
    (
        LOOKAHEAD( 2 ) label=LabelOrRelType() { labels.add( new StringPos<>( label.image, pos( label ) ) ); }
        | <COLON> <DOLLAR> <LPAREN> e=Expression() <RPAREN> { dynamicLabels.add( e ); }
    )+
    {
        return astFactory.removeLabels( v, labels, dynamicLabels, false );
    }
}

REMOVE_ITEM RemoveNodeLabelsIs(VARIABLE v) throws Exception:
{
    Token label;
    List<StringPos<POS>> labels = new ArrayList<>();
    List<EXPRESSION> dynamicLabels = new ArrayList<>();
    EXPRESSION e = null;
}
{
    <IS> (
            <DOLLAR> <LPAREN> e=Expression() <RPAREN> { dynamicLabels.add( e ); }
            | label=SymbolicNameString() { labels.add( new StringPos<>( label.image, pos( label ) ) ); }
        )
    (
        LOOKAHEAD( 2 ) label=LabelOrRelType() { labels.add( new StringPos<>( label.image, pos( label ) ) ); }
        | <COLON> <DOLLAR> <LPAREN> e=Expression() <RPAREN> { dynamicLabels.add( e ); }
    )*
    {
        return astFactory.removeLabels( v, labels, dynamicLabels, true );
    }
}

EXPRESSION LabelExpressionPredicate(EXPRESSION subject) :
{
    LABEL_EXPRESSION exp = null;
}
{
    exp=LabelExpression(astFactory.nodeOrRelationshipType())
    {
        return astFactory.labelExpressionPredicate( subject, exp );
    }
}

Token LabelOrRelType() :
{
    Token t;
}
{
    <COLON> t=SymbolicNameString()
    {
        return t;
    }
}

List<StringPos<POS>> LabelOrRelTypes() :
{
    List<StringPos<POS>> labels = new ArrayList<>();
    StringPos<POS> label;
}
{
    <COLON> SymbolicNameString() { labels.add( new StringPos( token.image, pos(token) ) ); }
    ( <BAR> SymbolicNameString() { labels.add( new StringPos( token.image, pos(token) ) ); } )*
    {
        return labels;
    }
}

EXPRESSION Properties() throws Exception:
{
    EXPRESSION e;
}
{
    (
        LOOKAHEAD( 3 ) e=MapLiteral()
        | e=Parameter( ParameterType.ANY )
    )
    {
        return e;
    }
}

REL_PATTERN RelationshipPattern() throws Exception:
{
    Token firstToken = token;
    boolean left = false;
    REL_PATTERN r;
}
{
    ( LeftArrow() { left = true; })? ArrowLine()
    (
        // Shortcuts for rel patterns not containing IS keyword or ambigious inlined WHERE
        LOOKAHEAD(ArrowLine()) r=RelationshipPatternDoubleDash(firstToken, left)
        | <LBRACKET>
        (
            LOOKAHEAD(<RBRACKET>) r=RelationshipPatternEmpty(firstToken, left)
            | LOOKAHEAD(Variable() <RBRACKET>) r=RelationshipPatternOnlyVariable(firstToken, left)
            | LOOKAHEAD(<COLON>) r=RelationshipPatternColon(firstToken, left)
            | LOOKAHEAD(Variable() <COLON>) r=RelationshipPatternVariableColon(firstToken, left)
            | LOOKAHEAD(<LCURLY>|<DOLLAR>) r=RelationshipPatternProperties(firstToken, left)
            | LOOKAHEAD(PathLength()) r=RelationshipPatternPathLength(firstToken, left)
            | LOOKAHEAD(Variable() PathLength() <RBRACKET>)
                r=RelationshipPatternOnlyVariablePathLength(firstToken, left)
            | r=RelationshipPatternComplex(firstToken, left)
        )
    )
    {
        return r;
    }
}

REL_PATTERN RelationshipPatternDoubleDash(Token firstToken, boolean left) throws Exception:
{
    boolean right = false;
}
{
    ArrowLine() ( RightArrow() { right = true; } )?
    {
        return astFactory.relationshipPattern( pos( firstToken.next ), left, right, null, null, null, null, null );
    }
}

REL_PATTERN RelationshipPatternEmpty(Token firstToken, boolean left) throws Exception:
{
    boolean right = false;
}
{
    <RBRACKET>
    ArrowLine() ( RightArrow() { right = true; } )?
    {
        return astFactory.relationshipPattern( pos( firstToken.next ), left, right, null, null, null, null, null );
    }
}

REL_PATTERN RelationshipPatternOnlyVariable(Token firstToken, boolean left) throws Exception:
{
    boolean right = false;
    VARIABLE v = null;
}
{
    v=Variable()
    <RBRACKET>
    ArrowLine() ( RightArrow() { right = true; } )?
    {
        return astFactory.relationshipPattern( pos( firstToken.next ), left, right, v, null, null, null, null );
    }
}

REL_PATTERN RelationshipPatternColon(Token firstToken, boolean left) throws Exception:
{
    boolean right = false;
    LABEL_EXPRESSION labelExpression = null;
    PATH_LENGTH pathLength = null;
    EXPRESSION properties = null;
    EXPRESSION predicate = null;
}
{
    // From the LOOKAHEAD outside, we know this rel pattern started with a colon,
    // so it must be of the form [labelExpression pathLength? properties? WHERE?].
    labelExpression = LabelExpression(astFactory.relationshipType())
    ( pathLength=PathLength() )?
    ( properties=Properties() )?
    ( <WHERE> predicate=Expression() )?
    <RBRACKET>
    ArrowLine() ( RightArrow() { right = true; } )?
    {
        return astFactory.relationshipPattern( pos( firstToken.next ), left, right, null, labelExpression, pathLength, properties, predicate );
    }
}

REL_PATTERN RelationshipPatternVariableColon(Token firstToken, boolean left) throws Exception:
{
    boolean right = false;
    VARIABLE v = null;
    LABEL_EXPRESSION labelExpression = null;
    PATH_LENGTH pathLength = null;
    EXPRESSION properties = null;
    EXPRESSION predicate = null;
}
{
    // From the LOOKAHEAD outside, we know this rel pattern started with variable followed by a colon,
    // so it must be of the form [variable labelExpression pathLength? properties? WHERE?].
    v = Variable()
    labelExpression = LabelExpression(astFactory.relationshipType())
    ( pathLength=PathLength() )?
    ( properties=Properties() )?
    ( <WHERE> predicate=Expression() )?
    <RBRACKET>
    ArrowLine() ( RightArrow() { right = true; } )?
    {
        return astFactory.relationshipPattern( pos( firstToken.next ), left, right, v, labelExpression, pathLength, properties, predicate );
    }
}

REL_PATTERN RelationshipPatternProperties(Token firstToken, boolean left) throws Exception:
{
    boolean right = false;
    EXPRESSION properties = null;
    EXPRESSION predicate = null;
}
{
    // From the LOOKAHEAD outside, we know this rel pattern started with  a {,
    // so it must be of the form [properties WHERE?].
    properties=Properties()
    ( <WHERE> predicate=Expression() )?
    <RBRACKET>
    ArrowLine() ( RightArrow() { right = true; } )?
    {
        return astFactory.relationshipPattern( pos( firstToken.next ), left, right, null, null, null, properties, predicate );
    }
}

REL_PATTERN RelationshipPatternPathLength(Token firstToken, boolean left) throws Exception:
{
    boolean right = false;
    PATH_LENGTH pathLength = null;
    EXPRESSION properties = null;
    EXPRESSION predicate = null;
}
{
    // From the LOOKAHEAD outside, we know this rel pattern started with  a pathLength,
    // so it must be of the form [pathLength properties? WHERE?].
    pathLength=PathLength()
    ( properties=Properties() )?
    ( <WHERE> predicate=Expression() )?
    <RBRACKET>
    ArrowLine() ( RightArrow() { right = true; } )?
    {
        return astFactory.relationshipPattern( pos( firstToken.next ), left, right, null, null, pathLength, properties, predicate );
    }
}

REL_PATTERN RelationshipPatternOnlyVariablePathLength(Token firstToken, boolean left) throws Exception:
{
    boolean right = false;
    VARIABLE v = null;
    PATH_LENGTH pathLength = null;
}
{
    // From the LOOKAHEAD outside, we know this rel pattern must be of the form [variable pathLength].
    v=Variable()
    pathLength=PathLength()
    <RBRACKET>
    ArrowLine() ( RightArrow() { right = true; } )?
    {
        return astFactory.relationshipPattern( pos( firstToken.next ), left, right, v, null, pathLength, null, null );
    }
}

REL_PATTERN RelationshipPatternComplex(Token firstToken, boolean left) throws Exception:
{
    boolean right = false;
    VARIABLE v = null;
    LABEL_EXPRESSION labelExpression = null;
    PATH_LENGTH pathLength = null;
    EXPRESSION properties = null;
    EXPRESSION predicate = null;
}
{
    (
       // The general relationship pattern is  [variable? labelExpression? pathLength? properties? WHERE?],
       // but since 'IS' and 'WHERE' can be both relationship variables, types and keywords,
       // we must check all of the 2^5 combinations that has not been covered earlier in a certain order to avoid ambiguity.
       // The below is a trial and error solution to make all tests in IsWhereRelationshipPatternParserTest work
       // while also have each combination in exactly one branch below.
       (
       LOOKAHEAD(LabelExpression(astFactory.relationshipType()) ( pathLength=PathLength() )? <WHERE> Expression() <RBRACKET>)
            labelExpression = LabelExpression(astFactory.relationshipType())
            ( pathLength=PathLength() )?
            <WHERE> predicate=Expression()
       | LOOKAHEAD(v=Variable() ( PathLength() )? properties=Properties()) v=Variable()
            ( pathLength=PathLength() )?
            properties=Properties()
            ( <WHERE> predicate=Expression() )?
       | LOOKAHEAD(Variable() ( PathLength() )? <WHERE> Expression() <RBRACKET>) v=Variable() ( pathLength=PathLength() )? <WHERE> predicate=Expression()
       | LOOKAHEAD(<WHERE> Expression() <RBRACKET>) <WHERE> predicate=Expression()
       | LOOKAHEAD(3) v=Variable()
            labelExpression = LabelExpression(astFactory.relationshipType())
            ( pathLength=PathLength() )?
            ( properties=Properties() )?
            ( <WHERE> predicate=Expression() )?
       | LOOKAHEAD(LabelExpression(astFactory.relationshipType()) (PathLength())? Properties())
            labelExpression = LabelExpression(astFactory.relationshipType())
            ( pathLength=PathLength() )?
            properties=Properties()
            ( <WHERE> predicate=Expression() )?
       | labelExpression = LabelExpression(astFactory.relationshipType()) ( pathLength=PathLength() )?
       )
    )
    <RBRACKET>
    ArrowLine() ( RightArrow() { right = true; } )?
    {
        return astFactory.relationshipPattern( pos( firstToken.next ), left, right, v, labelExpression, pathLength, properties, predicate );
    }
}

REL_PATTERN InsertRelationshipPattern() throws Exception:
{
    Token firstToken = token;
    boolean left = false;
    boolean right = false;
    VARIABLE v = null;
    LABEL_EXPRESSION labelExpression = null;
    EXPRESSION properties = null;
}
{
    ( LeftArrow() { left = true; })? ArrowLine()
    <LBRACKET>
   (
   LOOKAHEAD(3) v=Variable() labelExpression = InsertRelationshipLabelExpression() ( properties=MapLiteral() )?
   | labelExpression = InsertRelationshipLabelExpression() ( properties=MapLiteral() )?
    )
    <RBRACKET>
    ArrowLine() ( RightArrow() { right = true; } )?
    {
        return astFactory.relationshipPattern( pos( firstToken.next ), left, right, v, labelExpression, null, properties, null );
    }
}

void LeftArrow() :
{}
{
  <LT> | <ARROW_LEFT_HEAD>
}

void ArrowLine() :
{}
{
  <ARROW_LINE> | <MINUS>
}

void RightArrow() :
{}
{
  <GT> | <ARROW_RIGHT_HEAD>
}

PATH_LENGTH PathLength() :
{
    Token t;
    PATH_LENGTH p = null;
}
{
    t=<TIMES> ( p=PathLengthLiteral( t ) )?
    {
        return p == null ? astFactory.pathLength( pos( t ), null, null, null, null ) : p;
    }
}

PATH_LENGTH PathLengthLiteral( Token t ) :
{
    Token v1 = null;
    Token v2 = null;
}
{
    LOOKAHEAD( 2 ) ( v1=<UNSIGNED_DECIMAL_INTEGER> )? t=<DOTDOT> ( v2=<UNSIGNED_DECIMAL_INTEGER> )?
        {
            return astFactory.pathLength( pos( t ), v1 == null ? null : pos ( v1 ), v2 == null ? null : pos ( v2 ),  v1 == null ? "" : v1.image, v2 == null ? "" : v2.image );
        }
    | v1=<UNSIGNED_DECIMAL_INTEGER>
        {
            String v = v1 == null ? "" : v1.image;
            return astFactory.pathLength( pos( t ), v1 == null ? null : pos ( v1 ), v1 == null ? null : pos ( v1 ), v, v);
        }
}

// LABEL EXPRESSIONS

LABEL_EXPRESSION LabelExpression( ENTITY_TYPE type ) :
{
    LABEL_EXPRESSION e;
}
{
    (
        (<COLON> (
            LOOKAHEAD({ !labelExpressionStack.isEmpty() && labelExpressionStack.peek() == ExpectBar.EXPECT_BAR})
            e = LabelExpression4ExpectingBar(type)
            |
            LOOKAHEAD({ labelExpressionStack.isEmpty() || labelExpressionStack.peek() == ExpectBar.DO_NOT_EXPECT_BAR})
            e = LabelExpression4(type)
        ))
        |
        (<IS> (
            LOOKAHEAD({ !labelExpressionStack.isEmpty() && labelExpressionStack.peek() == ExpectBar.EXPECT_BAR})
            e = LabelExpression4ExpectingBarIs(type)
            |
            LOOKAHEAD({ labelExpressionStack.isEmpty() || labelExpressionStack.peek() == ExpectBar.DO_NOT_EXPECT_BAR})
            e = LabelExpression4Is(type)
        ))
    )
    {
        return e;
    }
}

LABEL_EXPRESSION LabelExpression4( ENTITY_TYPE type ) :
{
    Token t;
    LABEL_EXPRESSION e;
    LABEL_EXPRESSION temp;
}
{
    e=LabelExpression3(type) (
        LOOKAHEAD(2)
        t=<BAR>
        (
            <COLON> temp=LabelExpression3(type) { e = astFactory.labelColonDisjunction( pos( t ), e, temp, false ); }
        |
            temp=LabelExpression3(type) { e = astFactory.labelDisjunction( pos( t ), e, temp, false ); }
        )
    )*
    {
        return e;
    }
}


LABEL_EXPRESSION LabelExpression4Is( ENTITY_TYPE type ) :
{
    Token t;
    LABEL_EXPRESSION e;
    LABEL_EXPRESSION temp;
}
{
    e=LabelExpression3Is(type) (
        LOOKAHEAD(2)
        t=<BAR>
        (
            <COLON> temp=LabelExpression3Is(type) { e = astFactory.labelColonDisjunction( pos( t ), e, temp, true ); }
        |
            temp=LabelExpression3Is(type) { e = astFactory.labelDisjunction( pos( t ), e, temp, true ); }
        )
    )*
    {
        return e;
    }
}
LABEL_EXPRESSION LabelExpression4ExpectingBar( ENTITY_TYPE type ) :
{
    Token t;
    LABEL_EXPRESSION e;
    LABEL_EXPRESSION temp;
}
{
    e=LabelExpression3(type) (
        LOOKAHEAD(
            <BAR> (<COLON>)? LabelExpression3() <BAR>
        )
        t=<BAR>
        (
            <COLON> temp=LabelExpression3(type) { e = astFactory.labelColonDisjunction( pos( t ), e, temp, false ); }
        |
            temp=LabelExpression3(type) { e = astFactory.labelDisjunction( pos( t ), e, temp, false ); }
        )
    )*
    {
        return e;
    }
}

LABEL_EXPRESSION LabelExpression4ExpectingBarIs( ENTITY_TYPE type ) :
{
    Token t;
    LABEL_EXPRESSION e;
    LABEL_EXPRESSION temp;
}
{
    e=LabelExpression3Is(type) (
        LOOKAHEAD(
            <BAR> (<COLON>)? LabelExpression3Is() <BAR>
        )
        t=<BAR>
        (
            <COLON> temp=LabelExpression3Is(type) { e = astFactory.labelColonDisjunction( pos( t ), e, temp, true ); }
        |
            temp=LabelExpression3Is(type) { e = astFactory.labelDisjunction( pos( t ), e, temp, true ); }
        )
    )*
    {
        return e;
    }
}

LABEL_EXPRESSION LabelExpression3( ENTITY_TYPE type ) :
{
    Token t;
    LABEL_EXPRESSION e;
    LABEL_EXPRESSION temp;
}
{
    e=LabelExpression2(type)
    (
        LOOKAHEAD(2)
        (
            t=<AMPERSAND> temp=LabelExpression2(type) { e = astFactory.labelConjunction( pos( t ), e, temp, false ); }
        |
            t=<COLON> temp=LabelExpression2(type) { e = astFactory.labelColonConjunction( pos( t ), e, temp, false ); }
        )
    )*
    {
        return e;
    }
}


LABEL_EXPRESSION LabelExpression3Is( ENTITY_TYPE type ) :
{
    Token t;
    LABEL_EXPRESSION e;
    LABEL_EXPRESSION temp;
}
{
    e=LabelExpression2Is(type)
    (
        LOOKAHEAD(2)
        (
            t=<AMPERSAND> temp=LabelExpression2Is(type) { e = astFactory.labelConjunction( pos( t ), e, temp, true ); }
        |
            t=<COLON> temp=LabelExpression2Is(type) { e = astFactory.labelColonConjunction( pos( t ), e, temp, true ); }
        )
    )*
    {
        return e;
    }
}

LABEL_EXPRESSION LabelExpression2( ENTITY_TYPE type ) :
{
    Token t;
    LABEL_EXPRESSION e;
}
{
    (
        LOOKAHEAD( 3 ) t=<EXCLAMATION_MARK> e=LabelExpression2(type) { e = astFactory.labelNegation( pos( t ), e, false ); }
        | e=LabelExpression1(type)
    )
    {
        return e;
    }
}

LABEL_EXPRESSION LabelExpression2Is( ENTITY_TYPE type ) :
{
    Token t;
    LABEL_EXPRESSION e;
}
{
    (
        LOOKAHEAD( 3 ) t=<EXCLAMATION_MARK> e=LabelExpression2Is(type) { e = astFactory.labelNegation( pos( t ), e, true ); }
        | e=LabelExpression1Is(type)
    )
    {
        return e;
    }
}

LABEL_EXPRESSION LabelExpression1( ENTITY_TYPE type ) :
{
    LABEL_EXPRESSION e = null;
    String label = null;
    Token t;
    labelExpressionStack.push(ExpectBar.DO_NOT_EXPECT_BAR);
}
{
    (
        <LPAREN> e=LabelExpression4(type) <RPAREN>
        | t = <PERCENT> { e = astFactory.labelWildcard( pos ( t ), false ); }
        | t=SymbolicNameString() { e = astFactory.labelLeaf( pos ( t ), t.image, type, false ); }
    )
    {
        labelExpressionStack.pop();
        return e;
    }
}

LABEL_EXPRESSION LabelExpression1Is( ENTITY_TYPE type ) :
{
    LABEL_EXPRESSION e = null;
    String label = null;
    Token t;
    labelExpressionStack.push(ExpectBar.DO_NOT_EXPECT_BAR);
}
{
    (
        <LPAREN> e=LabelExpression4Is(type) <RPAREN>
        | t = <PERCENT> { e = astFactory.labelWildcard( pos ( t ), true ); }
        | t=SymbolicLabelNameString() { e = astFactory.labelLeaf( pos ( t ), t.image, type, true ); }
    )
    {
        labelExpressionStack.pop();
        return e;
    }
}

LABEL_EXPRESSION InsertNodeLabelExpression() throws Exception:
{
    Token t;
    LABEL_EXPRESSION e;
    LABEL_EXPRESSION temp;
    boolean containsIs = false;
}
{
    (
        <COLON> | <IS>  { containsIs = true; } ) e = InsertLabelConjunction(astFactory.nodeType(), containsIs
    )
    {
        return e;
    }
}

LABEL_EXPRESSION InsertRelationshipLabelExpression() throws Exception:
{
    LABEL_EXPRESSION e;
    boolean containsIs = false;
}
{
    (
        <COLON> | <IS>  { containsIs = true; } ) e = InsertLabelLeaf(astFactory.relationshipType(), containsIs
    )
    {
        return e;
    }
}

LABEL_EXPRESSION InsertLabelConjunction( ENTITY_TYPE type, boolean containsIs) throws Exception:
{
    Token t;
    Token errorStart = null;
    LABEL_EXPRESSION e;
    LABEL_EXPRESSION temp;
}
{
    e=InsertLabelLeaf(type, containsIs)
    (
        LOOKAHEAD(2)
        (
            t=<AMPERSAND> temp=InsertLabelLeaf(type, containsIs) { e = astFactory.labelConjunction( pos( t ), e, temp, containsIs ); }
        |
            errorStart=<COLON>
        )
    )*
    {
        if (errorStart != null)
        {
            throw exceptionFactory.syntaxException(
                new ParseException( ASTExceptionFactory.colonConjunctionInInsertNotSupported ),
                errorStart.beginOffset, errorStart.beginLine, errorStart.beginColumn );
        }
        return e;
    }
}


LABEL_EXPRESSION InsertLabelLeaf( ENTITY_TYPE type, boolean containsIs ) :
{
    Token t;
}
{
    t=SymbolicNameString()
    {
        return astFactory.labelLeaf( pos ( t ), t.image, type, containsIs );
    }
}

// EXPRESSIONS

EXPRESSION Expression() throws Exception:
{
    EXPRESSION e;
}
{
    e=Expression12()
    {
        return e;
    }
}

EXPRESSION Expression12() throws Exception:
{
    Token t;
    EXPRESSION e;
    EXPRESSION temp;
}
{
    e=Expression11() ( t=<OR> temp=Expression11() { e = astFactory.or( pos( t ), e, temp ); } )*
    {
        return e;
    }
}

EXPRESSION Expression11() throws Exception:
{
    Token t;
    EXPRESSION e;
    EXPRESSION temp;
}
{
    e=Expression10() ( t=<XOR> temp=Expression10() { e = astFactory.xor( pos( t ), e, temp ); } )*
    {
        return e;
    }
}

EXPRESSION Expression10() throws Exception:
{
    Token t;
    EXPRESSION e;
    EXPRESSION temp;
}
{
    e=Expression9() (t=<AND> temp=Expression9() { e = astFactory.and( pos( t ), e, temp ); } )*
    {
        return e;
    }
}

EXPRESSION Expression9() throws Exception:
{
    Token t;
    EXPRESSION e;
}
{
    (
        LOOKAHEAD( 3 ) t=<NOT> e=Expression9() { e = astFactory.not( pos( t ), e ); }
        | e=Expression8()
    )
    {
        return e;
    }
}

/**
 * Implements comparison operation chaining. That is that expressions like `a < b < c` are interpreted as `a < b AND b < c`.
 * See https://neo4j.com/docs/cypher-manual/current/syntax/operators/#cypher-operations-chaining
 */
EXPRESSION Expression8() throws Exception:
{
    Token t;
    EXPRESSION e;
    EXPRESSION lhs;
    EXPRESSION rhs;
    List<EXPRESSION> expressions = new ArrayList();
}
{
    e=Expression7() { lhs = e; } (
        LOOKAHEAD( 2 ) t=<EQ>  rhs=Expression7() { expressions.add( astFactory.eq( pos( t ), lhs, rhs)); lhs = rhs; }
        | t=<NEQ> rhs=Expression7() { expressions.add( astFactory.neq( pos( t ), lhs, rhs ) ); lhs = rhs; }
        | t=<NEQ2> rhs=Expression7() { expressions.add( astFactory.neq2( pos( t ), lhs, rhs ) ); lhs = rhs; }
        | t=<LE> rhs=Expression7() { expressions.add( astFactory.lte( pos( t ), lhs, rhs ) ); lhs = rhs; }
        | t=<GE> rhs=Expression7() { expressions.add( astFactory.gte( pos( t ), lhs, rhs ) ); lhs = rhs; }
        | t=<LT> rhs=Expression7() { expressions.add( astFactory.lt( pos( t ), lhs, rhs ) ); lhs = rhs; }
        | t=<GT> rhs=Expression7() { expressions.add( astFactory.gt( pos( t ), lhs, rhs ) ); lhs = rhs; }
    )*
    {
        if ( expressions.isEmpty() )
        {
            return e;
        }
        else if ( expressions.size() == 1 )
        {
            return expressions.get( 0 );
        }
        else
        {
            return astFactory.ands( expressions );
        }
    }
}

EXPRESSION Expression8ComparatorExpression( EXPRESSION lhs ) throws Exception:
{
    Token t;
    EXPRESSION e;
    EXPRESSION rhs;
}
{
        LOOKAHEAD( 2 ) t=<EQ>  rhs=Expression7() { return astFactory.eq( pos( t ), lhs, rhs); }
        | t=<NEQ> rhs=Expression7() { return astFactory.neq( pos( t ), lhs, rhs ); }
        | t=<NEQ2> rhs=Expression7() { return astFactory.neq2( pos( t ), lhs, rhs ); }
        | t=<LE> rhs=Expression7() { return astFactory.lte( pos( t ), lhs, rhs ); }
        | t=<GE> rhs=Expression7() { return astFactory.gte( pos( t ), lhs, rhs ); }
        | t=<LT> rhs=Expression7() { return astFactory.lt( pos( t ), lhs, rhs ); }
        | t=<GT> rhs=Expression7() { return astFactory.gt( pos( t ), lhs, rhs ); }
}

EXPRESSION Expression7() throws Exception:
{
    EXPRESSION e;
}
{
    e=Expression6() ( e=ComparisonExpression6( e ) )?
    {
        return e;
    }
}

EXPRESSION ComparisonExpression6( EXPRESSION lhs ) throws Exception:
{
    Token t;
    EXPRESSION rhs;
    ParserCypherTypeName typeName;
    ParserNormalForm normalForm;
}
{
    LOOKAHEAD( 2 ) t=<REGEQ> rhs=Expression6() { return astFactory.regeq( pos( t ), lhs, rhs ); }
    | t=<STARTS> <WITH> rhs=Expression6() { return astFactory.startsWith( pos( t ), lhs, rhs ); }
    | t=<ENDS> <WITH> rhs=Expression6() { return astFactory.endsWith( pos( t ), lhs, rhs ); }
    | t=<CONTAINS> rhs=Expression6() { return astFactory.contains( pos( t ), lhs, rhs ); }
    | t=<IN> rhs=Expression6() { return astFactory.in( pos( t ), lhs, rhs ); }
    | t=<IS> (
        <NULL> { return astFactory.isNull( pos( t ), lhs ); }
        | <NOT> (
            <NULL> { return astFactory.isNotNull( pos( t ), lhs ); }
            | ((<TYPED> | <COLONCOLON>) typeName = cypherTypeName() { return astFactory.isNotTyped( pos( t ), lhs, typeName ); })
            | (normalForm = normalForm() <NORMALIZED> { return astFactory.isNotNormalized( pos( t ), lhs, normalForm ); })
        )
        | (<TYPED> | <COLONCOLON>) typeName = cypherTypeName() { return astFactory.isTyped( pos( t ), lhs, typeName ); }
        |  normalForm = normalForm() <NORMALIZED>{ return astFactory.isNormalized( pos( t ), lhs, normalForm ); }

    )
    | t=<COLONCOLON> typeName = cypherTypeName() { return astFactory.isTyped( pos( t ), lhs, typeName ); }
}

ParserNormalForm normalForm():
{
    ParserNormalForm normalForm = ParserNormalForm.NFC;
}
{
        (
          <NFC>
          | <NFD> { normalForm = ParserNormalForm.NFD; }
          | <NFKC> { normalForm = ParserNormalForm.NFKC; }
          | <NFKD> { normalForm = ParserNormalForm.NFKD; }
        )?
        { return normalForm; }
}

EXPRESSION Expression6() throws Exception:
{
    Token t;
    EXPRESSION lhs;
    EXPRESSION rhs;
}
{
    lhs=Expression5() (
        t=<PLUS> rhs=Expression5() { lhs = astFactory.plus( pos( t ), lhs, rhs); }
        | t=<MINUS> rhs=Expression5() { lhs = astFactory.minus( pos( t ), lhs, rhs); }
        | t=<DOUBLEBAR> rhs=Expression5() { lhs = astFactory.concatenate( pos( t ), lhs, rhs); }
    )*
    {
        return lhs;
    }
}

EXPRESSION Expression5() throws Exception:
{
    Token t;
    EXPRESSION lhs;
    EXPRESSION rhs;
}
{
    lhs=Expression4() (
        t=<TIMES> rhs=Expression4() { lhs = astFactory.multiply( pos( t ), lhs, rhs ); }
        | t=<DIVIDE> rhs=Expression4() { lhs = astFactory.divide( pos( t ), lhs, rhs ); }
        | t=<PERCENT> rhs=Expression4() { lhs = astFactory.modulo( pos( t ), lhs, rhs ); }
    )*
    {
        return lhs;
    }
}

EXPRESSION Expression4() throws Exception:
{
    Token t;
    EXPRESSION lhs;
    EXPRESSION rhs;
}
{
    lhs=Expression3() ( t=<POW> rhs=Expression3() { lhs = astFactory.pow( pos( t ), lhs, rhs ); } )*
    {
        return lhs;
    }
}

EXPRESSION Expression3() throws Exception:
{
    Token t;
    EXPRESSION e;
}
{
    (
        LOOKAHEAD(3) e=Expression2()
        | t = <PLUS> e=Expression2() { e = astFactory.unaryPlus( pos( t ), e ); }
        | t = <MINUS> e=Expression2() { e = astFactory.unaryMinus( pos( t ), e ); }
    )
    {
        return e;
    }
}

EXPRESSION Expression2() throws Exception:
{
    EXPRESSION e;
}
{
    e=Expression1()
    ( LOOKAHEAD(<DOT> | <LBRACKET> | <COLON> | <IS> (<EXCLAMATION_MARK> | <PERCENT> | <LPAREN> | SymbolicLabelNameString() ))
        e=PostFix1( e ) )*
    {
        return e;
    }
}

EXPRESSION PostFix1( EXPRESSION subject ) throws Exception:
{
    Token t;
    EXPRESSION e1 = null;
    EXPRESSION e2 = null;
    EXPRESSION ret;
}
{
    (
        ret=Property( subject )
        | LOOKAHEAD(<COLON>) ret=LabelExpressionPredicate( subject )
        | LOOKAHEAD(<IS> (<EXCLAMATION_MARK> | <PERCENT> | <LPAREN> | SymbolicLabelNameString())) ret=LabelExpressionPredicate( subject )
        | LOOKAHEAD(<LBRACKET> Expression() <RBRACKET>) <LBRACKET> e1=Expression() <RBRACKET> { ret=astFactory.listLookup( subject, e1 ); }
        | t=<LBRACKET> ( e1=Expression() )? <DOTDOT> ( e2=Expression() )? <RBRACKET> { ret=astFactory.listSlice( pos( t ), subject, e1, e2 ); }
    )
    {
        return ret;
    }
}

PROPERTY Property( EXPRESSION subject ) :
{
    EXPRESSION e;
    StringPos<POS> propKeyName;
}
{
    <DOT> propKeyName=PropertyKeyName()
    {
        return astFactory.property( subject, propKeyName );
    }
}

EXPRESSION DynamicPropertyExpression() throws Exception:
{
    EXPRESSION subject;
    EXPRESSION e;
}
{
    subject=Expression1() e=DynamicProperty( subject )
    {
        return e; 
    }
}

PROPERTY PropertyExpression() throws Exception:
{
    EXPRESSION subject;
    PROPERTY p;
}
{
    subject=Expression1() ( p=Property( subject ) { subject = p; } )+
    {
        return p;
    }
}

EXPRESSION DynamicProperty( EXPRESSION subject ) throws Exception:
{
    EXPRESSION e;
}
{
    <LBRACKET> e=Expression() <RBRACKET> 
    {
        return astFactory.listLookup( subject, e ); 
    }
}

EXPRESSION Expression1() throws Exception:
{
    EXPRESSION e = null;
    Token t;
}
{
    (
        e=NumberLiteral()
        | e=StringLiteral()
        | e=Parameter( ParameterType.ANY )
        | t=<TRUE> { e = astFactory.newTrueLiteral( pos( t ) ); }
        | t=<FALSE> { e = astFactory.newFalseLiteral( pos( t ) ); }
        | ( t=<INFINITY> | t=<INF> ) { e = astFactory.newInfinityLiteral( pos( t ) ); }
        | t=<NAN> { e = astFactory.newNaNLiteral( pos( t ) ); }
        | LOOKAHEAD( 2 ) t=<NULL> { e = astFactory.newNullLiteral( pos( t ) ); }
        | LOOKAHEAD( 3 ) e=CaseExpression()
        | LOOKAHEAD( 3 ) t=<COUNT> <LPAREN> <TIMES> <RPAREN> { e = astFactory.newCountStar( pos( t ) ); }
        | LOOKAHEAD( 3 ) e=MapLiteral()
        | LOOKAHEAD( 3 ) e=ExistsExpression() // `exists { match` should not be a map-projection
        | LOOKAHEAD( 3 ) e=CountExpression()
        | LOOKAHEAD( 3 ) e=CollectExpression()
        | LOOKAHEAD( 2 ) e=MapProjection()
        | LOOKAHEAD( <LBRACKET> v=Variable() <IN> e=Expression() ( <WHERE> | <BAR> | <RBRACKET> )) e=ListComprehension() // before literal because it takes precedence. Lookahead due to potential confusion with ListLiteral
        | LOOKAHEAD( PatternComprehensionPrefix() ) e=PatternComprehension() // Only after matching up to "WHERE" or "|" can we be sure it is a PatternComprehension and not a ListLiteral.
        | LOOKAHEAD( 3 ) e=ListLiteral()
        | LOOKAHEAD( 3 ) e=ReduceExpression()
        | LOOKAHEAD( 3 ) e=AllExpression()
        | LOOKAHEAD( 3 ) e=AnyExpression()
        | LOOKAHEAD( 3 ) e=NoneExpression()
        | LOOKAHEAD( 3 ) e=SingleExpression()
        | LOOKAHEAD( 2 ) e=NormalizeExpression()
        | LOOKAHEAD( 2 ) e=TrimFunction()
        | LOOKAHEAD( NodePattern() RelationshipPattern() ) e=PatternExpression()
        | LOOKAHEAD( 2 ) e=ShortestPathExpression()
        | <LPAREN>
          { labelExpressionStack.push(ExpectBar.DO_NOT_EXPECT_BAR); }
          e=Expression()
          { labelExpressionStack.pop(); }
          <RPAREN>
        | LOOKAHEAD( (SymbolicNameString() <DOT> )* SymbolicNameString() <LPAREN> ) e=FunctionInvocation(false)
        | e=Variable()
    )
    {
        return e;
    }
}

EXPRESSION CaseExpression() throws Exception:
{
    EXPRESSION e = null;
}
{
    (
        LOOKAHEAD( <CASE> Expression() <WHEN> ) e=SimpleCaseExpression()
        | e=GeneralCaseExpression()
    )
    {
        return e;
    }
}

EXPRESSION SimpleCaseExpression() throws Exception:
{
    Token t;
    EXPRESSION caseExpr;
    EXPRESSION e;
    List<EXPRESSION> tempWhen = new ArrayList<>();
    List<EXPRESSION> when = new ArrayList<>();
    List<EXPRESSION> then = new ArrayList<>();
    EXPRESSION elseCase = null;
}
{
    t=<CASE>  caseExpr=Expression()
    <WHEN> tempWhen=simpleCaseWhenOperandList(caseExpr) { when.addAll( tempWhen ); }
    <THEN> e=Expression() { for (var i = 0; i < tempWhen.size(); i++) { then.add( e ); } }
    (
        <WHEN> tempWhen=simpleCaseWhenOperandList(caseExpr) { when.addAll( tempWhen ); }
        <THEN> e=Expression() { for (var i = 0; i < tempWhen.size(); i++) { then.add( e ); } }
    )*
    ( <ELSE> elseCase=Expression() )?
    <END>
    {
        return astFactory.caseExpression( pos( t ), caseExpr, when, then, elseCase);
    }
}

List<EXPRESSION> simpleCaseWhenOperandList( EXPRESSION caseExpr ) throws Exception:
{
    EXPRESSION e;
    List<EXPRESSION> list = new ArrayList<>();
}
{
    e=whenOperand( caseExpr ) { list.add( e ); }
    ( LOOKAHEAD(2) <COMMA> e=whenOperand( caseExpr ) { list.add( e ); } )*
    {
        return list;
    }
}

EXPRESSION whenOperand( EXPRESSION lhs ) throws Exception:
{
    Token t;
    EXPRESSION e;
    EXPRESSION rhs;
    ParserCypherTypeName typeName;
    ParserNormalForm normalForm;
}
{
    { t = token; }
    (
         t=<REGEQ> rhs=Expression6() { return astFactory.regeq( pos( t ), lhs, rhs ); }
         | t=<STARTS> <WITH> rhs=Expression6() { return astFactory.startsWith( pos( t ), lhs, rhs ); }
         | t=<ENDS> <WITH> rhs=Expression6() { return astFactory.endsWith( pos( t ), lhs, rhs ); }
         | LOOKAHEAD( 3 ) t=<IS> <NULL> { return astFactory.isNull( pos( t ), lhs ); }
         | LOOKAHEAD( 3 ) t=<IS> <NOT> <NULL> { return astFactory.isNotNull( pos( t ), lhs ); }
         | LOOKAHEAD( 3 ) t=<IS> (normalForm = normalForm()) <NORMALIZED> { return astFactory.isNormalized( pos( t ), lhs, normalForm ); }
         | LOOKAHEAD( 3 ) t=<IS> <NOT> (normalForm = normalForm()) <NORMALIZED> { return astFactory.isNotNormalized( pos( t ), lhs, normalForm ); }
         | LOOKAHEAD( 3 ) t=<IS> <TYPED> typeName = cypherTypeName() { return astFactory.isTyped( pos( t ), lhs, typeName ); }
         | LOOKAHEAD( 3 ) t=<IS> <NOT> <TYPED> typeName = cypherTypeName() { return astFactory.isNotTyped( pos( t ), lhs, typeName ); }
         | t=<COLONCOLON> typeName = cypherTypeName() { return astFactory.isTyped( pos( t ), lhs, typeName ); }
         | e=Expression8ComparatorExpression( lhs )  { return e; }
         | e=Expression() { return astFactory.eq( pos( t ), lhs, e); }
    )
}

EXPRESSION GeneralCaseExpression() throws Exception:
{
    Token t;
    EXPRESSION caseExpr = null;
    EXPRESSION e;
    List<EXPRESSION> when = new ArrayList<>();
    List<EXPRESSION> then = new ArrayList<>();
    EXPRESSION elseCase = null;
}
{
    t=<CASE>
    <WHEN> e=Expression() { when.add( e ); }
    <THEN> e=Expression() { then.add( e ); }
    (
        <WHEN> e=Expression() { when.add( e ); }
        <THEN> e=Expression() {then.add( e );}
    )*
    ( <ELSE> elseCase=Expression() )?
    <END>
    {
        return astFactory.caseExpression( pos( t ), caseExpr, when, then, elseCase);
    }
}

EXPRESSION ListComprehension() throws Exception:
{
    Token t;
    VARIABLE v;
    EXPRESSION e;
    EXPRESSION where = null;
    EXPRESSION projection = null;
    labelExpressionStack.push(ExpectBar.EXPECT_BAR);
}
{
    t=<LBRACKET> v=Variable() <IN> e=Expression() ( <WHERE> where=Expression() )? ( <BAR> projection=Expression() )? <RBRACKET>
    {
        labelExpressionStack.pop();
        return astFactory.listComprehension( pos( t ), v, e, where, projection );
    }
}

EXPRESSION PatternComprehension() throws Exception:
{
    Token t;
    Token relationshipPatternPosition;
    VARIABLE v = null;
    PATTERN p;
    EXPRESSION where = null;
    EXPRESSION projection = null;
}
{
    t=<LBRACKET> ( v=Variable() <EQ> )? {relationshipPatternPosition = token;} p=PathPatternNonEmpty()
    ( <WHERE> {
        labelExpressionStack.push(ExpectBar.EXPECT_BAR);
      }
      where=Expression()
      {
        labelExpressionStack.pop();
      }
    )? <BAR> projection=Expression() <RBRACKET>
    {
        return astFactory.patternComprehension( pos( t ), pos( relationshipPatternPosition.next ), v, p, where, projection );
    }
}

void PatternComprehensionPrefix() throws Exception:
{}
{
    <LBRACKET> ( Variable() <EQ> )? PathPatternNonEmpty() ( <WHERE> | <BAR> )
}

EXPRESSION ReduceExpression() throws Exception:
{
    Token t;
    VARIABLE acc;
    EXPRESSION accExpr;
    VARIABLE v;
    EXPRESSION vExpr;
    EXPRESSION innerExpr;
}
{
    t=<REDUCE>
    <LPAREN>
        acc=Variable() <EQ> accExpr=Expression()
        <COMMA> v=Variable() <IN> vExpr=Expression()
        <BAR> innerExpr=Expression()
    <RPAREN>
    {
        return astFactory.reduceExpression( pos( t ), acc, accExpr, v, vExpr, innerExpr );
    }
}

EXPRESSION AllExpression() throws Exception:
{
    Token t;
    VARIABLE v;
    EXPRESSION e;
    EXPRESSION where = null;
}
{
    t=<ALL> <LPAREN> v=Variable() <IN> e=Expression() ( <WHERE> where=Expression() )? <RPAREN>
    {
        return astFactory.allExpression( pos( t ), v, e, where );
    }
}

EXPRESSION AnyExpression() throws Exception:
{
    Token t;
    VARIABLE v;
    EXPRESSION e;
    EXPRESSION where = null;
}
{
    t=<ANY> <LPAREN> v=Variable() <IN> e=Expression() ( <WHERE> where=Expression() )? <RPAREN>
    {
        return astFactory.anyExpression( pos( t ), v, e, where );
    }
}

EXPRESSION NoneExpression() throws Exception:
{
    Token t;
    VARIABLE v;
    EXPRESSION e;
    EXPRESSION where = null;
}
{
    t=<NONE> <LPAREN> v=Variable() <IN> e=Expression() ( <WHERE> where=Expression() )? <RPAREN>
    {
        return astFactory.noneExpression( pos( t ), v, e, where );
    }
}

EXPRESSION SingleExpression() throws Exception:
{
    Token t;
    VARIABLE v;
    EXPRESSION e;
    EXPRESSION where = null;
}
{
    t=<SINGLE> <LPAREN> v=Variable() <IN> e=Expression() ( <WHERE> where=Expression() )? <RPAREN>
    {
        return astFactory.singleExpression( pos( t ), v, e, where );
    }
}

EXPRESSION NormalizeExpression() throws Exception:
{
    Token t;
    EXPRESSION e;
    ParserNormalForm normalForm = ParserNormalForm.NFC;
}
{
    t=<NORMALIZE> <LPAREN>
        e=Expression()
        (<COMMA> (
          <NFC>
          | <NFD> { normalForm = ParserNormalForm.NFD; }
          | <NFKC> { normalForm = ParserNormalForm.NFKC; }
          | <NFKD> { normalForm = ParserNormalForm.NFKD; }
        ))?
        <RPAREN>
    {
        return astFactory.normalizeExpression( pos( t ), e, normalForm );
    }
}


EXPRESSION TrimFunction() throws Exception:
{
    Token t;
    EXPRESSION trimCharacterString = null;
    EXPRESSION trimSource = null;
    EXPRESSION expression = null;
    ParserTrimSpecification trimSpec = ParserTrimSpecification.BOTH;
}
{
    t=<TRIM> <LPAREN>
    // TRIM(FROM <expr>)
    (LOOKAHEAD(<FROM>) <FROM> trimSource=Expression() <RPAREN> { return astFactory.trimFunction( pos( t ), trimSpec, trimCharacterString, trimSource ); }
    // TRIM(BOTH/LEADING/TRAILING FROM <expr>)
    | LOOKAHEAD((<BOTH> | <LEADING> | <TRAILING>) <FROM>)
        ( <BOTH> | <LEADING> { trimSpec = ParserTrimSpecification.LEADING; } | <TRAILING> { trimSpec = ParserTrimSpecification.TRAILING; })
            <FROM> trimSource=Expression() <RPAREN> { return astFactory.trimFunction( pos( t ), trimSpec, trimCharacterString, trimSource ); }
    // TRIM(BOTH/LEADING/TRAILING <expr> FROM <expr>)
    | LOOKAHEAD(<BOTH> | <LEADING> | <TRAILING>)
        ( <BOTH> | <LEADING> { trimSpec = ParserTrimSpecification.LEADING; } | <TRAILING> { trimSpec = ParserTrimSpecification.TRAILING; })
        trimCharacterString = Expression() <FROM> trimSource=Expression() <RPAREN> { return astFactory.trimFunction( pos( t ), trimSpec, trimCharacterString, trimSource ); }
    // TRIM(<expr> FROM <expr>) or TRIM(<expr>)
    | expression = Expression()
        (LOOKAHEAD(<RPAREN>) (<RPAREN> { return astFactory.trimFunction( pos( t ), trimSpec, trimCharacterString, expression ); })
        | <FROM> trimSource=Expression() <RPAREN> { return astFactory.trimFunction( pos( t ), trimSpec, expression, trimSource ); }))
}


EXPRESSION PatternExpression() throws Exception:
{
    PATTERN p;
    Token t;
}
{
    { t = token; }
    p=PathPatternNonEmpty()
    {
        return astFactory.patternExpression( pos( t.next ), p );
    }
}

EXPRESSION ShortestPathExpression() throws Exception:
{
    PATTERN p;
    Token t;
}
{
    { t = token; }
    p=ShortestPathPattern()
    {
        return astFactory.patternExpression( pos( t.next ), p );
    }
}

EXPRESSION MapProjection() throws Exception:
{
    Token t;
    VARIABLE v;
    MAP_PROJECTION_ITEM x;
    List<MAP_PROJECTION_ITEM> items = new ArrayList<>();
}
{
    v=Variable() t=<LCURLY> ( x=MapProjectionItem() { items.add( x ); } ( <COMMA> x=MapProjectionItem() { items.add( x ); } )* )? <RCURLY>
    {
        return astFactory.mapProjection( pos( t ), v, items );
    }
}

MAP_PROJECTION_ITEM MapProjectionItem() throws Exception:
{
    Token t;
    StringPos<POS> p;
    EXPRESSION e;
    VARIABLE v;
}
{
    LOOKAHEAD( 2 ) p=PropertyKeyName() <COLON> e=Expression() { return astFactory.mapProjectionLiteralEntry( p, e ); }
    | LOOKAHEAD( 2 ) <DOT> p=PropertyKeyName() { return astFactory.mapProjectionProperty( p ); }
    | v=Variable() { return astFactory.mapProjectionVariable( v ); }
    | <DOT> t=<TIMES> { return astFactory.mapProjectionAll( pos( t ) ); }
}

EXPRESSION ExistsExpression() throws Exception:
{
    Token t;
    List<PATTERN> patterns = null;
    MATCH_MODE matchMode = null;
    QUERY q = null;
    WHERE where = null;
}
{
    t=<EXISTS>
    <LCURLY>
        (q=RegularQuery() | ( (matchMode = MatchMode() )? patterns=PatternList() ( where=WhereClause() )?))
    <RCURLY>
    {
        return astFactory.existsExpression( pos( t ), matchMode, patterns, q, where );
    }
}

EXPRESSION CountExpression() throws Exception:
{
    Token t;
    List<PATTERN> patterns = null;
    MATCH_MODE matchMode = null;
    QUERY q = null;
    WHERE where = null;
}
{
    t=<COUNT>
    <LCURLY>
        (q=RegularQuery() | ((matchMode = MatchMode() )? patterns=PatternList() ( where=WhereClause() )?))
    <RCURLY>
    {
        return astFactory.countExpression( pos( t ), matchMode, patterns, q, where );
    }
}

EXPRESSION CollectExpression() throws Exception:
{
    Token t;
    QUERY q;
}
{
    t=<COLLECT>
    <LCURLY>
        q=RegularQuery()
    <RCURLY>
    {
        return astFactory.collectExpression( pos( t ), q );
    }
}

EXPRESSION StringLiteral() :
{
    Token t;
}
{
    t=StringToken() { return astFactory.newString( pos( t ), endPos( t ), token.image ); }
}

EXPRESSION NumberLiteral() :
{
    Token sign = null;
    Token t;
    boolean negated = false;
}
{
    ( sign=<MINUS> { negated = true; } )?
    (
        t=<DECIMAL_DOUBLE> { return astFactory.newDouble(  pos( sign != null ? sign : t ) , sign != null ? sign.image + token.image : token.image ); }
        | t=<UNSIGNED_DECIMAL_INTEGER> { return astFactory.newDecimalInteger( pos( sign != null ? sign : t ), token.image, negated ); }
        | t=<UNSIGNED_HEX_INTEGER> { return astFactory.newHexInteger( pos( sign != null ? sign : t ), token.image, negated ); }
        | t=<UNSIGNED_OCTAL_INTEGER> { return astFactory.newOctalInteger( pos( sign != null ? sign : t ), token.image, negated ); }
    )
}

EXPRESSION SignedIntegerLiteral():
{
    Token sign = null;
    Token number;
    boolean negated = false;
}
{
    ( sign=<MINUS> { negated = true; })?
    number=<UNSIGNED_DECIMAL_INTEGER>
    {
        return astFactory.newDecimalInteger( pos( sign != null ? sign : number ), token.image, negated );
    }
}

EXPRESSION ListLiteral() throws Exception:
{
    Token t;
    EXPRESSION e;
    List<EXPRESSION> list = new ArrayList<>();
}
{
    t=<LBRACKET> ( e=Expression() { list.add( e ); } ( <COMMA> e=Expression() { list.add( e ); } )* )? <RBRACKET>
    {
        return astFactory.listLiteral( pos( t ), list );
    }
}

EXPRESSION StringListLiteral() throws Exception:
{
    Token t;
    EXPRESSION e;
    List<EXPRESSION> list = new ArrayList<>();
}
{
    t=<LBRACKET> ( e=StringLiteral() { list.add( e ); } ( <COMMA> e=StringLiteral() { list.add( e ); } )* )? <RBRACKET>
    {
        return astFactory.listLiteral( pos( t ), list );
    }
}

EXPRESSION MapLiteral() throws Exception:
{
    Token t;
    StringPos<POS> key;
    EXPRESSION value;
    List<StringPos<POS>> keys = new ArrayList<>();
    List<EXPRESSION> values = new ArrayList<>();
}
{
    t=<LCURLY> ( key=PropertyKeyName() <COLON> value=Expression() { keys.add( key ); values.add( value ); }
           ( <COMMA> key=PropertyKeyName() <COLON> value=Expression() { keys.add( key ); values.add( value ); } )* )? <RCURLY>
    {
        return astFactory.mapLiteral( pos( t ), keys, values);
    }
}

StringPos<POS> PropertyKeyName() :
{
    Token t;
}
{
    t=SymbolicNameString()
    {
        return new StringPos<POS>( t.image,  pos( t ) );
    }
}

PARAMETER Parameter( ParameterType type ) :
{
    Token t;
    VARIABLE v;
}
{
    t=<DOLLAR> (
        v=Variable() { return astFactory.newParameter( pos( t ), v, type ); }
        | <UNSIGNED_DECIMAL_INTEGER> { return astFactory.newParameter( pos( t ), token.image, type ); }
    )
}

FUNCTION_INVOCATION FunctionInvocation(boolean calledFromUseClause)  throws Exception:
{
    Token before = token;
    Token nameSpaceToken;
    Token nameToken;
    List<String> namespace;
    boolean distinct = false;
    EXPRESSION e;
    List<EXPRESSION> arguments = new ArrayList<>();
}
{
    namespace=Namespace() nameToken=SymbolicNameString()
    <LPAREN>
        ( LOOKAHEAD( 2 ) <DISTINCT> { distinct = true; } | <ALL> )?
        ( e=Expression() { arguments.add( e ); } ( <COMMA> e=Expression() { arguments.add( e ); } )* )?
    <RPAREN>
    {
        return astFactory.functionInvocation( pos( before.next ), pos( nameToken ), namespace, nameToken.image, distinct, arguments, calledFromUseClause );
    }
}

List<String> Namespace() :
{
    Token t;
    List<String> parts = new ArrayList<>();
}
{
    ( LOOKAHEAD( 2 ) t=SymbolicNameString() { parts.add( t.image ); } <DOT> )*
    {
        return parts;
    }
}

List<VARIABLE> VariableList1() :
{
    Token t;
    List<VARIABLE> list = new ArrayList<>();
}
{
    t=SymbolicNameString() { list.add( astFactory.newVariable( pos( t ), t.image ) ); }
    ( <COMMA> t=SymbolicNameString() { list.add( astFactory.newVariable( pos( t ), t.image) ); })*
    {
        return list;
    }
}

VARIABLE Variable() :
{
    Token t;
}
{
    t=SymbolicNameString()
    {
        return astFactory.newVariable( pos( t ), t.image );
    }
}

List<String> SymbolicNameList1() :
{
    Token n;
    List<String> list = new ArrayList<>();
}
{
    n=SymbolicNameString() { list.add(n.image); } ( <COMMA> n=SymbolicNameString() { list.add( n.image ); } )*
    {
        return list;
    }
}

// Command Section

STATEMENT_WITH_GRAPH CreateCommand( USE_CLAUSE useClause ) throws Exception:
{
    Token start;
    boolean replace = false;
    STATEMENT_WITH_GRAPH statement;
}
{
    start=<CREATE> (<OR> <REPLACE> { replace = true; })? (
        statement=CreateRole( start, replace )
        | statement=CreateUser( start, replace )
        | statement=CreateDatabase( start, replace )
        | statement=CreateConstraint( start, replace )
        | statement=CreateIndex( start, replace )
        | statement=CreateAlias( start, replace )
        | statement=CreateCompositeDatabase( start, replace )
    )
    {
        return astFactory.useGraph( statement, useClause );
    }
}

STATEMENT Command( USE_CLAUSE useClause ) throws Exception:
{
    STATEMENT statement = null;
}
{
    (

        statement=CommandWithUseGraph( useClause )
        | statement=ShowCommand( useClause )
        | statement=TerminateCommand( useClause )
    )
    {
        return statement;
    }
}

STATEMENT_WITH_GRAPH CommandWithUseGraph( USE_CLAUSE useClause ) throws Exception:
{
    STATEMENT_WITH_GRAPH s;
}
{
    (
        s=DropCommand()
        | s=AlterCommand()
        | s=RenameCommand()
        | s=DenyPrivilege()
        | s=RevokeCommand()
        | s=GrantCommand()
        | s=StartDatabase()
        | s=StopDatabase()
        | s=EnableServerCommand()
        | s=AllocationCommand()
    )
    {
        return astFactory.useGraph( s, useClause );
    }
}

STATEMENT_WITH_GRAPH DropCommand() throws Exception:
{
    Token start;
    STATEMENT_WITH_GRAPH s;
}
{
    start=<DROP>
    (
        s=DropRole( start )
        | s=DropUser( start )
        | s=DropDatabase( start )
        | s=DropConstraint( start )
        | s=DropIndex( start )
        | s=DropAlias( start )
        | s=DropServer( start )
    )
    {
        return s;
    }
}

STATEMENT_WITH_GRAPH AlterCommand() throws Exception:
{
    Token start = null;
    STATEMENT_WITH_GRAPH s;
}
{
    start=<ALTER>
    (
        s=AlterDatabase( start )
        | s=AlterAlias( start )
        | s=AlterCurrentUser( start )
        | s=AlterUser( start )
        | s=AlterServer( start )
    )
    {
        return s;
    }
}

// SHOW commands

STATEMENT ShowCommand( USE_CLAUSE useClause ) throws Exception:
{
    Token start = null;
    Token showCommandType = null;
    STATEMENT statement = null;
    List<CLAUSE> clauses = null;
}
{
    start=<SHOW>
    (
        showCommandType=<ALL> statement=ShowAllCommand( start, useClause )
        | <POPULATED> (<ROLES> | <ROLE>) statement=ShowRoles( start, useClause, false )
        | showCommandType=<BTREE> clauses=ShowIndexesAllowBrief( start, ShowCommandFilterTypes.BTREE )
        | showCommandType=<RANGE> clauses=ShowIndexesNoBrief( start, ShowCommandFilterTypes.RANGE )
        | showCommandType=<FULLTEXT> clauses=ShowIndexesNoBrief( start, ShowCommandFilterTypes.FULLTEXT )
        | showCommandType=<TEXT> clauses=ShowIndexesNoBrief( start, ShowCommandFilterTypes.TEXT )
        | showCommandType=<POINT> clauses=ShowIndexesNoBrief( start, ShowCommandFilterTypes.POINT )
        | showCommandType=<VECTOR> clauses=ShowIndexesNoBrief( start, ShowCommandFilterTypes.VECTOR )
        | showCommandType=<LOOKUP> clauses=ShowIndexesNoBrief( start, ShowCommandFilterTypes.LOOKUP )
        | showCommandType=<UNIQUE> clauses=ShowConstraintsAllowBriefAndYield( start, ShowCommandFilterTypes.UNIQUE )
        | showCommandType=<UNIQUENESS> clauses=ShowConstraintsAllowYield( start, ShowCommandFilterTypes.UNIQUE )
        | showCommandType=<KEY> clauses=ShowConstraintsAllowYield( start, ShowCommandFilterTypes.KEY )
        | showCommandType=<NODE> clauses=ShowNodeCommand( start )
        | showCommandType=<PROPERTY> clauses=ShowPropertyCommand( start, ShowCommandFilterTypes.EXIST )
        | showCommandType=<EXISTENCE> clauses=ShowConstraintsAllowYield( start, ShowCommandFilterTypes.EXIST )
        | showCommandType=<EXISTS> ShowConstraintsAllowBrief( start )
        | showCommandType=<EXIST> clauses=ShowConstraintsAllowBriefAndYield( start, ShowCommandFilterTypes.OLD_EXIST )
        | showCommandType=<RELATIONSHIP> clauses=ShowRelationshipCommand( start )
        | showCommandType=<REL> clauses=ShowRelCommand( start )
        | showCommandType=<BUILT> <IN> clauses=ShowFunctions( start, ShowCommandFilterTypes.BUILT_IN )
        | clauses=ShowIndexesAllowBrief( start, ShowCommandFilterTypes.ALL )
        | statement=ShowDatabase( start, useClause )
        | statement=ShowCurrentUser( start, useClause )
        | clauses=ShowConstraintsAllowBriefAndYield( start, ShowCommandFilterTypes.ALL )
        | clauses=ShowProcedures( start )
        | clauses=ShowSettings( start )
        | clauses=ShowFunctions( start, ShowCommandFilterTypes.ALL )
        | clauses=ShowTransactions( start )
        | statement=ShowAliases( start, useClause )
        | statement=ShowServers( start, useClause )
        | statement=ShowPrivileges( start, useClause )
        | statement=ShowSupportedPrivileges( start, useClause )
        | (<ROLES> | <ROLE>)
            (
                // Need these lookaheads to distinguish e.g. 'SHOW ROLE[S] YIELD ...' from 'SHOW ROLE[S] yield[, ...] PRIVILEGE[S]'
                LOOKAHEAD(( <YIELD> | <WHERE> | <WITH> ) ( <PRIVILEGE> | <PRIVILEGES> | <COMMA> )) statement=ShowRolePrivileges( start, useClause )
                | LOOKAHEAD(<YIELD> | <WHERE> | <WITH> | <EOF>) statement=ShowRoles( start, useClause, true )
                | statement=ShowRolePrivileges( start, useClause )
            )
        // Need a lookahead to distinguish 'SHOW USER DEFINED FUNCTION[S]' from 'SHOW USER defined[, ...] PRIVILEGE[S]'
        | LOOKAHEAD(<USER> <DEFINED> ( <FUNCTION> | <FUNCTIONS> )) showCommandType=<USER> <DEFINED> clauses=ShowFunctions( start, ShowCommandFilterTypes.USER_DEFINED )
        | (<USERS> | <USER>)
            (
                // Need these lookaheads to distinguish e.g. 'SHOW USER[S] YIELD ...' from 'SHOW USER[S] yield[, ...] PRIVILEGE[S]'
                LOOKAHEAD(( <YIELD> | <WHERE> | <WITH> ) ( <PRIVILEGE> | <PRIVILEGES> | <COMMA> )) statement=ShowUserPrivileges( start, useClause )
                | LOOKAHEAD(<YIELD> | <WHERE> | <WITH> | <EOF>) statement=ShowUsers( start, useClause )
                | statement=ShowUserPrivileges( start, useClause )
            )
    )
    {
        if ( clauses != null ) {
            if ( useClause != null )
            {
                clauses.add( 0, useClause );
            }
            statement = astFactory.newSingleQuery( pos( start ), clauses );
        }
        return statement;
    }
}

STATEMENT TerminateCommand( USE_CLAUSE useClause ) throws Exception:
{
    Token start = null;
    List<CLAUSE> clauses = null;
}
{
    start=<TERMINATE>
    (
        clauses=TerminateTransactions( start )
    )
    {
        if ( useClause != null )
        {
            clauses.add( 0, useClause );
        }
        return astFactory.newSingleQuery( pos( start ), clauses );
    }
}

STATEMENT ShowAllCommand( Token start, USE_CLAUSE useClause ) throws Exception:
{
    STATEMENT statement = null;
    List<CLAUSE> clauses = null;
}
{
    (
        (<ROLES> | <ROLE>) statement=ShowRoles( start, useClause, true )
        | clauses=ShowIndexesAllowBrief( start, ShowCommandFilterTypes.ALL )
        | clauses=ShowConstraintsAllowBriefAndYield( start, ShowCommandFilterTypes.ALL )
        | clauses=ShowFunctions( start, ShowCommandFilterTypes.ALL )
        | statement=ShowPrivileges( start, useClause )
    )
    {
        if ( clauses != null ) {
            if ( useClause != null )
            {
                clauses.add( 0, useClause );
            }
            statement = astFactory.newSingleQuery( pos( start ), clauses );
        }
        return statement;
    }
}

List<CLAUSE> ShowNodeCommand( Token start ) throws Exception:
{
    List<CLAUSE> clauses = null;
}
{
    // Needs to add <NODE> to the type
    (
        (<UNIQUE> | <UNIQUENESS>) clauses=ShowConstraintsAllowYield( start, ShowCommandFilterTypes.NODE_UNIQUE )
        | <KEY> clauses=ShowConstraintsAllowBriefAndYield( start, ShowCommandFilterTypes.NODE_KEY )
        | <PROPERTY> clauses=ShowPropertyCommand( start, ShowCommandFilterTypes.NODE_EXIST )
        | <EXISTENCE> clauses=ShowConstraintsAllowYield( start, ShowCommandFilterTypes.NODE_EXIST )
        | <EXISTS> ShowConstraintsAllowBrief( start )
        | <EXIST> clauses=ShowConstraintsAllowBriefAndYield( start, ShowCommandFilterTypes.NODE_OLD_EXIST )
    )
    {
        return clauses;
    }
}

List<CLAUSE> ShowRelationshipCommand( Token start ) throws Exception:
{
    List<CLAUSE> clauses = null;
}
{
    (
        (<UNIQUE> | <UNIQUENESS>) clauses=ShowConstraintsAllowYield( start, ShowCommandFilterTypes.RELATIONSHIP_UNIQUE )
        | <KEY> clauses=ShowConstraintsAllowYield( start, ShowCommandFilterTypes.RELATIONSHIP_KEY )
        | <PROPERTY> clauses=ShowPropertyCommand( start, ShowCommandFilterTypes.RELATIONSHIP_EXIST )
        | <EXISTENCE> clauses=ShowConstraintsAllowYield( start, ShowCommandFilterTypes.RELATIONSHIP_EXIST )
        | <EXISTS> ShowConstraintsAllowBrief( start )
        | <EXIST> clauses=ShowConstraintsAllowBriefAndYield( start, ShowCommandFilterTypes.RELATIONSHIP_OLD_EXIST )
    )
    {
        return clauses;
    }
}

List<CLAUSE> ShowRelCommand( Token start ) throws Exception:
{
    List<CLAUSE> clauses = null;
}
{
    (
        (<UNIQUE> | <UNIQUENESS>) clauses=ShowConstraintsAllowYield( start, ShowCommandFilterTypes.RELATIONSHIP_UNIQUE )
        | <KEY> clauses=ShowConstraintsAllowYield( start, ShowCommandFilterTypes.RELATIONSHIP_KEY )
        | <PROPERTY> clauses=ShowPropertyCommand( start, ShowCommandFilterTypes.RELATIONSHIP_EXIST )
        | <EXISTENCE> clauses=ShowConstraintsAllowYield( start, ShowCommandFilterTypes.RELATIONSHIP_EXIST )
        | <EXIST> clauses=ShowConstraintsAllowYield( start, ShowCommandFilterTypes.RELATIONSHIP_EXIST )
    )
    {
        return clauses;
    }
}

List<CLAUSE> ShowPropertyCommand( Token start, ShowCommandFilterTypes existenceConstraintType ) throws Exception:
{
    List<CLAUSE> clauses = null;
    ShowCommandFilterTypes propertyTypeConstraintType;
    if (existenceConstraintType.description().startsWith("NODE")) {
        propertyTypeConstraintType = ShowCommandFilterTypes.NODE_PROP_TYPE;
    } else if (existenceConstraintType.description().startsWith("REL")) {
        propertyTypeConstraintType = ShowCommandFilterTypes.RELATIONSHIP_PROP_TYPE;
    } else {
        propertyTypeConstraintType = ShowCommandFilterTypes.PROP_TYPE;
    }
    ShowCommandFilterTypes constraintType;
}
{
    ( (<EXISTENCE> | <EXIST>) { constraintType = existenceConstraintType; }
      | <TYPE> { constraintType = propertyTypeConstraintType; }
    ) clauses=ShowConstraintsAllowYield( start, constraintType )
     { return clauses; }
}

RETURN_ITEM YieldItem() :
{
    VARIABLE e;
    VARIABLE v = null;
    Token eStart;
    Token eEnd;
}
{
    { eStart = token; }
    e=Variable() { eEnd = token; } ( <AS> v=Variable() )?
    {
        if ( v != null )
        {
            return astFactory.newReturnItem( pos( eStart.next ), e, v );
        }
        else
        {
            return astFactory.newReturnItem( pos( eStart.next ), e, eStart.next.beginOffset, eEnd.endOffset );
        }
    }
}

YIELD YieldClause() throws Exception:
{
    Token start;
    Token skipPosition = null;
    Token limitPosition = null;
    Token orderToken = null;
    boolean returnAll = false;
    RETURN_ITEM item;
    ORDER_ITEM o;
    List<RETURN_ITEM> returnItems = new ArrayList<>();
    List<ORDER_ITEM> orders = new ArrayList<>();
    EXPRESSION skip = null;
    EXPRESSION limit = null;
    WHERE where = null;
}
{
    start=<YIELD>
    ( <TIMES> { returnAll = true; }  |
    ( item=YieldItem() { returnItems.add( item ); } (<COMMA> item=YieldItem() { returnItems.add( item ); } )*))
    ( orderToken=<ORDER> <BY> o=OrderItem() { orders.add( o ); } ( <COMMA> o=OrderItem() {orders.add( o ); } )*)?
    ( skipPosition=<SKIPROWS> skip=SignedIntegerLiteral() )?
    ( limitPosition=<LIMITROWS> limit=SignedIntegerLiteral() )?
    ( where=WhereClause() ) ?
    {
        return astFactory.yieldClause( pos( start ), returnAll, returnItems, pos( start.next ), orders, pos( orderToken ), skip, pos( skipPosition ), limit, pos( limitPosition ), where );
    }
}

List<CLAUSE> ShowIndexesAllowBrief( Token start, ShowCommandFilterTypes indexType ) throws Exception:
{
    // all and btree indexes
    List<CLAUSE> clauses = new ArrayList<>();
    boolean brief = false;
    boolean verbose = false;
    WHERE where = null;
    YIELD yieldClause = null;
    RETURN_CLAUSE returnClause = null;
    List<CLAUSE> tailClauses = null;
}
{
    ( <INDEX> | <INDEXES> )
    (
        ( ( <BRIEF> { brief = true; } | <VERBOSE> { verbose = true; } ) ( <OUTPUT> )? )
        | ( yieldClause=YieldClause() ( returnClause=ReturnClause() )? )
        | where=WhereClause()
    )?
    ( tailClauses=composableCommandClauses() )?
    {
        if (brief || verbose) {
            throw exceptionFactory.syntaxException(
                    new ParseException(ASTExceptionFactory.invalidBriefVerbose("SHOW INDEXES")),
                    start.beginOffset, start.beginLine, start.beginColumn );
        }

        if ( yieldClause != null )
        {
            clauses.add( astFactory.showIndexClause( pos( start ), indexType, where, yieldClause ) );
            clauses.add( astFactory.turnYieldToWith( yieldClause ) );
            if ( returnClause != null )
            {
                clauses.add( returnClause );
            }
        }
        else
        {
            clauses.add( astFactory.showIndexClause( pos( start ), indexType, where, null ) );
        }
        if ( tailClauses != null ) {
            clauses.addAll( tailClauses );
        }
        return clauses;
    }
}

List<CLAUSE> ShowIndexesNoBrief(Token start, ShowCommandFilterTypes indexType) throws Exception:
{
  // remaining indexes
  List<CLAUSE> clauses = new ArrayList<>();
  WHERE where = null;
  YIELD yieldClause = null;
  RETURN_CLAUSE returnClause = null;
  List<CLAUSE> tailClauses = null;
}
{
    ( <INDEX> | <INDEXES> )
    ( (yieldClause=YieldClause() ( returnClause=ReturnClause() )?) | where=WhereClause() )?
    ( tailClauses=composableCommandClauses() )?
    {
        if ( yieldClause != null )
        {
            clauses.add( astFactory.showIndexClause( pos( start ), indexType, where, yieldClause ) );
            clauses.add( astFactory.turnYieldToWith( yieldClause ) );
            if ( returnClause != null )
            {
                clauses.add( returnClause );
            }
        }
        else
        {
            clauses.add( astFactory.showIndexClause( pos( start ), indexType, where, null ) );
        }
        if ( tailClauses != null ) {
            clauses.addAll( tailClauses );
        }
        return clauses;
    }
}

List<CLAUSE> ShowConstraintsAllowBriefAndYield( Token start, ShowCommandFilterTypes constraintType ) throws Exception:
{
    // constraints that previously allowed brief/verbose
    List<CLAUSE> clauses = new ArrayList<>();
    boolean brief = false;
    boolean verbose = false;
    WHERE where = null;
    YIELD yieldClause = null;
    RETURN_CLAUSE returnClause = null;
    List<CLAUSE> tailClauses = null;
}
{
    ( <CONSTRAINT> | <CONSTRAINTS> )
    (
        ( ( <BRIEF> { brief = true; } | <VERBOSE> { verbose = true; }) (<OUTPUT>)? )
        | ( yieldClause=YieldClause() ( returnClause=ReturnClause() )?)
        | where=WhereClause()
    )?
    ( tailClauses=composableCommandClauses() )?
    {
        if (brief || verbose) {
            throw exceptionFactory.syntaxException(
                    new ParseException(ASTExceptionFactory.invalidBriefVerbose("SHOW CONSTRAINTS")),
                    start.beginOffset, start.beginLine, start.beginColumn );
        }

        if ( yieldClause != null )
        {
            clauses.add( astFactory.showConstraintClause( pos( start ), constraintType, where, yieldClause ) );
            clauses.add( astFactory.turnYieldToWith( yieldClause ) );
            if ( returnClause != null )
            {
                clauses.add( returnClause );
            }
        }
        else
        {
            clauses.add( astFactory.showConstraintClause( pos( start ), constraintType, where, null ) );
        }
        if ( tailClauses != null ) {
            clauses.addAll( tailClauses );
        }
        return clauses;
    }
}

void ShowConstraintsAllowBrief( Token start ) throws Exception:
{
    // old removed existence constraints, parsing kept for nice error
}
{
    ( <CONSTRAINT> | <CONSTRAINTS> )
    ( ( <BRIEF> | <VERBOSE>) (<OUTPUT>)? )?
    ( composableCommandClauses() )?
    {
        throw exceptionFactory.syntaxException(
                new ParseException(ASTExceptionFactory.invalidExistsForShowConstraints),
                start.beginOffset, start.beginLine, start.beginColumn );
    }
}

List<CLAUSE> ShowConstraintsAllowYield( Token start, ShowCommandFilterTypes constraintType ) throws Exception:
{
    // constraints only allowing yield and not brief/verbose
    // this is the method that will be used for all constraints in 6.0
    List<CLAUSE> clauses = new ArrayList<>();
    WHERE where = null;
    YIELD yieldClause = null;
    RETURN_CLAUSE returnClause = null;
    List<CLAUSE> tailClauses = null;
}
{
    ( <CONSTRAINT> | <CONSTRAINTS> )
    (
        ( yieldClause=YieldClause() ( returnClause=ReturnClause() ) ? )
        | where=WhereClause()
    )?
    ( tailClauses=composableCommandClauses() )?
    {
        if ( yieldClause != null )
        {
            clauses.add( astFactory.showConstraintClause( pos( start ), constraintType, where, yieldClause ) );
            clauses.add( astFactory.turnYieldToWith( yieldClause ) );
            if ( returnClause != null )
            {
                clauses.add( returnClause );
            }
        }
        else
        {
            clauses.add( astFactory.showConstraintClause( pos( start ), constraintType, where, null ) );
        }
        if ( tailClauses != null ) {
            clauses.addAll( tailClauses );
        }
        return clauses;
    }
}

List<CLAUSE> ShowProcedures( Token start ) throws Exception:
{
    List<CLAUSE> clauses = new ArrayList<>();

    boolean currentUser = false;
    Token userToken = null;
    String user = null;

    WHERE where = null;
    YIELD yieldClause = null;
    RETURN_CLAUSE returnClause = null;

    List<CLAUSE> tailClauses = null;
}
{
    ( <PROCEDURE> | <PROCEDURES> )
    (
        <EXECUTABLE> { currentUser = true; } ( <BY>
        ( LOOKAHEAD(<CURRENT> <USER>) <CURRENT> <USER> { currentUser = true; }
        | userToken=SymbolicNameString() { user = userToken.image; currentUser = false; } ) )?
    )?
    (
        ( yieldClause=YieldClause() ( returnClause=ReturnClause() ) ? )
        | where=WhereClause()
    )?
    ( tailClauses=composableCommandClauses() )?
    {
        if ( yieldClause != null )
        {
            clauses.add( astFactory.showProcedureClause( pos( start ), currentUser, user, where, yieldClause ) );
            clauses.add( astFactory.turnYieldToWith( yieldClause ) );
            if ( returnClause != null )
            {
                clauses.add( returnClause );
            }
        }
        else
        {
            clauses.add( astFactory.showProcedureClause( pos( start ), currentUser, user, where, null ) );
        }
        if ( tailClauses != null ) {
            clauses.addAll( tailClauses );
        }
        return clauses;
    }
}

List<CLAUSE> ShowFunctions( Token start, ShowCommandFilterTypes functionType ) throws Exception:
{
    List<CLAUSE> clauses = new ArrayList<>();

    boolean currentUser = false;
    Token userToken = null;
    String user = null;

    WHERE where = null;
    YIELD yieldClause = null;
    RETURN_CLAUSE returnClause = null;

    List<CLAUSE> tailClauses = null;
}
{
    ( <FUNCTION> | <FUNCTIONS> )
    (
        <EXECUTABLE> { currentUser = true; } ( <BY>
        ( LOOKAHEAD(<CURRENT> <USER>) <CURRENT> <USER> { currentUser = true; }
        | userToken=SymbolicNameString() { user = userToken.image; currentUser = false; } ) )?
    )?
    (
        ( yieldClause=YieldClause() ( returnClause=ReturnClause() ) ? )
        | where=WhereClause()
    )?
    ( tailClauses=composableCommandClauses() )?
    {
        if ( yieldClause != null )
        {
            clauses.add( astFactory.showFunctionClause( pos( start ), functionType, currentUser, user, where, yieldClause ) );
            clauses.add( astFactory.turnYieldToWith( yieldClause ) );
            if ( returnClause != null )
            {
                clauses.add( returnClause );
            }
        }
        else
        {
            clauses.add( astFactory.showFunctionClause( pos( start ), functionType, currentUser, user, where, null ) );
        }
        if ( tailClauses != null ) {
            clauses.addAll( tailClauses );
        }
        return clauses;
    }
}

List<CLAUSE> ShowTransactions( Token start ) throws Exception:
{
    List<CLAUSE> clauses = new LinkedList<>();
    SimpleEither<List<String>, EXPRESSION> idEither = SimpleEither.left(new ArrayList<>());

    WHERE where = null;
    YIELD yieldClause = null;
    RETURN_CLAUSE returnClause = null;

    List<CLAUSE> tailClauses = null;
}
{
    ( <TRANSACTION> | <TRANSACTIONS> )
    (
        LOOKAHEAD(composableCommandClauses()) tailClauses=composableCommandClauses()
        | ( LOOKAHEAD(stringsOrExpression() (WhereClause() | YieldClause()))
              idEither=stringsOrExpression() (
                  ( yieldClause=YieldClause() ( returnClause=ReturnClause() ) ? )
                  | where=WhereClause()
              )
          | LOOKAHEAD(YieldClause()) yieldClause=YieldClause() ( returnClause=ReturnClause() ) ?
          | LOOKAHEAD(WhereClause()) where=WhereClause()
          | idEither=stringsOrExpression()
        ) ( tailClauses=composableCommandClauses() )?
    )?
    {
        if ( yieldClause != null )
        {
            clauses.add( astFactory.showTransactionsClause( pos( start ), idEither,  where, yieldClause ) );
            clauses.add( astFactory.turnYieldToWith( yieldClause ) );
            if ( returnClause != null )
            {
                clauses.add( returnClause );
            }
        }
        else
        {
            clauses.add( astFactory.showTransactionsClause( pos( start ), idEither, where, null ) );
        }
        if ( tailClauses != null ) {
            clauses.addAll( tailClauses );
        }
        return clauses;
    }
}

List<CLAUSE> TerminateTransactions( Token start ) throws Exception:
{
    List<CLAUSE> clauses = new LinkedList<>();
    SimpleEither<List<String>, EXPRESSION> idEither = SimpleEither.left(new ArrayList<>());

    WHERE where = null;
    YIELD yieldClause = null;
    RETURN_CLAUSE returnClause = null;

    List<CLAUSE> tailClauses = null;
}
{
    ( <TRANSACTION> | <TRANSACTIONS> )
    (
        LOOKAHEAD(composableCommandClauses()) tailClauses=composableCommandClauses()
        | ( LOOKAHEAD(stringsOrExpression() (WhereClause() | YieldClause()))
              idEither=stringsOrExpression() (
                  ( yieldClause=YieldClause() ( returnClause=ReturnClause() ) ? )
                  | where=WhereClause()
              )
          | LOOKAHEAD(YieldClause()) yieldClause=YieldClause() ( returnClause=ReturnClause() ) ?
          | LOOKAHEAD(WhereClause()) where=WhereClause()
          | idEither=stringsOrExpression()
        ) ( tailClauses=composableCommandClauses() )?
    )?
    {
        if ( yieldClause != null )
        {
            clauses.add( astFactory.terminateTransactionsClause( pos( start ), idEither, where, yieldClause ) );
            clauses.add( astFactory.turnYieldToWith( yieldClause ) );
            if ( returnClause != null )
            {
                clauses.add( returnClause );
            }
        }
        else
        {
            clauses.add( astFactory.terminateTransactionsClause( pos( start ), idEither, where, null ) );
        }
        if ( tailClauses != null ) {
            clauses.addAll( tailClauses );
        }
        return clauses;
    }
}

List<CLAUSE> ShowSettings( Token start ) throws Exception:
{
    List<CLAUSE> clauses = new ArrayList<>();
    SimpleEither<List<String>, EXPRESSION> nameEither = SimpleEither.left(new ArrayList<>());

    WHERE where = null;
    YIELD yieldClause = null;
    RETURN_CLAUSE returnClause = null;

    List<CLAUSE> tailClauses = null;
}
{
    ( <SETTING> | <SETTINGS> )
    (
        LOOKAHEAD(composableCommandClauses()) tailClauses=composableCommandClauses()
        | ( LOOKAHEAD(stringsOrExpression() (WhereClause() | YieldClause()))
              nameEither=stringsOrExpression() (
                  ( yieldClause=YieldClause() ( returnClause=ReturnClause() ) ? )
                  | where=WhereClause()
              )
          | LOOKAHEAD(YieldClause()) yieldClause=YieldClause() ( returnClause=ReturnClause() ) ?
          | LOOKAHEAD(WhereClause()) where=WhereClause()
          | nameEither=stringsOrExpression()
        ) ( tailClauses=composableCommandClauses() )?
    )?
    {
        if ( yieldClause != null )
        {
            clauses.add( astFactory.showSettingsClause( pos( start ), nameEither, where, yieldClause ) );
            clauses.add( astFactory.turnYieldToWith( yieldClause ) );
            if ( returnClause != null )
            {
                clauses.add( returnClause );
            }
        }
        else
        {
            clauses.add( astFactory.showSettingsClause( pos( start ), nameEither, where, null ) );
        }
        if ( tailClauses != null ) {
            clauses.addAll( tailClauses );
        }
        return clauses;
    }
}

List<CLAUSE> composableCommandClauses() throws Exception:
{
    Token start = null;
    List<CLAUSE> clauses = null;
}
{
    (
        (start=<TERMINATE> clauses=TerminateTransactions(start))
        | start=<SHOW> (
            // order: first the read tokens than lookaheads,
            // each group is alphabetical but longer words first
            <ALL> (
                LOOKAHEAD( <CONSTRAINT> | <CONSTRAINTS> ) clauses=ShowConstraintsAllowBriefAndYield(start, ShowCommandFilterTypes.ALL)
                | LOOKAHEAD( <INDEX> | <INDEXES> ) clauses=ShowIndexesAllowBrief(start, ShowCommandFilterTypes.ALL)
                | clauses=ShowFunctions(start, ShowCommandFilterTypes.ALL)
            )
            | <BTREE> clauses=ShowIndexesAllowBrief(start, ShowCommandFilterTypes.BTREE)
            | <BUILT> <IN> clauses=ShowFunctions(start, ShowCommandFilterTypes.BUILT_IN)
            | <EXISTENCE> clauses=ShowConstraintsAllowYield(start, ShowCommandFilterTypes.EXIST)
            | <EXISTS> ShowConstraintsAllowBrief(start)
            | <EXIST> clauses=ShowConstraintsAllowBriefAndYield(start, ShowCommandFilterTypes.OLD_EXIST)
            | <FULLTEXT> clauses=ShowIndexesNoBrief(start, ShowCommandFilterTypes.FULLTEXT)
            | <KEY> clauses=ShowConstraintsAllowYield(start, ShowCommandFilterTypes.KEY)
            | <LOOKUP> clauses=ShowIndexesNoBrief(start, ShowCommandFilterTypes.LOOKUP)
            | <NODE> clauses=ShowNodeCommand( start )
            | <POINT> clauses=ShowIndexesNoBrief(start, ShowCommandFilterTypes.POINT)
            | <PROPERTY> clauses=ShowPropertyCommand( start, ShowCommandFilterTypes.EXIST )
            | <RANGE> clauses=ShowIndexesNoBrief(start, ShowCommandFilterTypes.RANGE)
            | <RELATIONSHIP> clauses=ShowRelationshipCommand( start )
            | <REL> clauses=ShowRelCommand( start )
            | <TEXT> clauses=ShowIndexesNoBrief(start, ShowCommandFilterTypes.TEXT)
            | <UNIQUENESS> clauses=ShowConstraintsAllowYield(start, ShowCommandFilterTypes.UNIQUE)
            | <UNIQUE> clauses=ShowConstraintsAllowBriefAndYield(start, ShowCommandFilterTypes.UNIQUE)
            | <USER> <DEFINED> clauses=ShowFunctions(start, ShowCommandFilterTypes.USER_DEFINED)
            | <VECTOR> clauses=ShowIndexesNoBrief(start, ShowCommandFilterTypes.VECTOR)
            | LOOKAHEAD( <CONSTRAINT> | <CONSTRAINTS> ) clauses=ShowConstraintsAllowBriefAndYield(start, ShowCommandFilterTypes.ALL)
            | LOOKAHEAD( <FUNCTION> | <FUNCTIONS> ) clauses=ShowFunctions(start, ShowCommandFilterTypes.ALL)
            | LOOKAHEAD( <INDEX> | <INDEXES> ) clauses=ShowIndexesAllowBrief(start, ShowCommandFilterTypes.ALL)
            | LOOKAHEAD( <PROCEDURE> | <PROCEDURES> ) clauses=ShowProcedures(start)
            | LOOKAHEAD( <SETTING> | <SETTINGS> )  clauses=ShowSettings(start)
            | clauses=ShowTransactions(start)
        )
    )
    {
        return clauses;
    }
}

SimpleEither<List<String>, EXPRESSION> stringsOrExpression() throws Exception:
{
    List<String> ids = new ArrayList<>();
    EXPRESSION expr = null;
    SimpleEither<List<String>, EXPRESSION> idEither = SimpleEither.left(ids);
}
{
    ( LOOKAHEAD(StringImage() <COMMA>) (ids=StringList() { idEither=SimpleEither.left(ids); })
    | (expr=Expression() { idEither=SimpleEither.right(expr); }) )
    {
        return idEither;
    }
}

// Schema commands
// Constraint commands

SCHEMA_COMMAND CreateConstraint( Token start, boolean replace ) throws Exception:
{
    SimpleEither<StringPos<POS>, PARAMETER> name = null;
    boolean ifNotExists = false;
    Token label;
    VARIABLE variable = null;
    List<PROPERTY> properties = new ArrayList<>();
    ParserCypherTypeName propertyType = null;
    SimpleEither<Map<String, EXPRESSION>, PARAMETER> options = null;
    ConstraintType constraintType = ConstraintType.NODE_EXISTS;
    boolean isNode = false;
    Token errorStart;
    boolean containsOn = true;
    ConstraintVersion constraintVersion = ConstraintVersion.CONSTRAINT_VERSION_0;
}
{
    <CONSTRAINT>
    (
        //special construct for allowing lookahead since on could also be an identifier
        LOOKAHEAD (<ON> <LPAREN>) <ON> <LPAREN>
        | LOOKAHEAD (<FOR> <LPAREN>) <FOR> <LPAREN> { containsOn = false; }
        | LOOKAHEAD (<IF> <NOT>) <IF> <NOT> <EXISTS> { ifNotExists = true; } (<ON> | <FOR> { containsOn = false; }) <LPAREN>
        | ( LOOKAHEAD(2) name=SymbolicNameOrStringParameter() )? ( <IF> <NOT> <EXISTS> { ifNotExists = true; } )? (<ON> | <FOR> { containsOn = false; }) <LPAREN>
    )
    (
        //(variable:LABEL)
        variable=Variable() label=LabelOrRelType() <RPAREN> { isNode = true; }
    |   //()-[variable:LABEL]-()
        <RPAREN> ( LeftArrow() )? ArrowLine()
        <LBRACKET> variable=Variable() label=LabelOrRelType() <RBRACKET>
        ArrowLine() ( RightArrow() )? <LPAREN> <RPAREN>
    )
    (
         // CREATE CONSTRAINT ON (variable:LABEL) ASSERT EXISTS variable.prop
        LOOKAHEAD(<ASSERT> <EXISTS>)
        <ASSERT> { constraintVersion = ConstraintVersion.CONSTRAINT_VERSION_0; }
        errorStart=<EXISTS> { constraintType = isNode ? ConstraintType.NODE_EXISTS : ConstraintType.REL_EXISTS; }
        properties=PropertyList()
    |
        (
            <REQUIRE> { constraintVersion = ConstraintVersion.CONSTRAINT_VERSION_2; }
            | <ASSERT> { constraintVersion = ConstraintVersion.CONSTRAINT_VERSION_0; }
        )
        properties=PropertyList()
        (
            <COLONCOLON> propertyType = cypherTypeName() {
                // CREATE CONSTRAINT FOR (variable:LABEL) REQUIRE variable.prop :: <TYPE>
                // CREATE CONSTRAINT FOR ()-[variable:LABEL]-() REQUIRE variable.prop :: <TYPE>
                constraintType = isNode ? ConstraintType.NODE_IS_TYPED : ConstraintType.REL_IS_TYPED;
            }
            | errorStart=<IS>
            (
                <UNIQUE> {
                        // CREATE CONSTRAINT FOR (variable:LABEL) REQUIRE variable.prop IS UNIQUE
                        // CREATE CONSTRAINT FOR ()-[variable:LABEL]-() REQUIRE variable.prop IS UNIQUE
                        constraintType = isNode ? ConstraintType.NODE_UNIQUE : ConstraintType.REL_UNIQUE;
                     }
                | <KEY> {
                        // CREATE CONSTRAINT FOR (variable:LABEL) REQUIRE variable.prop IS KEY
                        // CREATE CONSTRAINT FOR ()-[variable:LABEL]-() REQUIRE variable.prop IS KEY
                        constraintType = isNode ? ConstraintType.NODE_KEY : ConstraintType.REL_KEY;
                     }
                | <NODE>
                    (<KEY>
                    {
                        // CREATE CONSTRAINT FOR (variable:LABEL) REQUIRE variable.prop IS NODE KEY
                        constraintType = ConstraintType.NODE_KEY;
                        if ( !isNode )
                        {
                            throw exceptionFactory.syntaxException(
                                new ParseException( ASTExceptionFactory.relationshipPatternNotAllowed( constraintType ) ),
                                errorStart.beginOffset, errorStart.beginLine, errorStart.beginColumn );
                        }
                    }
                    | <UNIQUE>
                    {
                        // CREATE CONSTRAINT FOR (variable:LABEL) REQUIRE variable.prop IS NODE UNIQUE
                        constraintType = ConstraintType.NODE_UNIQUE;
                        if ( !isNode )
                        {
                            throw exceptionFactory.syntaxException(
                                new ParseException( ASTExceptionFactory.relationshipPatternNotAllowed( constraintType ) ),
                                errorStart.beginOffset, errorStart.beginLine, errorStart.beginColumn );
                        }
                    })
                | (<RELATIONSHIP> | <REL>)
                    (<KEY>
                    {
                        // CREATE CONSTRAINT FOR ()-[variable:LABEL]-() REQUIRE variable.prop IS RELATIONSHIP KEY
                        constraintType = ConstraintType.REL_KEY;
                        if ( isNode )
                        {
                            throw exceptionFactory.syntaxException(
                                new ParseException( ASTExceptionFactory.nodePatternNotAllowed( constraintType ) ),
                                errorStart.beginOffset, errorStart.beginLine, errorStart.beginColumn );
                        }
                    }
                    | <UNIQUE>
                    {
                        // CREATE CONSTRAINT FOR ()-[variable:LABEL]-() REQUIRE variable.prop IS RELATIONSHIP UNIQUE
                        constraintType = ConstraintType.REL_UNIQUE;
                        if ( isNode )
                        {
                            throw exceptionFactory.syntaxException(
                                new ParseException( ASTExceptionFactory.nodePatternNotAllowed( constraintType ) ),
                                errorStart.beginOffset, errorStart.beginLine, errorStart.beginColumn );
                        }
                    })
                | <NOT> <NULL> {
                    // CREATE CONSTRAINT FOR (variable:LABEL) REQUIRE variable.prop IS NOT NULL
                    // CREATE CONSTRAINT FOR ()-[variable:LABEL]-() REQUIRE variable.prop IS NOT NULL
                    constraintType = isNode ? ConstraintType.NODE_IS_NOT_NULL : ConstraintType.REL_IS_NOT_NULL;
                    if (constraintVersion == ConstraintVersion.CONSTRAINT_VERSION_0)
                    {
                        constraintVersion = ConstraintVersion.CONSTRAINT_VERSION_1;
                    }
                }
                | (<TYPED> | <COLONCOLON>) propertyType = cypherTypeName() {
                    // CREATE CONSTRAINT FOR (variable:LABEL) REQUIRE variable.prop IS :: <TYPE>
                    // CREATE CONSTRAINT FOR (variable:LABEL) REQUIRE variable.prop IS TYPED <TYPE>
                    // CREATE CONSTRAINT FOR ()-[variable:LABEL]-() REQUIRE variable.prop IS :: <TYPE>
                    // CREATE CONSTRAINT FOR ()-[variable:LABEL]-() REQUIRE variable.prop IS TYPED <TYPE>
                    constraintType = isNode ? ConstraintType.NODE_IS_TYPED : ConstraintType.REL_IS_TYPED;
                }
            )
        )
    )
    ( <OPTIONS> options=MapOrParameter() )?
    {
        String error = ASTExceptionFactory.checkForInvalidCreateConstraint(constraintType, constraintVersion, containsOn, properties.size() > 1);
        if (error != null) {
            throw exceptionFactory.syntaxException(
                new ParseException( error ),
                start.beginOffset, start.beginLine, start.beginColumn );
        } else {
            return astFactory.createConstraint( pos( start ), constraintType, replace, ifNotExists, name, variable,
            new StringPos<POS>( label.image, pos( label ) ), properties, propertyType, options );
        }
    }
}

ParserCypherTypeName cypherTypeName() throws Exception:
{
    Token t = null;
    List<ParserCypherTypeName> list = new ArrayList<>();
}
{
    { t = token; }
    list = cypherTypeNameList()
    {
        if ( list.size() ==  1)
        {
            return list.get(0);
        }
        else
        {
             t = t.next;
            return ParserCypherTypeName.closedDynamicUnionOf(list).withPos(t.beginOffset, t.beginLine, t.beginColumn);
        }
    }
}

List<ParserCypherTypeName> cypherTypeNameList() throws Exception:
{
    ParserCypherTypeName typeName;
    List<ParserCypherTypeName> list = new ArrayList<>();
}
{
    typeName=cypherTypeNamePart() { list.add( typeName ); }
    ( LOOKAHEAD(2) <BAR> typeName=cypherTypeNamePart() { list.add( typeName ); } )*
    {
        return list;
    }
}

ParserCypherTypeName cypherTypeNamePart() throws Exception:
{
    Token t = null;
    ParserCypherTypeName typeName = null;
    ParserCypherTypeName innerType = null;
    List<ParserCypherTypeName> unionTypeList = null;
}
{
    { t = token; }
    try {
        (
            <NOTHING> { typeName = ParserCypherTypeName.NOTHING; }
            | <NULL> { typeName = ParserCypherTypeName.NULL; }
            | (<BOOLEAN> | <BOOL>) { typeName = ParserCypherTypeName.BOOLEAN; }
            | (<STRING> | <VARCHAR>) { typeName = ParserCypherTypeName.STRING; }
            | (<INT> | (<SIGNED>)? <INTEGER>) { typeName = ParserCypherTypeName.INTEGER; }
            | <FLOAT> { typeName = ParserCypherTypeName.FLOAT; }
            | <DATE> { typeName = ParserCypherTypeName.DATE; }
            | <LOCAL> (
                <TIME> { typeName = ParserCypherTypeName.LOCAL_TIME; }
                | <DATETIME> { typeName = ParserCypherTypeName.LOCAL_DATETIME; }
            )
            | <ZONED> (
                <TIME> { typeName = ParserCypherTypeName.ZONED_TIME; }
                | <DATETIME> { typeName = ParserCypherTypeName.ZONED_DATETIME; }
            )
            | <TIME> (
                <WITHOUT> <TIMEZONE> { typeName = ParserCypherTypeName.LOCAL_TIME; }
                | <WITH> <TIMEZONE> { typeName = ParserCypherTypeName.ZONED_TIME; }
            )
            | <TIMESTAMP> (
                <WITHOUT> <TIMEZONE> { typeName = ParserCypherTypeName.LOCAL_DATETIME; }
                | <WITH> <TIMEZONE> { typeName = ParserCypherTypeName.ZONED_DATETIME; }
            )
            | <DURATION> { typeName = ParserCypherTypeName.DURATION; }
            | <POINT> { typeName = ParserCypherTypeName.POINT; }
            | (<NODE> | <VERTEX>) { typeName = ParserCypherTypeName.NODE; }
            | (<RELATIONSHIP> | <EDGE>){ typeName = ParserCypherTypeName.RELATIONSHIP; }
            | <MAP> { typeName = ParserCypherTypeName.MAP; }
            | (<LIST> | <ARRAY>) <LT> innerType=cypherTypeName() <GT> { typeName = ParserCypherTypeName.listOf(innerType); }
            | <PATH> { typeName = ParserCypherTypeName.PATH; }
            | <PROPERTY> <VALUE> { typeName = ParserCypherTypeName.PROPERTY_VALUE; }
            | <ANY> (
                (<NODE> | <VERTEX>) { typeName = ParserCypherTypeName.NODE; }
                | (<RELATIONSHIP> | <EDGE>) { typeName = ParserCypherTypeName.RELATIONSHIP; }
                | <MAP> { typeName = ParserCypherTypeName.MAP; }
                | <PROPERTY> <VALUE> { typeName = ParserCypherTypeName.PROPERTY_VALUE; }
                | LOOKAHEAD(2) (<VALUE>)? <LT> unionTypeList=cypherTypeNameList() <GT> { typeName = ParserCypherTypeName.closedDynamicUnionOf(unionTypeList); }
                | (<VALUE>)? { typeName = ParserCypherTypeName.ANY; }
            )
        ) ( (<NOT> <NULL> | <EXCLAMATION_MARK>) { typeName =  ParserCypherTypeName.getNotNullTypeName(typeName); } )?
        ((<LIST> | <ARRAY>) { typeName = ParserCypherTypeName.listOf(typeName); } ((<NOT> <NULL> | <EXCLAMATION_MARK>) { typeName =  ParserCypherTypeName.getNotNullTypeName(typeName); })? )*
    } catch (IllegalArgumentException e) {
        // This is thrown if the getNotNullTypeName errors, it will error on Open Dynamic Union Types.
        t = t.next;
        throw exceptionFactory.syntaxException(e, t.beginOffset, t.beginLine, t.beginColumn);
    }
    {
        t = t.next;
        return typeName.withPos(t.beginOffset, t.beginLine, t.beginColumn);
    }
}

SCHEMA_COMMAND DropConstraint( Token start ) throws Exception:
{
        SimpleEither<StringPos<POS>, PARAMETER> name = null;
        boolean ifExists = false;
        VARIABLE variable = null;
        Token label = null;
        List<PROPERTY> properties= new ArrayList<>();
        ConstraintType constraintType = ConstraintType.NODE_EXISTS;
        boolean isNode = false;
        Token errorStart;
}
{
    <CONSTRAINT>
    ( LOOKAHEAD (<ON> <LPAREN>) <ON> <LPAREN>
        (
            //(n:LABEL)
            variable=Variable() label=LabelOrRelType() <RPAREN> { isNode = true; }
        |   //()-[r:RELTYPE]-()
            <RPAREN> ( LeftArrow() )? ArrowLine()
            <LBRACKET> variable=Variable() label=LabelOrRelType() <RBRACKET>
            ArrowLine() ( RightArrow() )? <LPAREN> <RPAREN>
        )
        <ASSERT>
        (
            LOOKAHEAD(<EXISTS>) errorStart=<EXISTS> { constraintType = isNode ? ConstraintType.NODE_EXISTS : ConstraintType.REL_EXISTS; }
            properties=PropertyList()
       |
            properties=PropertyList()
            errorStart=<IS>
              (
                  //DROP CONSTRAINT ON (node:Label) ASSERT (node.prop) IS UNIQUE
                  <UNIQUE> {
                          constraintType = ConstraintType.NODE_UNIQUE;
                          if ( !isNode )
                          {
                              throw exceptionFactory.syntaxException(
                                  new ParseException( ASTExceptionFactory.relationshipPatternNotAllowed( constraintType ) ),
                                  errorStart.beginOffset, errorStart.beginLine, errorStart.beginColumn );
                          }
                      }
                  | //DROP CONSTRAINT ON (node:Label) ASSERT (node.prop) IS NODE KEY
                      <NODE> <KEY>
                      {
                          constraintType = ConstraintType.NODE_KEY ;
                          if ( !isNode )
                          {
                              throw exceptionFactory.syntaxException(
                                  new ParseException( ASTExceptionFactory.relationshipPatternNotAllowed( constraintType ) ),
                                  errorStart.beginOffset, errorStart.beginLine, errorStart.beginColumn );
                          }
                      }
                  | <NOT> <NULL> {
                      constraintType = isNode ? ConstraintType.NODE_IS_NOT_NULL : ConstraintType.REL_IS_NOT_NULL;
                  }
              )
        )
        {
            throw exceptionFactory.syntaxException(
                                              new ParseException( ASTExceptionFactory.invalidDropConstraint( constraintType, properties.size() > 1 ) ),
                                              start.beginOffset, start.beginLine, start.beginColumn );
        }
    |   //DROP CONSTRAINT name IF EXISTS
        name=SymbolicNameOrStringParameter() ( <IF> <EXISTS> { ifExists = true; } )?
        {
            return astFactory.dropConstraint( pos( start ), name, ifExists );
        }
    )
}

// Index commands

SCHEMA_COMMAND CreateIndex( Token start, boolean replace ) throws Exception:
{
    SCHEMA_COMMAND command = null;
}
{
    (
        <BTREE> <INDEX> command=createIndex( start, replace, CreateIndexTypes.BTREE )
        | <RANGE> <INDEX> command=createIndex( start, replace, CreateIndexTypes.RANGE )
        | <FULLTEXT> <INDEX> command=createFulltextIndex( start, replace )
        | <TEXT> <INDEX> command=createIndex( start, replace, CreateIndexTypes.TEXT )
        | <POINT> <INDEX> command=createIndex( start, replace, CreateIndexTypes.POINT )
        | <VECTOR> <INDEX> command=createIndex( start, replace, CreateIndexTypes.VECTOR )
        | <LOOKUP> <INDEX> command=createLookupIndex( start, replace )
        | <INDEX> (
            LOOKAHEAD(<ON> <COLON>) <ON> oldCreateIndex( start, replace ) // old syntax: CREATE INDEX ON :nodeLabel(prop1, prop2)
            | command=createIndex( start, replace, CreateIndexTypes.DEFAULT )
        )
    )
    {
        return command;
    }
}

void oldCreateIndex(Token start, boolean replace ) throws Exception:
{
    Token nodeLabel;
    List<StringPos<POS>> properties;
}
{
    //CREATE INDEX ON :nodeLabel(prop1, prop2)
    nodeLabel=LabelOrRelType()
    <LPAREN> properties = SymbolicNamePositions() <RPAREN>
    {
        if (replace) {
            throw exceptionFactory.syntaxException( new ParseException("'REPLACE' is not allowed for this index syntax"), start.beginOffset, start.beginLine, start.beginColumn );
        }
        throw exceptionFactory.syntaxException( new ParseException("Invalid create index syntax, use `CREATE INDEX FOR ...` instead."), start.beginOffset, start.beginLine, start.beginColumn );
    }
}

SCHEMA_COMMAND createIndex( Token start, boolean replace, CreateIndexTypes indexType ) throws Exception:
{
    boolean ifNotExists = false;
    boolean isNode = false;
    SimpleEither<StringPos<POS>, PARAMETER> indexName = null;
    VARIABLE variable = null;
    Token label = null;
    List<PROPERTY> properties= new ArrayList<>();
    SimpleEither<Map<String, EXPRESSION>, PARAMETER> options = null;
}
{
    //CREATE [RANGE | BTREE | TEXT | POINT | VECTOR] INDEX FOR (n:label) ON (n.prop)
    (
        //lookaheads for potential symbolicNames "for", "if"
        LOOKAHEAD(<FOR> <LPAREN>) <FOR> <LPAREN>
        | LOOKAHEAD(<IF> <NOT>) <IF> <NOT> <EXISTS> { ifNotExists = true; }  <FOR> <LPAREN>
        | indexName=SymbolicNameOrStringParameter() ( <IF> <NOT> <EXISTS> { ifNotExists = true; } )? <FOR> <LPAREN>
    )
    (
        //(n:LABEL)
        variable=Variable() label=LabelOrRelType() <RPAREN> { isNode = true; }
    |   //()-[r:RELTYPE]-()
        <RPAREN> ( LeftArrow() )? ArrowLine()
        <LBRACKET> variable=Variable() label=LabelOrRelType() <RBRACKET>
        ArrowLine() ( RightArrow() )? <LPAREN> <RPAREN>
    )
    <ON>
    properties=PropertyList()
    ( <OPTIONS> options=MapOrParameter() )?
    {
        return astFactory.createIndex( pos(start), replace, ifNotExists, isNode, indexName, variable, new StringPos<>(label.image, pos(label)), properties, options, indexType );
    }
}

SCHEMA_COMMAND createFulltextIndex( Token start, boolean replace) throws Exception:
{
    boolean ifNotExists = false;
    boolean isNode = false;
    SimpleEither<StringPos<POS>, PARAMETER> indexName = null;
    VARIABLE variable = null;
    VARIABLE propName = null;
    PROPERTY p = null;
    List<StringPos<POS>> labels = new ArrayList<>();
    List<PROPERTY> properties= new ArrayList<>();
    SimpleEither<Map<String, EXPRESSION>, PARAMETER> options = null;
}
{
    //CREATE FULLTEXT INDEX FOR (n:T1 | T2) ON (v.prop)
    (
        //lookaheads for potential symbolicNames "for", "if"
        LOOKAHEAD(<FOR> <LPAREN>) <FOR> <LPAREN>
        | LOOKAHEAD(<IF> <NOT>) ( <IF> <NOT> <EXISTS> { ifNotExists = true; } ) <FOR> <LPAREN>
        | indexName=SymbolicNameOrStringParameter() ( <IF> <NOT> <EXISTS> { ifNotExists = true; } )? <FOR> <LPAREN>
    )
        (   //(v:L1 | ... | Ln)
            variable=Variable() labels=LabelOrRelTypes() <RPAREN> { isNode = true; }
        |
            //()-[r:R1 | ... | Rn]-()
            <RPAREN> ( LeftArrow() )? ArrowLine()
            <LBRACKET> variable=Variable() labels=LabelOrRelTypes() <RBRACKET>
            ArrowLine() ( RightArrow() )? <LPAREN> <RPAREN>
        )
        <ON> <EACH>
        <LBRACKET>
            propName=Variable() p=Property( propName ) { properties.add( p ); }
            ( <COMMA> propName=Variable() p=Property( propName ) { properties.add( p ); } )*
        <RBRACKET>
        ( <OPTIONS> options=MapOrParameter() )?
        {
            return astFactory.createFulltextIndex( pos(start), replace, ifNotExists, isNode, indexName, variable, labels, properties, options );
        }
}

SCHEMA_COMMAND createLookupIndex( Token start, boolean replace ) throws Exception:
{
    boolean ifNotExists = false;
    boolean isNode = false;
    SimpleEither<StringPos<POS>, PARAMETER> indexName = null;
    VARIABLE variable = null;
    StringPos<POS> funcName = null;
    VARIABLE funcParam = variable;
    SimpleEither<Map<String, EXPRESSION>, PARAMETER> options = null;
}
{
    //CREATE LOOKUP INDEX FOR (n) ON EACH funcName(funcParam)
    (
            //lookaheads for potential symbolicNames "for", "if"
            LOOKAHEAD(<FOR> <LPAREN>) <FOR> <LPAREN>
            | LOOKAHEAD(<IF> <NOT>)( <IF> <NOT> <EXISTS> { ifNotExists = true; } ) <FOR> <LPAREN>
            | indexName=SymbolicNameOrStringParameter() ( <IF> <NOT> <EXISTS> { ifNotExists = true; } )? <FOR> <LPAREN>
    )
    (   //(v)
        variable=Variable() <RPAREN> <ON> <EACH> { isNode = true; }
    |
        //()-[r]-()
        <RPAREN> ( LeftArrow() )? ArrowLine()
        <LBRACKET> variable=Variable() <RBRACKET>
        ArrowLine() ( RightArrow() )? <LPAREN> <RPAREN> <ON> (LOOKAHEAD(<EACH>) <EACH>)?
    )
    SymbolicNameString() { funcName = new StringPos<POS>( token.image, pos(token) ); } <LPAREN> funcParam=Variable() <RPAREN>
    ( <OPTIONS> options=MapOrParameter() )?
    {
        return astFactory.createLookupIndex( pos(start), replace, ifNotExists, isNode, indexName, variable, funcName, funcParam, options );
    }
}

SCHEMA_COMMAND DropIndex( Token start ) throws Exception:
{
    Token nodeLabel;
    List<StringPos<POS>> properties;
    SimpleEither<StringPos<POS>, PARAMETER> name;
    boolean ifExists = false;
}
{
    <INDEX>
    ( LOOKAHEAD(2) <ON> nodeLabel=LabelOrRelType() <LPAREN> properties=SymbolicNamePositions() <RPAREN>
        { throw exceptionFactory.syntaxException( new ParseException("Indexes cannot be dropped by schema, please drop by name instead: DROP INDEX index_name. The index name can be found using SHOW INDEXES."), start.beginOffset, start.beginLine, start.beginColumn ); }
    | name=SymbolicNameOrStringParameter() ( <IF> <EXISTS> { ifExists = true; } )?
        { return astFactory.dropIndex( pos(start), name, ifExists ); }
    )
}

List<PROPERTY> PropertyList():
{
    VARIABLE variable;
    PROPERTY p;
    List<PROPERTY> properties= new ArrayList<>();
}
{
        (
            variable=Variable() p=Property( variable ) { properties.add( p ); }
            | <LPAREN>
                variable=Variable() p=Property( variable ) { properties.add( p ); }
                ( <COMMA> variable=Variable() p=Property( variable ) { properties.add( p ); } )*
            <RPAREN>
        )
        {
            return properties;
        }
}

// Administration Commands

ADMINISTRATION_COMMAND RenameCommand():
{
    Token start;
    ADMINISTRATION_COMMAND command;
}
{
    start=<RENAME>
    (
        command=RenameRole( start )
        | command=RenameUser( start )
        | command=RenameServer( start )
    )
    {
        return command;
    }
}

ADMINISTRATION_COMMAND GrantCommand() throws Exception:
{
    Token start;
    ADMINISTRATION_COMMAND c;
    boolean immutable = false;
}
{
    start=<GRANT>
    (
      <IMMUTABLE> (
          c=grantPrivilege(start, true)
          |<ROLE> c=grantRoleManagement(start, true)
      ) |
      (
          c=grantPrivilege(start, false)
          | <ROLE> (
                LOOKAHEAD(<MANAGEMENT> <ON>) c=grantRoleManagement(start, false)
                | c=GrantRole(start)
            )
          | <ROLES> c=GrantRole(start)
      )
    )
    {
        return c;
    }
}

ADMINISTRATION_COMMAND RevokeCommand() throws Exception:
{
    Token start;
    ADMINISTRATION_COMMAND c;
    boolean immutable = false;
}
{
    start=<REVOKE>
    (
      <DENY> (<IMMUTABLE> { immutable = true; } )? ( c=RevokePrivilege(start, false, true, immutable) | <ROLE> c=revokeRoleManagement(start, false, true, immutable) )
      | <GRANT> (<IMMUTABLE> { immutable = true; } )? ( c=RevokePrivilege(start, true, false, immutable) | <ROLE> c=revokeRoleManagement(start, true, false, immutable) )
      | <IMMUTABLE> (
        c=RevokePrivilege(start, true, true, true)
        |<ROLE> c=revokeRoleManagement(start, true, true, true)
      )
      | (
        c=RevokePrivilege(start, true, true, false)
        | LOOKAHEAD(<ROLE> <MANAGEMENT> <ON>) <ROLE> c=revokeRoleManagement(start, true, true, false)
        | (<ROLE> | <ROLES>) c=RevokeRole(start)
      )
    )
    {
        return c;
    }
}

// Server commands

ADMINISTRATION_COMMAND EnableServerCommand() throws Exception:
{
    Token start;
    SimpleEither<String, PARAMETER> serverName = null;
    SimpleEither<Map<String, EXPRESSION>, PARAMETER> options = null;
}
{
    start=<ENABLE> <SERVER> serverName=StringOrParameter()
    ( options=Options() )?
    {
        return astFactory.enableServer( pos( start ), serverName, options );
    }
}

ADMINISTRATION_COMMAND AlterServer( Token start ) throws Exception:
{
    SimpleEither<String, PARAMETER> serverName = null;
    SimpleEither<Map<String, EXPRESSION>, PARAMETER> options = null;
}
{
    <SERVER> serverName=StringOrParameter() <SET> options=Options()
    {
        return astFactory.alterServer( pos( start ), serverName, options );
    }
}

ADMINISTRATION_COMMAND RenameServer( Token start ):
{
    SimpleEither<String, PARAMETER> serverName = null;
    SimpleEither<String, PARAMETER> newName = null;
}
{
    <SERVER> serverName=StringOrParameter() <TO> newName=StringOrParameter()
    {
        return astFactory.renameServer( pos( start ), serverName, newName );
    }
}

ADMINISTRATION_COMMAND DropServer( Token start ):
{
    SimpleEither<String, PARAMETER> serverName = null;
}
{
    <SERVER> serverName=StringOrParameter()
    {
        return astFactory.dropServer( pos( start ), serverName );
    }
}

STATEMENT_WITH_GRAPH ShowServers( Token start, USE_CLAUSE useClause ) throws Exception:
{
    YIELD yield = null;
    RETURN_CLAUSE returnClause = null;
    WHERE where = null;
}
{
    (<SERVERS> | <SERVER>)
    (
        ( yield = YieldClause() ( returnClause = ReturnClause() )? )
        | ( where=WhereClause() )
    )?
    {
        return astFactory.useGraph( astFactory.showServers( pos( start ), yield, returnClause, where ), useClause );
    }
}

ADMINISTRATION_COMMAND AllocationCommand():
{
    boolean dryRun = false;
    ADMINISTRATION_COMMAND s;
}
{
    ( <DRYRUN> {dryRun = true;} )?
    (
        s=DeallocateDatabaseFromServers(dryRun)
        | s=ReallocateDatabases(dryRun)
    )
    {
        return s;
    }
}


ADMINISTRATION_COMMAND DeallocateDatabaseFromServers(boolean dryRun):
{
    Token start;
    List<SimpleEither<String, PARAMETER>> serverNames = new ArrayList<>();
    SimpleEither<String, PARAMETER> entry;
}
{
    start=<DEALLOCATE> ( <DATABASE> | <DATABASES> ) <FROM> ( <SERVER> | <SERVERS> )
    entry=StringOrParameter() { serverNames.add( entry ); } ( <COMMA> entry=StringOrParameter() { serverNames.add( entry ); } )*
    {
        return astFactory.deallocateServers( pos( start ), dryRun, serverNames );
    }
}

ADMINISTRATION_COMMAND ReallocateDatabases(boolean dryRun):
{
    Token start;
}
{
    start=<REALLOCATE> ( <DATABASE> | <DATABASES> )
    {
        return astFactory.reallocateDatabases( pos( start ), dryRun );
    }
}

// Role commands

ADMINISTRATION_COMMAND CreateRole( Token start, boolean replace ):
{
    SimpleEither<StringPos<POS>, PARAMETER> roleName = null;
    SimpleEither<StringPos<POS>, PARAMETER> sourceRoleName = null;
    boolean ifNotExists = false;
}
{
    <ROLE>
    roleName=SymbolicNameOrStringParameter()
    ( <IF> <NOT> <EXISTS> { ifNotExists = true; } )?
    ( <AS> <COPY> <OF> sourceRoleName=SymbolicNameOrStringParameter() )?
    {
        return astFactory.createRole( pos( start ), replace, roleName, sourceRoleName, ifNotExists );
    }
}

ADMINISTRATION_COMMAND DropRole( Token start ):
{
    SimpleEither<StringPos<POS>, PARAMETER> roleName = null;
    boolean ifExists = false;
}
{
    <ROLE>
    roleName=SymbolicNameOrStringParameter()
    ( <IF> <EXISTS> { ifExists = true; } )?
    {
        return astFactory.dropRole( pos( start ), roleName, ifExists );
    }
}

ADMINISTRATION_COMMAND RenameRole( Token start ):
{
    SimpleEither<StringPos<POS>, PARAMETER> fromRoleName = null;
    SimpleEither<StringPos<POS>, PARAMETER> toRoleName = null;
    boolean ifExists = false;
}
{
    <ROLE>
    fromRoleName=SymbolicNameOrStringParameter()
    ( <IF> <EXISTS> { ifExists = true; } )?
    <TO>
    toRoleName=SymbolicNameOrStringParameter()
    {
        return astFactory.renameRole( pos( start ), fromRoleName, toRoleName, ifExists );
    }
}

STATEMENT_WITH_GRAPH ShowRoles( Token start, USE_CLAUSE useClause, boolean showAll ) throws Exception:
{
    boolean withUsers = false;
    YIELD yield = null;
    RETURN_CLAUSE returnClause = null;
    WHERE where = null;
}
{
    ( <WITH> (<USERS> | <USER>) { withUsers = true; } )?
    (
        ( yield = YieldClause() ( returnClause = ReturnClause() )? )
        | ( where=WhereClause() )
    )?
    {
        return astFactory.useGraph( astFactory.showRoles( pos( start ), withUsers, showAll, yield, returnClause, where ), useClause );
    }
}

ADMINISTRATION_COMMAND GrantRole( Token start ):
{
    List<SimpleEither<StringPos<POS>, PARAMETER>> roles;
    List<SimpleEither<StringPos<POS>, PARAMETER>> users;
}
{
    roles=SymbolicNameOrStringParameterList() <TO> users=SymbolicNameOrStringParameterList()
    {
        return astFactory.grantRoles( pos( start ), roles, users );
    }
}

ADMINISTRATION_COMMAND RevokeRole(Token start):
{
    List<SimpleEither<StringPos<POS>, PARAMETER>> roles;
    List<SimpleEither<StringPos<POS>, PARAMETER>> users;
}
{
    roles=SymbolicNameOrStringParameterList() <FROM> users=SymbolicNameOrStringParameterList()
    {
        return astFactory.revokeRoles( pos( start ), roles, users );
    }
}

// User commands

ADMINISTRATION_COMMAND CreateUser( Token start, boolean replace ) throws Exception:
{
    Token token = null;
    SimpleEither<StringPos<POS>, PARAMETER> username = null;
    boolean ifNotExists = false;
    Optional<Boolean> suspended = Optional.empty();
    Optional<DATABASE_NAME> homeDatabase = Optional.empty();
    AUTH auth = null;
    List<AUTH> auths = new ArrayList<>();
    List<AUTH_ATTRIBUTE> systemAuthAttributes = new ArrayList<>();
}
{
    <USER>
    username=SymbolicNameOrStringParameter()
    ( <IF> <NOT> <EXISTS> { ifNotExists = true; } )?
    (
        token=<SET> (
            token=<PLAINTEXT>
                <PASSWORD> SetPassword(token, systemAuthAttributes, false) ( PasswordChangeRequired( systemAuthAttributes ) )?
            | token=<ENCRYPTED>
                <PASSWORD> SetPassword(token, systemAuthAttributes, true) ( PasswordChangeRequired( systemAuthAttributes ) )?
            | token=<PASSWORD> (
                PasswordChangeRequired( systemAuthAttributes )
                | SetPassword(token, systemAuthAttributes, false) ( PasswordChangeRequired( systemAuthAttributes ) )?
            )
            | suspended=UserStatus( token, suspended )
            | homeDatabase=HomeDatabase( token, homeDatabase )
            | auth=UserAuthObjects() { auths.add(auth); }
        )
    )+
    {
        return astFactory.createUser( pos( start ), replace, ifNotExists, username,
                                      suspended.orElse( null ), homeDatabase.orElse( null ),
                                      auths, systemAuthAttributes );
    }
}

ADMINISTRATION_COMMAND DropUser( Token start ) :
{
    SimpleEither<StringPos<POS>, PARAMETER> username = null;
    boolean ifExists = false;
}
{
    <USER>
    username=SymbolicNameOrStringParameter()
    ( <IF> <EXISTS> { ifExists = true; } )?
    {
        return astFactory.dropUser( pos( start ), ifExists, username );
    }
}

ADMINISTRATION_COMMAND RenameUser(Token start):
{
    SimpleEither<StringPos<POS>, PARAMETER> fromUserName = null;
    SimpleEither<StringPos<POS>, PARAMETER> toUserName = null;
    boolean ifExists = false;
}
{
    <USER>
    fromUserName=SymbolicNameOrStringParameter()
    (<IF> <EXISTS> { ifExists = true; } )?
    <TO>
    toUserName=SymbolicNameOrStringParameter()
    {
        return astFactory.renameUser( pos( start ), fromUserName, toUserName, ifExists );
    }
}

ADMINISTRATION_COMMAND AlterCurrentUser( Token start ) throws Exception:
{
    EXPRESSION currentPassword = null;
    EXPRESSION newPassword = null;
}
{
    <CURRENT> <USER> <SET> <PASSWORD> <FROM> currentPassword=passwordExpression() <TO> newPassword=passwordExpression()
    {
        return astFactory.setOwnPassword( pos( start ), currentPassword, newPassword);
    }
}

ADMINISTRATION_COMMAND AlterUser( Token start ) throws Exception:
{
    Token token = null;
    Token token2 = null;
    SimpleEither<StringPos<POS>, PARAMETER> username = null;
    boolean ifExists = false;
    Optional<Boolean> suspended = Optional.empty();
    Optional<DATABASE_NAME> homeDatabase = Optional.empty();
    boolean removeHome = false;
    boolean removeAllAuth = false;
    EXPRESSION provider = null;
    List<EXPRESSION> removeAuths = new ArrayList<>();
    AUTH auth = null;
    List<AUTH> auths = new ArrayList<>();
    List<AUTH_ATTRIBUTE> systemAuthAttributes = new ArrayList<>();
}
{
    <USER>
    username=SymbolicNameOrStringParameter()
    ( <IF> <EXISTS> { ifExists = true; } )?
    (
        token=<REMOVE> (
            <HOME> <DATABASE> { removeHome = true; }
            | <ALL> <AUTH> (<PROVIDER> | <PROVIDERS>)? { removeAllAuth = true; }
            | <AUTH> (<PROVIDER> | <PROVIDERS>)? (
               provider=StringLiteral() | provider=Parameter( ParameterType.ANY ) | provider=StringListLiteral()
            ) { removeAuths.add(provider); }
        )
    )*
    (
        token=<SET> (
            token2=<PLAINTEXT>
                <PASSWORD> SetPassword(token2, systemAuthAttributes, false) ( PasswordChangeRequired( systemAuthAttributes ) )?
            | token2=<ENCRYPTED>
                <PASSWORD> SetPassword(token2, systemAuthAttributes, true) ( PasswordChangeRequired( systemAuthAttributes ) )?
            | token2=<PASSWORD> (
                PasswordChangeRequired( systemAuthAttributes )
                | SetPassword(token2, systemAuthAttributes, false) ( PasswordChangeRequired( systemAuthAttributes ) )?
            )
            | suspended=UserStatus( token, suspended )
            | homeDatabase=HomeDatabase( token, homeDatabase )
            | auth=UserAuthObjects() { auths.add(auth); }
        )
    )*
    {
        return astFactory.alterUser( pos( start ), ifExists, username,
            suspended.orElse( null ), homeDatabase.orElse( null ), removeHome,
             auths, systemAuthAttributes, removeAllAuth, removeAuths );
    }
}

void SetPassword( Token start, List<AUTH_ATTRIBUTE> attributes, boolean encrypted ) throws Exception:
{
    EXPRESSION newPassword = null;
}
{
    newPassword=passwordExpression()
    {
        attributes.add(astFactory.password(pos(start), newPassword, encrypted));
    }
}

EXPRESSION passwordExpression():
{
   Token name = null;
   PARAMETER parameter = null;
}
{
    (
        name=StringToken()
        | parameter=Parameter( ParameterType.STRING )
    )
    {
        if ( name != null )
        {
            return astFactory.passwordExpression( pos(name), endPos(name), name.image );
        }
        else
        {
            return astFactory.passwordExpression( parameter );
        }
    }
}

void PasswordChangeRequired( List<AUTH_ATTRIBUTE> attributes ) throws Exception:
{
    boolean required = true;
    Token token = null;
}
{
    token=<CHANGE> ( <NOT> { required = false; } )? <REQUIRED>
    {
        attributes.add(astFactory.passwordChangeRequired( pos(token), required ));
    }
}

Optional<Boolean> UserStatus( Token start, Optional<Boolean> suspended ) throws Exception:
{
    String errorMessage = "Duplicate SET STATUS {SUSPENDED|ACTIVE} clause";
    boolean suspend = false;
}
{
    <STATUS> (
        <SUSPENDED> { suspend = true; }
        | <ACTIVE> { suspend = false; }
    )
    {
        assertNotAlreadySet( suspended.orElse(null), start, errorMessage );
        return Optional.of( suspend );
    }
}

Optional<DATABASE_NAME> HomeDatabase( Token start, Optional<DATABASE_NAME> homeDatabase ) throws Exception:
{
    String errorMessage = "Duplicate SET HOME DATABASE clause";
    AliasName<DATABASE_NAME, PARAMETER> home = null;
}
{
    <HOME> <DATABASE> home=SymbolicAliasNameOrParameter()
    {
        assertNotAlreadySet( homeDatabase.orElse(null), start, errorMessage );
        return Optional.of( home.getLocalAliasName(astFactory) );
    }
}

AUTH UserAuthObjects() throws Exception:
{
    Token start = null;
    Token set = null;
    Token provider = null;
    EXPRESSION password = null;
    boolean changeRequired = true;
    EXPRESSION id = null;
    List<AUTH_ATTRIBUTE> authAttributes = new ArrayList<>();
}
{
    start=<AUTH> (<PROVIDER>)? provider=StringToken() <LCURLY> (
        <SET> (
            set=<ID> (id=StringLiteral() | id=Parameter( ParameterType.STRING )) { authAttributes.add(astFactory.authId(pos(set), id)); }
            | set=<PLAINTEXT> <PASSWORD> SetPassword(set, authAttributes, false)
            | set=<ENCRYPTED> <PASSWORD> SetPassword(set, authAttributes, true)
            | set=<PASSWORD> (
               PasswordChangeRequired(authAttributes)
               | SetPassword(set, authAttributes, false)
            )
        )
    )+ <RCURLY>
    {
        return astFactory.auth(provider.image, authAttributes, pos(start));
    }
}

STATEMENT_WITH_GRAPH ShowUsers( Token start, USE_CLAUSE useClause ) throws Exception:
{
    boolean withAuth = false;
    YIELD yield = null;
    RETURN_CLAUSE returnClause = null;
    WHERE where = null;
}
{
    (<WITH> <AUTH> { withAuth = true; })?
    (
        ( yield = YieldClause() ( returnClause = ReturnClause() )? )
        | where=WhereClause()
    )?
    {
        return astFactory.useGraph( astFactory.showUsers( pos( start ), yield, returnClause, where, withAuth ), useClause );
    }
}

STATEMENT_WITH_GRAPH ShowCurrentUser( Token start, USE_CLAUSE useClause ) throws Exception:
{
    YIELD yield = null;
    RETURN_CLAUSE returnClause = null;
    WHERE where = null;
}
{
    <CURRENT> <USER> (
        ( yield = YieldClause() ( returnClause = ReturnClause() )? )
        | where=WhereClause() )?
    {
        return astFactory.useGraph( astFactory.showCurrentUser( pos( start ), yield, returnClause, where ), useClause );
    }
}

// Privilege commands

STATEMENT_WITH_GRAPH ShowSupportedPrivileges( Token start, USE_CLAUSE useClause ) throws Exception:
{
    YIELD yield = null;
    RETURN_CLAUSE returnClause = null;
    WHERE where = null;
}
{
    <SUPPORTED> (<PRIVILEGE> | <PRIVILEGES>)
    (
        ( yield = YieldClause() ( returnClause = ReturnClause() )? )
        | ( where=WhereClause() )
    )?
    {
        return astFactory.useGraph( astFactory.showSupportedPrivileges( pos( start ), yield, returnClause, where ), useClause );
    }
}

STATEMENT_WITH_GRAPH ShowPrivileges( Token start, USE_CLAUSE useClause ) throws Exception:
{
    boolean asCommand = false;
    boolean asRevoke = false;
    YIELD yield = null;
    RETURN_CLAUSE returnClause = null;
    WHERE where = null;
}
{
    (<PRIVILEGE> | <PRIVILEGES>)
    (
        <AS>
        (<REVOKE>  { asRevoke=true; })?
        ( <COMMAND> | <COMMANDS> )
        { asCommand=true; }
    )?
    (
        ( yield = YieldClause() ( returnClause = ReturnClause() )? )
        | ( where=WhereClause() )
    )?
    {
        return astFactory.useGraph( astFactory.showAllPrivileges( pos( start ), asCommand, asRevoke, yield, returnClause, where ), useClause );
    }
}

STATEMENT_WITH_GRAPH ShowRolePrivileges( Token start, USE_CLAUSE useClause ) throws Exception:
{
    List<SimpleEither<StringPos<POS>, PARAMETER>> roles = null;
    boolean asCommand = false;
    boolean asRevoke = false;
    YIELD yield = null;
    RETURN_CLAUSE returnClause = null;
    WHERE where = null;
}
{
    roles=SymbolicNameOrStringParameterList()
    (<PRIVILEGE> | <PRIVILEGES>)
     (
        <AS>
        (<REVOKE>  { asRevoke=true; })?
        ( <COMMAND> | <COMMANDS> )
        { asCommand=true; }
    )?
    (
        ( yield = YieldClause() ( returnClause = ReturnClause() )? )
        | ( where=WhereClause() )
    )?
    {
        return astFactory.useGraph( astFactory.showRolePrivileges( pos( start ), roles, asCommand, asRevoke, yield, returnClause, where ), useClause );
    }
}

STATEMENT_WITH_GRAPH ShowUserPrivileges( Token start, USE_CLAUSE useClause ) throws Exception:
{
    List<SimpleEither<StringPos<POS>, PARAMETER>> users = null;
    boolean asCommand = false;
    boolean asRevoke = false;
    YIELD yield = null;
    RETURN_CLAUSE returnClause = null;
    WHERE where = null;
}
{
    (
        // The lookahead is needed to distinguish 'SHOW USER[S] privilege[, ..] PRIVILEGE[S] ...' and 'SHOW USER[S] PRIVILEGE[S] ...'
        LOOKAHEAD(( <PRIVILEGE> | <PRIVILEGES> ) ( <PRIVILEGE> | <PRIVILEGES> | <COMMA> )) (users=SymbolicNameOrStringParameterList() ( <PRIVILEGE> | <PRIVILEGES> ))
        | ( <PRIVILEGE> | <PRIVILEGES> )
        | (users=SymbolicNameOrStringParameterList() ( <PRIVILEGE> | <PRIVILEGES> ))
    )
    (
        <AS>
        (<REVOKE>  { asRevoke=true; })?
        ( <COMMAND> | <COMMANDS> )
        { asCommand=true; }
    )?
    (
        ( yield = YieldClause() ( returnClause = ReturnClause() )? )
        | ( where=WhereClause() )
    )?
    {
        return astFactory.useGraph( astFactory.showUserPrivileges( pos( start ), users, asCommand, asRevoke, yield, returnClause, where ), useClause );
    }
}

ADMINISTRATION_COMMAND grantRoleManagement(Token start, boolean immutable):
{
    PRIVILEGE_TYPE privilege = null;
    List<SimpleEither<StringPos<POS>, PARAMETER>> roles = null;
}
{
    privilege=roleManagementPrivilege(start, immutable) <TO> roles=SymbolicNameOrStringParameterList()
    {
        return astFactory.grantPrivilege( pos(start), roles, privilege );
    }
}

ADMINISTRATION_COMMAND revokeRoleManagement(Token start, boolean revokeGrant, boolean revokeDeny, boolean immutable):
{
    PRIVILEGE_TYPE privilege = null;
    List<SimpleEither<StringPos<POS>, PARAMETER>> roles = null;
}
{
    privilege=roleManagementPrivilege(start, immutable) <FROM> roles=SymbolicNameOrStringParameterList()
    {
        return astFactory.revokePrivilege( pos(start), roles, privilege, revokeGrant, revokeDeny );
    }
}

PRIVILEGE_TYPE roleManagementPrivilege(Token start, boolean immutable):
{
    List<SimpleEither<String, PARAMETER>> roles = null;
}
{
    <MANAGEMENT> <ON> <DBMS>
    {
        return astFactory.dbmsPrivilege( pos(start), astFactory.privilegeAction( ActionType.ROLE_ALL ), astFactory.allQualifier(), immutable );
    }
}

ADMINISTRATION_COMMAND grantPrivilege(Token start, boolean immutable) throws Exception:
{
    List<SimpleEither<StringPos<POS>, PARAMETER>> roles = null;
    PRIVILEGE_TYPE privilege = null;
}
{
    privilege=privilege(start, immutable) <TO> roles=SymbolicNameOrStringParameterList()
    {
        return astFactory.grantPrivilege( pos(start), roles, privilege );
    }
}

ADMINISTRATION_COMMAND DenyPrivilege() throws Exception:
{
    Token start;
    List<SimpleEither<StringPos<POS>, PARAMETER>> roles = null;
    PRIVILEGE_TYPE privilege = null;
    boolean immutable = false;
}
{
    start=<DENY> (<IMMUTABLE> { immutable = true; } )?
    (
       privilege=privilege(start, immutable)
       // DENY doesn't have a choice conflict for ROLE MANAGEMENT
       | <ROLE> privilege=roleManagementPrivilege(start, immutable)
    )
    <TO> roles=SymbolicNameOrStringParameterList()
    {
        return astFactory.denyPrivilege( pos(start), roles, privilege );
    }
}

ADMINISTRATION_COMMAND RevokePrivilege(Token start, boolean revokeGrant, boolean revokeDeny, boolean immutable) throws Exception:
{
    List<SimpleEither<StringPos<POS>, PARAMETER>> roles = null;
    PRIVILEGE_TYPE privilege = null;
}
{
    privilege=privilege(start, immutable) <FROM> roles=SymbolicNameOrStringParameterList()
    {
        return astFactory.revokePrivilege( pos(start), roles, privilege, revokeGrant, revokeDeny );
    }
}

PRIVILEGE_TYPE privilege(Token start, boolean immutable) throws Exception:
{
    PRIVILEGE_TYPE privilege = null;
}
{
    (
        privilege=allPrivilege(start, immutable)
        | privilege=createPrivilege(start, immutable)
        | privilege=dropPrivilege(start, immutable)
        | privilege=showPrivilege(start, immutable)
        | privilege=loadPrivilege(start, immutable)
        | privilege=setPrivilege(start, immutable)
        | privilege=removePrivilege(start, immutable)
        | privilege=databasePrivilege(start, immutable)
        | privilege=dbmsPrivilege(start, immutable)
        | privilege=writePrivilege(start, immutable)
        | privilege=qualifiedGraphPrivileges(start, immutable)
        | privilege=qualifiedGraphPrivilegesWithProperty(start, immutable)
    )
    {
        return privilege;
    }
}

PRIVILEGE_TYPE allPrivilege(Token start, boolean immutable) throws Exception:
{
    ADMINISTRATION_ACTION action = null;
    List<DATABASE_NAME> names = null;
    boolean isAll = false;
    String type = null;
    Token t = null;
    ScopeType scopeType = ScopeType.NAMED;
}
{
    <ALL> ((<DBMS> { type = "DBMS"; } | <GRAPH> { type = "GRAPH"; } | <DATABASE> { type = "DATABASE"; } )? <PRIVILEGES>)? <ON> (
        t=<DEFAULT_TOKEN> (
             <GRAPH> {
                 assertValidType( t, type, "GRAPH" );
                 return astFactory.graphPrivilege( pos(start), astFactory.privilegeAction( ActionType.GRAPH_ALL ), astFactory.graphScope( pos( t ), null, ScopeType.DEFAULT ), null, astFactory.allQualifier(), immutable );
             }
             | <DATABASE> {
                assertValidType( t, type, "DATABASE" );
                return astFactory.databasePrivilege( pos(start), astFactory.privilegeAction( ActionType.DATABASE_ALL ), astFactory.databaseScope( pos( t ), null, ScopeType.DEFAULT ), astFactory.allDatabasesQualifier(), immutable );
             }
        )
        | t=<HOME> (
            <GRAPH> {
                assertValidType( t, type, "GRAPH" );
                return astFactory.graphPrivilege( pos(start), astFactory.privilegeAction( ActionType.GRAPH_ALL ), astFactory.graphScope( pos( t ), null, ScopeType.HOME ), null, astFactory.allQualifier(), immutable );
            }
            | <DATABASE> {
                assertValidType( t, type, "DATABASE" );
                return astFactory.databasePrivilege( pos(start), astFactory.privilegeAction( ActionType.DATABASE_ALL ), astFactory.databaseScope( pos( t ), null, ScopeType.HOME ), astFactory.allDatabasesQualifier(), immutable );
            }
        )
        | t=<DBMS> {
            assertValidType( t, type, "DBMS" );
            return astFactory.dbmsPrivilege( pos(start), astFactory.privilegeAction( ActionType.DBMS_ALL ), astFactory.allQualifier(), immutable );
        }
        | (t=<GRAPH> | t=<GRAPHS>) (<TIMES> { scopeType = ScopeType.ALL; } | names=SymbolicAliasNameList()) {
            assertValidType( t, type, "GRAPH" );
            return astFactory.graphPrivilege( pos(start), astFactory.privilegeAction( ActionType.GRAPH_ALL ), astFactory.graphScope( pos( t ), names, scopeType ), null, astFactory.allQualifier(), immutable );
        }
        | (t=<DATABASE> | t=<DATABASES>) (<TIMES> { scopeType = ScopeType.ALL; } | names=SymbolicAliasNameList() ) {
            assertValidType( t, type, "DATABASE" );
            return astFactory.databasePrivilege( pos(start), astFactory.privilegeAction( ActionType.DATABASE_ALL ), astFactory.databaseScope( pos( t ), names, scopeType ), astFactory.allDatabasesQualifier(), immutable );
        }
    )
}

PRIVILEGE_TYPE createPrivilege(Token start, boolean immutable) throws Exception:
{
    PRIVILEGE_TYPE privilege = null;
    ADMINISTRATION_ACTION action = null;
    DATABASE_SCOPE database = null;
    GRAPH_SCOPE graph = null;
    List<PRIVILEGE_QUALIFIER> qualifier = new ArrayList<>();
}
{
    <CREATE>
    (
       (
           (
               (<INDEX> | <INDEXES>) { action = astFactory.privilegeAction( ActionType.INDEX_CREATE ); }
               | (<CONSTRAINT> | <CONSTRAINTS>) { action = astFactory.privilegeAction( ActionType.CONSTRAINT_CREATE ); }
               | <NEW> (
                   (<NODE>)? (<LABEL> | <LABELS>) { action = astFactory.privilegeAction( ActionType.CREATE_LABEL ); }
                   | (<RELATIONSHIP>)? (<TYPE> | <TYPES>) { action = astFactory.privilegeAction( ActionType.CREATE_RELTYPE ); }
                   | (<PROPERTY>)? (<NAME> | <NAMES>) { action = astFactory.privilegeAction( ActionType.CREATE_PROPERTYKEY ); }
               )
           ) <ON> database=DatabaseScope() { privilege = astFactory.databasePrivilege( pos(start), action, database, astFactory.allDatabasesQualifier(), immutable ); }
       ) | (
           (
               <DATABASE> { action = astFactory.privilegeAction( ActionType.DATABASE_CREATE ); }
               | <ALIAS> { action = astFactory.privilegeAction( ActionType.ALIAS_CREATE ); }
               | <ROLE> { action = astFactory.privilegeAction( ActionType.ROLE_CREATE ); }
               | <USER> { action = astFactory.privilegeAction( ActionType.USER_CREATE ); }
               | <COMPOSITE> <DATABASE> { action = astFactory.privilegeAction( ActionType.DATABASE_COMPOSITE_CREATE ); }
           ) <ON> <DBMS> { privilege = astFactory.dbmsPrivilege( pos(start), action,  astFactory.allQualifier(), immutable ); }
       ) | ( <ON> graph=GraphScope() qualifier=graphQualifier() { privilege = astFactory.graphPrivilege( pos(start), astFactory.privilegeAction( ActionType.GRAPH_CREATE ), graph, null, qualifier, immutable ); } )
    ) { return privilege; }
}

PRIVILEGE_TYPE dropPrivilege(Token start, boolean immutable) throws Exception:
{
    PRIVILEGE_TYPE privilege = null;
    ADMINISTRATION_ACTION action = null;
    DATABASE_SCOPE database = null;
}
{
    <DROP>
    (
       (
           (
               (<INDEX> | <INDEXES>) { action = astFactory.privilegeAction( ActionType.INDEX_DROP ); }
               | (<CONSTRAINT> | <CONSTRAINTS>) { action = astFactory.privilegeAction( ActionType.CONSTRAINT_DROP ); }
           ) <ON> database=DatabaseScope() { privilege = astFactory.databasePrivilege( pos(start), action, database, astFactory.allDatabasesQualifier(), immutable ); }
       ) | (
           (
               <DATABASE> { action = astFactory.privilegeAction( ActionType.DATABASE_DROP ); }
               | <ALIAS> { action = astFactory.privilegeAction( ActionType.ALIAS_DROP ); }
               | <ROLE> { action = astFactory.privilegeAction( ActionType.ROLE_DROP ); }
               | <USER> { action = astFactory.privilegeAction( ActionType.USER_DROP ); }
               | <COMPOSITE> <DATABASE> { action = astFactory.privilegeAction( ActionType.DATABASE_COMPOSITE_DROP ); }
           ) <ON> <DBMS> { privilege = astFactory.dbmsPrivilege( pos(start), action, astFactory.allQualifier(), immutable ); }
       )
    ) { return privilege; }
}

PRIVILEGE_TYPE loadPrivilege(Token start, boolean immutable):
{
    SimpleEither<String,PARAMETER> cidr = null;
    SimpleEither<String,PARAMETER> url = null;
}
{
    <LOAD><ON>
    (
    <URL> url=StringOrParameter() 
    | <CIDR> cidr=StringOrParameter()
    | <ALL> <DATA>
    ){
      return astFactory.loadPrivilege(pos(start), url, cidr, immutable);
    }
}

PRIVILEGE_TYPE showPrivilege(Token start, boolean immutable) throws Exception:
{
    PRIVILEGE_TYPE privilege = null;
    ADMINISTRATION_ACTION action = null;
    DATABASE_SCOPE database = null;
    List<PRIVILEGE_QUALIFIER> databaseQualifier = astFactory.allDatabasesQualifier();
    List<PRIVILEGE_QUALIFIER> dbmsQualifier = astFactory.allQualifier();
    List<SimpleEither<StringPos<POS>, PARAMETER>>qualifiers = null;
}
{
    <SHOW>
    (
        (
            (
                (<INDEX> | <INDEXES>) { action = astFactory.privilegeAction( ActionType.INDEX_SHOW ); }
                | (<CONSTRAINT> | <CONSTRAINTS>) { action = astFactory.privilegeAction( ActionType.CONSTRAINT_SHOW ); }
                | (<TRANSACTION> | <TRANSACTIONS>) { action = astFactory.privilegeAction( ActionType.TRANSACTION_SHOW ); databaseQualifier = astFactory.allUsersQualifier(); }
                    ( <LPAREN> (<TIMES> | qualifiers=SymbolicNameOrStringParameterList() { databaseQualifier = astFactory.userQualifier(qualifiers); } ) <RPAREN> )?
            ) <ON> database=DatabaseScope() { privilege = astFactory.databasePrivilege( pos(start), action, database, databaseQualifier, immutable ); }
        ) | (
            (
                <ALIAS> { action = astFactory.privilegeAction( ActionType.ALIAS_SHOW ); }
                | <PRIVILEGE> { action = astFactory.privilegeAction( ActionType.PRIVILEGE_SHOW ); }
                | <ROLE> { action = astFactory.privilegeAction( ActionType.ROLE_SHOW ); }
                | <USER> { action = astFactory.privilegeAction( ActionType.USER_SHOW ); }
                | (<SERVER> | <SERVERS>) { action = astFactory.privilegeAction( ActionType.SERVER_SHOW ); }
                | (<SETTING> | <SETTINGS>) dbmsQualifier = settingQualifier(start) { action = astFactory.privilegeAction( ActionType.SETTING_SHOW ); }
            ) <ON> <DBMS> { privilege = astFactory.dbmsPrivilege( pos(start), action, dbmsQualifier, immutable ); }
        )
    ) { return privilege; }
}

PRIVILEGE_TYPE setPrivilege(Token start, boolean immutable) throws Exception:
{
    PRIVILEGE_TYPE privilege = null;
    ADMINISTRATION_ACTION action = null;
    GRAPH_SCOPE graph = null;
    PRIVILEGE_RESOURCE resource = null;
    List<PRIVILEGE_QUALIFIER> qualifier = null;
}
{
    <SET>
    (
        (
            (
                ( <PASSWORD> | <PASSWORDS> ) { action = astFactory.privilegeAction( ActionType.USER_PASSWORD ); }
                | <AUTH> { action = astFactory.privilegeAction( ActionType.USER_AUTH ); }
                | <USER> (
                    <STATUS> { action = astFactory.privilegeAction( ActionType.USER_STATUS ); }
                    | <HOME> <DATABASE> { action = astFactory.privilegeAction( ActionType.USER_HOME ); }
                )
                | <DATABASE> <ACCESS> { action = astFactory.privilegeAction( ActionType.SET_DATABASE_ACCESS); }
            ) <ON> <DBMS> { privilege = astFactory.dbmsPrivilege( pos(start), action, astFactory.allQualifier(), immutable ); }
        ) | (
            ( <LABEL> resource=labelResource() <ON> graph=GraphScope() { privilege = astFactory.graphPrivilege( pos(start), astFactory.privilegeAction( ActionType.GRAPH_LABEL_SET ), graph, resource, List.of( astFactory.allLabelsQualifier( pos(start) ) ), immutable ); } )
            | ( <PROPERTY> resource=propertyResource() <ON> graph=GraphScope() qualifier=graphQualifier() { privilege = astFactory.graphPrivilege( pos(start), astFactory.privilegeAction( ActionType.GRAPH_PROPERTY_SET ), graph, resource, qualifier, immutable ); } )
        )
    ) { return privilege; }
}

PRIVILEGE_TYPE removePrivilege(Token start, boolean immutable) throws Exception:
{
    PRIVILEGE_TYPE privilege = null;
    GRAPH_SCOPE graph = null;
    PRIVILEGE_RESOURCE resource = null;
    ADMINISTRATION_ACTION action = null;
}
{
    <REMOVE>
    (
        (
            (
                <PRIVILEGE> { action = astFactory.privilegeAction( ActionType.PRIVILEGE_REMOVE ); }
                | <ROLE> { action = astFactory.privilegeAction( ActionType.ROLE_REMOVE ); }
            ) <ON> <DBMS> { privilege = astFactory.dbmsPrivilege( pos(start), action, astFactory.allQualifier(), immutable ); }
        ) | ( <LABEL> resource=labelResource() <ON> graph=GraphScope() { privilege = astFactory.graphPrivilege( pos(start), astFactory.privilegeAction( ActionType.GRAPH_LABEL_REMOVE ), graph, resource, List.of( astFactory.allLabelsQualifier( pos(start) ) ), immutable ); } )
    ) { return privilege; }
}

PRIVILEGE_TYPE writePrivilege(Token start, boolean immutable) throws Exception:
{
    GRAPH_SCOPE graph = null;
    List<SimpleEither<String, PARAMETER>> qualifiers = null;
}
{
    <WRITE> <ON> graph=GraphScope()
    {
        return astFactory.graphPrivilege( pos(start), astFactory.privilegeAction( ActionType.GRAPH_WRITE ), graph, null, List.of( astFactory.allElementsQualifier( pos(start) ) ), immutable );
    }
}

PRIVILEGE_TYPE databasePrivilege(Token start, boolean immutable) throws Exception:
{
    ADMINISTRATION_ACTION action = null;
    DATABASE_SCOPE database = null;
    List<PRIVILEGE_QUALIFIER> qualifier = astFactory.allDatabasesQualifier();
    List<SimpleEither<StringPos<POS>, PARAMETER>>qualifiers = null;
}
{
    (
        <ACCESS> { action = astFactory.privilegeAction( ActionType.ACCESS ); }
        | <START> { action = astFactory.privilegeAction( ActionType.DATABASE_START ); }
        | <STOP> { action = astFactory.privilegeAction( ActionType.DATABASE_STOP ); }
        | (<INDEX> | <INDEXES>) (<MANAGEMENT>)? { action = astFactory.privilegeAction( ActionType.INDEX_ALL ); }
        | (<CONSTRAINT> | <CONSTRAINTS>) (<MANAGEMENT>)? { action = astFactory.privilegeAction( ActionType.CONSTRAINT_ALL ); }
        | <TRANSACTION> (<MANAGEMENT>)? { qualifier = astFactory.allUsersQualifier(); } (<LPAREN> (<TIMES> | qualifiers=SymbolicNameOrStringParameterList() { qualifier = astFactory.userQualifier(qualifiers); } ) <RPAREN>)? { action = astFactory.privilegeAction( ActionType.TRANSACTION_ALL ); }
        | <TERMINATE> (<TRANSACTION> | <TRANSACTIONS>) { qualifier = astFactory.allUsersQualifier(); } (<LPAREN> (<TIMES> | qualifiers=SymbolicNameOrStringParameterList() { qualifier = astFactory.userQualifier(qualifiers); } ) <RPAREN>)? { action = astFactory.privilegeAction( ActionType.TRANSACTION_TERMINATE ); }
        | <NAME> (<MANAGEMENT>)? { action = astFactory.privilegeAction( ActionType.CREATE_TOKEN ); }
    )
    <ON> database=DatabaseScope()
    {
        return astFactory.databasePrivilege( pos(start), action, database, qualifier, immutable );
    }
}

PRIVILEGE_TYPE dbmsPrivilege(Token start, boolean immutable):
{
    ADMINISTRATION_ACTION action = null;
    List<PRIVILEGE_QUALIFIER> qualifier = astFactory.allQualifier();
    List<SimpleEither<StringPos<POS>, PARAMETER>> qualifiers = null;
}
{
    (
        <ALTER> (
            <USER> { action = astFactory.privilegeAction( ActionType.USER_ALTER ); }
            | <DATABASE> { action = astFactory.privilegeAction( ActionType.DATABASE_ALTER ); }
            | <ALIAS> { action = astFactory.privilegeAction( ActionType.ALIAS_ALTER ); }
        )
        | <ASSIGN> (
            <PRIVILEGE> { action = astFactory.privilegeAction( ActionType.PRIVILEGE_ASSIGN ); }
            | <ROLE> { action = astFactory.privilegeAction( ActionType.ROLE_ASSIGN ); }
        )
        | <COMPOSITE> <DATABASE> <MANAGEMENT> { action = astFactory.privilegeAction( ActionType.DATABASE_COMPOSITE_MANAGEMENT ); }
        | <DATABASE> <MANAGEMENT> { action = astFactory.privilegeAction( ActionType.DATABASE_MANAGEMENT ); }
        | <ALIAS> <MANAGEMENT> { action = astFactory.privilegeAction( ActionType.ALIAS_MANAGEMENT ); }
        | <EXECUTE> (
            ( <ADMIN> | <ADMINISTRATOR> ) <PROCEDURES> { action = astFactory.privilegeAction( ActionType.EXECUTE_ADMIN_PROCEDURE ); }
            | <BOOSTED> (
                ( <PROCEDURE> | <PROCEDURES> ) qualifier = executeProcedureQualifier(start) { action = astFactory.privilegeAction( ActionType.EXECUTE_BOOSTED_PROCEDURE ); }
                | ( <USER> ( <DEFINED> )? )? ( <FUNCTION> | <FUNCTIONS> ) qualifier = executeFunctionQualifier(start) { action = astFactory.privilegeAction( ActionType.EXECUTE_BOOSTED_FUNCTION ); }
            )
            | ( <PROCEDURE> | <PROCEDURES> ) qualifier = executeProcedureQualifier(start) { action = astFactory.privilegeAction( ActionType.EXECUTE_PROCEDURE ); }
            | ( <USER> ( <DEFINED> )? )? ( <FUNCTION> | <FUNCTIONS> ) qualifier = executeFunctionQualifier(start) { action = astFactory.privilegeAction( ActionType.EXECUTE_FUNCTION ); }
        )
        | <PRIVILEGE> <MANAGEMENT> { action = astFactory.privilegeAction( ActionType.PRIVILEGE_ALL ); }
        | <RENAME> (
            <ROLE> { action = astFactory.privilegeAction( ActionType.ROLE_RENAME ); }
            | <USER> { action = astFactory.privilegeAction( ActionType.USER_RENAME ); }
        )
        | <SERVER> <MANAGEMENT> { action = astFactory.privilegeAction( ActionType.SERVER_MANAGEMENT ); }
        | <USER> <MANAGEMENT> { action = astFactory.privilegeAction( ActionType.USER_ALL ); }
        | <IMPERSONATE> { qualifier = astFactory.allUsersQualifier(); }
            ( <LPAREN> (<TIMES> | qualifiers=SymbolicNameOrStringParameterList() { qualifier = astFactory.userQualifier(qualifiers); } ) <RPAREN> )?
            { action = astFactory.privilegeAction( ActionType.USER_IMPERSONATE ); }
    )
    <ON> <DBMS>
    {
        return astFactory.dbmsPrivilege( pos(start), action, qualifier, immutable );
    }
}

List<PRIVILEGE_QUALIFIER> executeFunctionQualifier(Token start):
{}
{
    {
        return astFactory.functionQualifier(pos(start), globs());
    }
}

List<PRIVILEGE_QUALIFIER> executeProcedureQualifier(Token start):
{}
{
    {
        return astFactory.procedureQualifier(pos(start), globs());
    }
}

List<PRIVILEGE_QUALIFIER> settingQualifier(Token start):
{}
{
    {
        return astFactory.settingQualifier(pos(start), globs());
    }
}

List<String> globs():
{
    List<String> executableList = new ArrayList<>();
    String executableName = null;
}
{
    executableName=Glob()
    {
        executableList.add(executableName);
    }
    (
        <COMMA> executableName=Glob()
        {
            executableList.add(executableName);
        }
    )*
    {
        return executableList;
    }
}

PRIVILEGE_TYPE qualifiedGraphPrivilegesWithProperty(Token start, boolean immutable) throws Exception:
{
    ADMINISTRATION_ACTION action = null;
    GRAPH_SCOPE graph = null;
    List<PRIVILEGE_QUALIFIER> qualifier = null;
    PRIVILEGE_RESOURCE resource = null;
}
{
    (
        <TRAVERSE> { action = astFactory.privilegeAction( ActionType.GRAPH_TRAVERSE ); }
        | ( <READ> { action = astFactory.privilegeAction( ActionType.GRAPH_READ ); } resource=propertyResource() )
        | ( <MATCH> { action = astFactory.privilegeAction( ActionType.GRAPH_MATCH ); } resource=propertyResource() )
    )
    <ON> graph=GraphScope() qualifier=graphQualifier() (<LPAREN> <TIMES> <RPAREN>)?
    {
        return astFactory.graphPrivilege( pos(start), action, graph, resource, qualifier, immutable );
    }
}

PRIVILEGE_TYPE qualifiedGraphPrivileges(Token start, boolean immutable) throws Exception:
{
    ADMINISTRATION_ACTION action = null;
    GRAPH_SCOPE graph = null;
    List<PRIVILEGE_QUALIFIER> qualifier = null;
    PRIVILEGE_RESOURCE resource = null;
}
{
    (
        <DELETE> { action = astFactory.privilegeAction( ActionType.GRAPH_DELETE ); }
        | <MERGE> resource=propertyResource() { action = astFactory.privilegeAction( ActionType.GRAPH_MERGE ); }
    )
    <ON> graph=GraphScope() qualifier=graphQualifier()
    {
        return astFactory.graphPrivilege( pos(start), action, graph, resource, qualifier, immutable );
    }
}

PRIVILEGE_RESOURCE labelResource():
{
    List<String> names = null;
    Token t;
}
{
    <TIMES> { return astFactory.allLabelsResource( pos(token) ); }
    | names=SymbolicNameList1() { return astFactory.labelsResource( pos(token), names ); }
}

PRIVILEGE_RESOURCE propertyResource():
{
    List<String> names = null;
    PRIVILEGE_RESOURCE resource = null;
    Token t;
}
{
    <LCURLY> (
        <TIMES> { resource = astFactory.allPropertiesResource( pos(token) ); }
        | names=SymbolicNameList1() { resource = astFactory.propertiesResource( pos(token), names ); }
    ) <RCURLY>
    {
        return resource;
    }
}

List<PRIVILEGE_QUALIFIER> graphQualifier() throws Exception:
{
    List<PRIVILEGE_QUALIFIER> qualifier = new ArrayList<>();
    Token n = null;
    VARIABLE v = null;
    List<StringPos<POS>> labels = null;
    EXPRESSION propertyRuleExpression = null;
}
{
    (
        (<RELATIONSHIP> | <RELATIONSHIPS>) (
            <TIMES> { qualifier.add( astFactory.allRelationshipsQualifier( pos(token) ) ); }
            | ( n=SymbolicNameString() { qualifier.add( astFactory.relationshipQualifier( pos(n), n.image ) ); } ( <COMMA> n=SymbolicNameString() { qualifier.add( astFactory.relationshipQualifier( pos(n), n.image ) ); } )* )
        )
        | (<NODE> | <NODES>) (
             <TIMES> { qualifier.add( astFactory.allLabelsQualifier( pos(token) ) ); }
             | ( n=SymbolicNameString() { qualifier.add( astFactory.labelQualifier( pos(n), n.image ) ); } ( <COMMA> n=SymbolicNameString() { qualifier.add( astFactory.labelQualifier( pos(n), n.image ) ); } )* )
         )
        | (<ELEMENT> | <ELEMENTS>) (
            <TIMES> { qualifier.add( astFactory.allElementsQualifier( pos(token) ) ); }
            | ( n=SymbolicNameString() { qualifier.add( astFactory.elementQualifier( pos(n), n.image ) ); } ( <COMMA> n=SymbolicNameString() { qualifier.add( astFactory.elementQualifier( pos(n), n.image ) ); } )* )
        )
        | <FOR> <LPAREN> (v=Variable())? (labels=LabelOrRelTypes())?
            (
                LOOKAHEAD(<RPAREN>) <RPAREN> <WHERE> propertyRuleExpression=Expression()
                | LOOKAHEAD(<WHERE>) <WHERE> propertyRuleExpression=Expression() <RPAREN>
                | propertyRuleExpression=MapLiteral() <RPAREN>
            )
            {
    List<PRIVILEGE_QUALIFIER> labelQualifiers = new ArrayList<>();
    if ( labels == null ) {
        labelQualifiers.add(astFactory.allLabelsQualifier( pos(token) ));
    } else {
        for(var label: labels) {
          labelQualifiers.add(astFactory.labelQualifier(label.pos, label.string));
        }
    }
    qualifier.add(astFactory.patternQualifier( labelQualifiers, v, propertyRuleExpression));
}
    )?
    {
        if ( qualifier.isEmpty() ) {
            qualifier.add( astFactory.allElementsQualifier( pos(token) ) );
        }
        return qualifier;
    }
}

// Database commands

ADMINISTRATION_COMMAND CreateDatabase( Token start, boolean replace ) throws Exception:
{
    AliasName<DATABASE_NAME, PARAMETER> databaseName = null;
    boolean ifNotExists = false;
    WAIT_CLAUSE wait = astFactory.wait( false, -1 );
    SimpleEither<Map<String, EXPRESSION>, PARAMETER> options = null;
    Token primaries = null;
    Token secondaries = null;
    Token count = null;
    Token errorStart = null;
    String topologyMultiplePrimaryError = "Duplicate PRIMARY clause";
    String topologyMultipleSecondaryError = "Duplicate SECONDARY clause";
}
{
    <DATABASE> databaseName=SymbolicAliasNameOrParameter()
    ( <IF> <NOT> <EXISTS> { ifNotExists = true; } )?
    ( <TOPOLOGY>
            ( count=<UNSIGNED_DECIMAL_INTEGER>
                (
                    (errorStart=<PRIMARY> | errorStart=<PRIMARIES>){ assertNotAlreadySet(primaries, errorStart, topologyMultiplePrimaryError); }  {primaries = count;}
                    | (errorStart=<SECONDARY> | errorStart=<SECONDARIES>){ assertNotAlreadySet(secondaries, errorStart, topologyMultipleSecondaryError); } {secondaries = count;}
                )
            )+
    )?
    ( options=Options() )?
    ( wait = WaitClause() )?
    {
        return astFactory.createDatabase(
            pos( start ),
            replace, databaseName.getAsDatabaseName(astFactory),
            ifNotExists,
            wait,
            options,
            (primaries != null) ? Integer.parseInt(primaries.image) : null,
            (secondaries != null) ? Integer.parseInt(secondaries.image) : null);
    }
}

SimpleEither<Map<String, EXPRESSION>, PARAMETER> Options() throws Exception:
{
     SimpleEither<Map<String, EXPRESSION>, PARAMETER> options = null;
}
{
    <OPTIONS> options=MapOrParameter()
    {
        return options;
    }
}

ADMINISTRATION_COMMAND CreateCompositeDatabase( Token start, boolean replace ) throws Exception:
{
    AliasName<DATABASE_NAME, PARAMETER> compositeDatabaseName = null;
    SimpleEither<Map<String, EXPRESSION>, PARAMETER> options = null;
    WAIT_CLAUSE wait = astFactory.wait( false, -1 );
    boolean ifNotExists = false;
}
{
    <COMPOSITE> <DATABASE>
    compositeDatabaseName=SymbolicAliasNameOrParameter()
    ( <IF> <NOT> <EXISTS> { ifNotExists = true; } )?
    ( options=Options() )?
    ( wait = WaitClause() )?
    {
       return astFactory.createCompositeDatabase( pos( start ), replace, compositeDatabaseName.getLocalAliasName(astFactory), ifNotExists, options, wait );
    }
}

ADMINISTRATION_COMMAND DropDatabase( Token start ) throws Exception:
{
    AliasName<DATABASE_NAME, PARAMETER> databaseName = null;
    boolean ifExists = false;
    WAIT_CLAUSE wait = astFactory.wait( false, -1 );
    boolean dumpData = false;
    boolean composite = false;
}
{
    ( <COMPOSITE> { composite = true; } )?
    <DATABASE> databaseName=SymbolicAliasNameOrParameter()
    ( <IF> <EXISTS> { ifExists = true; } )?
    ( ( <DUMP> { dumpData = true; } | <DESTROY> ) <DATA> )?
    ( wait = WaitClause() )?
    {
        return astFactory.dropDatabase( pos( start ), databaseName.getLocalAliasName(astFactory), ifExists, composite, dumpData, wait );
    }
}

ADMINISTRATION_COMMAND AlterDatabase( Token start ) throws Exception:
{
    AliasName<DATABASE_NAME, PARAMETER> databaseName = null;
    boolean ifExists = false;
    AccessType accessType = null;
    Token primaries = null;
    Token secondaries = null;
    Token count = null;
    Token set = null;
    Map<String, EXPRESSION> options = null;
    Set<String> optionsToRemove = new LinkedHashSet<>();
    String accessSetError = "Duplicate SET ACCESS clause";
    String topologySetError = "Duplicate SET TOPOLOGY clause";
    Token errorStart = null;
    String topologyMultiplePrimaryError = "Duplicate PRIMARY clause";
    String topologyMultipleSecondaryError = "Duplicate SECONDARY clause";
    Token key = null;
    Token remove = null;
    EXPRESSION value = null;
    WAIT_CLAUSE wait = astFactory.wait( false, -1 );
}
{
    <DATABASE>
    databaseName=SymbolicAliasNameOrParameter()
    ( <IF> <EXISTS> { ifExists = true; } )?
    (
      (set=<SET> (
        <ACCESS> { assertNotAlreadySet( accessType, set, accessSetError); }
            <READ> ( <ONLY> { accessType = AccessType.READ_ONLY; } | <WRITE> { accessType = AccessType.READ_WRITE; })
        | <TOPOLOGY>
            { assertNotAlreadySet(count, set, topologySetError ); }
            ( count=<UNSIGNED_DECIMAL_INTEGER>
                (
                    (errorStart=<PRIMARY> | errorStart=<PRIMARIES>){ assertNotAlreadySet(primaries, errorStart, topologyMultiplePrimaryError); }  {primaries = count;}
                    | (errorStart=<SECONDARY> | errorStart=<SECONDARIES>){ assertNotAlreadySet(secondaries, errorStart, topologyMultipleSecondaryError); } {secondaries = count;}
                )
            )+
        | <OPTION> key=SymbolicNameString() value=Expression() {
            if (options == null) {
                options = new LinkedHashMap<>();
            }
            assertNotAlreadySet(options.getOrDefault(key.image, null), set, "Duplicate 'SET OPTION " + key.image + "' clause");
            options.put(key.image, value);
        }
      ))+ |
      (remove=<REMOVE> (
        <OPTION> key=SymbolicNameString() {
            String entryOrNull = optionsToRemove.contains(key.image) ? key.image : null;
            assertNotAlreadySet(entryOrNull, remove, "Duplicate 'REMOVE OPTION " + key.image + "' clause");
            optionsToRemove.add(key.image);
        }
      ))+
    )
    ( wait=WaitClause() )?
    {
        return astFactory.alterDatabase(
            pos( start ),
            databaseName.getLocalAliasName(astFactory),
            ifExists,
            accessType,
            (primaries != null) ? Integer.parseInt(primaries.image) : null,
            (secondaries != null) ? Integer.parseInt(secondaries.image) : null,
            options,
            optionsToRemove,
            wait);
    }
}

ADMINISTRATION_COMMAND StartDatabase() throws Exception:
{
    Token start;
    AliasName<DATABASE_NAME, PARAMETER> databaseName;
    WAIT_CLAUSE wait = astFactory.wait( false, -1 );
}
{
    start=<START> <DATABASE> databaseName=SymbolicAliasNameOrParameter() ( wait=WaitClause() )?
    {
      return astFactory.startDatabase( pos( start ), databaseName.getLocalAliasName(astFactory), wait );
    }
}

ADMINISTRATION_COMMAND StopDatabase() throws Exception:
{
    Token start;
    AliasName<DATABASE_NAME, PARAMETER> databaseName;
    WAIT_CLAUSE wait = astFactory.wait( false, -1 );
}
{
    start=<STOP> <DATABASE> databaseName=SymbolicAliasNameOrParameter() ( wait=WaitClause() )?
    {
      return astFactory.stopDatabase( pos( start ), databaseName.getLocalAliasName(astFactory), wait );
    }
}

WAIT_CLAUSE WaitClause():
{
    Token number = null;
    boolean wait = false;
}
{
    (
        <WAIT> { wait = true; } ( number=<UNSIGNED_DECIMAL_INTEGER> ( <SEC> | <SECOND> | <SECONDS> )? )?
        | <NOWAIT>
    )
    {
        if ( number != null )
        {
            return astFactory.wait( wait, Long.parseLong( number.image) );
        }
        return astFactory.wait( wait, -1 ) ;
    }
}

STATEMENT_WITH_GRAPH ShowDatabase( Token start, USE_CLAUSE useClause ) throws Exception:
{
    Token scopeStart = null;
    AliasName<DATABASE_NAME, PARAMETER> name = null;
    boolean isDefault = false;
    boolean isHome = false;
    DATABASE_SCOPE scope;
    YIELD yield = null;
    RETURN_CLAUSE returnClause = null;
    WHERE where = null;
}
{
    // Due to allowing both DATABASE and DATABASES with and without name we need to lookahead for potential YIELD/WHERE to not consider those database names
   (
        (scopeStart=<DATABASES> | scopeStart=<DATABASE>) (
            LOOKAHEAD(SymbolicAliasNameOrParameter() (WhereClause() | YieldClause())) name=SymbolicAliasNameOrParameter() (
                ( yield = YieldClause() ( returnClause = ReturnClause() )? )
                | ( where=WhereClause() )
            )
            | LOOKAHEAD(YieldClause()) yield=YieldClause() ( returnClause=ReturnClause() ) ?
            | LOOKAHEAD(WhereClause()) where=WhereClause()
            | name=SymbolicAliasNameOrParameter()
        )?
        | (scopeStart=<DEFAULT_TOKEN> <DATABASE> { isDefault = true; }
            | scopeStart=<HOME> <DATABASE> { isHome = true; }
          )(
              ( yield = YieldClause() ( returnClause = ReturnClause() )? )
              | ( where=WhereClause() )
          )?
   )
   {
        scope = astFactory.databaseScope( pos( scopeStart ), name == null ? null : name.getLocalAliasName(astFactory), isDefault, isHome );
        return astFactory.useGraph( astFactory.showDatabase( pos( start ), scope, yield, returnClause, where), useClause );
   }
}

DATABASE_SCOPE DatabaseScope() throws Exception:
{
    Token start = null;
    List<DATABASE_NAME> names = null;
    ScopeType type = ScopeType.NAMED;
}
{
    (
        (start=<DATABASE> | start=<DATABASES>) (<TIMES> { type = ScopeType.ALL; } | names=SymbolicAliasNameList())
        | start=<DEFAULT_TOKEN> <DATABASE> { type = ScopeType.DEFAULT; }
        | start=<HOME> <DATABASE> { type = ScopeType.HOME; }
    )
  {
    return astFactory.databaseScope( pos( start ), names, type );
  }
}

GRAPH_SCOPE GraphScope() throws Exception:
{
    Token start = null;
    List<DATABASE_NAME> names = null;
    ScopeType type = ScopeType.NAMED;
}
{
    (
        (start=<GRAPH> | start=<GRAPHS>) (<TIMES> { type = ScopeType.ALL; } | names=SymbolicAliasNameList() )
        | start=<DEFAULT_TOKEN> <GRAPH> { type = ScopeType.DEFAULT; }
        | start=<HOME> <GRAPH> { type = ScopeType.HOME; }
    )
    {
        return astFactory.graphScope( pos( start ), names, type );
    }
}

ADMINISTRATION_COMMAND CreateAlias( Token start, boolean replace ) throws Exception:
{
    AliasName<DATABASE_NAME, PARAMETER> aliasName = null;
    AliasName<DATABASE_NAME, PARAMETER> targetName = null;
    boolean ifNotExists = false;
    SimpleEither<String, PARAMETER> url = null;
    SimpleEither<StringPos<POS>, PARAMETER> username = null;
    EXPRESSION password = null;
    SimpleEither<Map<String, EXPRESSION>, PARAMETER> driverSettings = null;
    SimpleEither<Map<String, EXPRESSION>, PARAMETER> properties = null;
}
{
    <ALIAS>
    aliasName=SymbolicAliasNameOrParameter()
    ( <IF> <NOT> <EXISTS> { ifNotExists = true; } )?
    <FOR> <DATABASE> targetName=SymbolicAliasNameOrParameter()
    (
        <AT> url=StringOrParameter()
        <USER> username=SymbolicNameOrStringParameter()
        <PASSWORD> password=passwordExpression()
        ( <DRIVER> driverSettings=MapOrParameter() )?
    )?
    ( <PROPERTIES> properties=MapOrParameter() )?
    {
       if ( url == null )
       {
           return astFactory.createLocalDatabaseAlias( pos( start ), replace, aliasName.getLocalAliasName(astFactory), targetName.getLocalAliasName(astFactory), ifNotExists, properties );
       }
       else
       {
           return astFactory.createRemoteDatabaseAlias( pos( start ), replace, aliasName.getRemoteAliasName(astFactory), targetName.getLocalAliasName(astFactory), ifNotExists, url, username, password, driverSettings, properties );
       }
    }
}

ADMINISTRATION_COMMAND DropAlias( Token start ) throws Exception:
{
    AliasName<DATABASE_NAME, PARAMETER> aliasName = null;
    boolean ifExists = false;
}
{
    <ALIAS> aliasName=SymbolicAliasNameOrParameter()
    (<IF> <EXISTS> { ifExists = true; })?
    <FOR> <DATABASE>
    {
        return astFactory.dropAlias( pos( start ), aliasName.getLocalAliasName(astFactory), ifExists );
    }
}


ADMINISTRATION_COMMAND AlterAlias( Token start ) throws Exception:
{
    AliasName<DATABASE_NAME, PARAMETER> aliasName = null;
    AliasName<DATABASE_NAME, PARAMETER> targetName = null;
    boolean ifExists = false;
    SimpleEither<String, PARAMETER> url = null;
    SimpleEither<StringPos<POS>, PARAMETER> username = null;
    EXPRESSION password = null;
    SimpleEither<Map<String, EXPRESSION>, PARAMETER> driverSettings = null;
    SimpleEither<Map<String, EXPRESSION>, PARAMETER> properties = null;
    Token errorStart = null;
    String alreadySet = "Duplicate SET DATABASE %s clause";
}
{
    <ALIAS> aliasName=SymbolicAliasNameOrParameter()
    (<IF> <EXISTS> { ifExists = true; })?
    <SET> <DATABASE>
    (
        errorStart=<TARGET> { assertNotAlreadySet( targetName, errorStart, String.format(alreadySet, errorStart.image) ); } targetName=SymbolicAliasNameOrParameter()  ( <AT> url=StringOrParameter() )?
        | errorStart=<USER> { assertNotAlreadySet( username, errorStart, String.format(alreadySet, errorStart.image) ); } username=SymbolicNameOrStringParameter()
        | errorStart=<PASSWORD> { assertNotAlreadySet( password, errorStart, String.format(alreadySet, errorStart.image) ); } password=passwordExpression()
        | errorStart=<DRIVER> { assertNotAlreadySet( driverSettings, errorStart, String.format(alreadySet, errorStart.image) ); } driverSettings=MapOrParameter()
        | errorStart=<PROPERTIES> { assertNotAlreadySet( properties, errorStart, String.format(alreadySet, errorStart.image) ); } properties=MapOrParameter()
    )+
    {
        if ( url == null && username == null && password == null && driverSettings == null )
        {
            return astFactory.alterLocalDatabaseAlias( pos( start ), aliasName.getLocalAliasName(astFactory), targetName == null ? null : targetName.getLocalAliasName(astFactory), ifExists, properties );
        }
        else
        {
            return astFactory.alterRemoteDatabaseAlias( pos( start ), aliasName.getRemoteAliasName(astFactory), targetName == null ? null : targetName.getRemoteAliasName(astFactory),
                ifExists, url, username, password, driverSettings, properties );
        }
    }
}

STATEMENT ShowAliases( Token start, USE_CLAUSE useClause ) throws Exception:
{
    AliasName<DATABASE_NAME, PARAMETER> aliasName = null;
    WHERE where = null;
    YIELD yieldClause = null;
    RETURN_CLAUSE returnClause = null;
}
{
    ( <ALIAS> | <ALIASES> )
    ( LOOKAHEAD(SymbolicAliasNameOrParameter() <FOR>) aliasName=SymbolicAliasNameOrParameter() )?
    ( <FOR> ( <DATABASE> | <DATABASES> ))
    (
        ( yieldClause=YieldClause() ( returnClause=ReturnClause() )? )
        | where=WhereClause()
    )?
    {
        DATABASE_NAME maybeAliasName = aliasName == null ? null : aliasName.getLocalAliasName(astFactory);
        return astFactory.useGraph( astFactory.showAliases( pos( start ), maybeAliasName, yieldClause, returnClause, where), useClause );
    }
}

List<DATABASE_NAME> SymbolicAliasNameList() throws Exception:
{
    AliasName<DATABASE_NAME, PARAMETER> dbSymbol = null;
    List<DATABASE_NAME> databases = new ArrayList<>();
}
{
    dbSymbol=SymbolicAliasNameOrParameter() { databases.add(dbSymbol.getLocalAliasName(astFactory)); }
    (<COMMA> dbSymbol=SymbolicAliasNameOrParameter() { databases.add(dbSymbol.getLocalAliasName(astFactory)); } )*
    {
        return databases;
    }
}

AliasName<DATABASE_NAME, PARAMETER> SymbolicAliasNameOrParameter() throws Exception:
{
    AliasName<DATABASE_NAME, PARAMETER> name = null;
    PARAMETER parameter;
}
{
    name=SymbolicAliasName() { return name; }
    | parameter=Parameter(ParameterType.STRING) { return new AliasName<DATABASE_NAME, PARAMETER>( exceptionFactory, parameter ); }
}

AliasName<DATABASE_NAME, PARAMETER> SymbolicAliasName() throws Exception:
{
    Token token;
    AliasName<DATABASE_NAME, PARAMETER> name = null;
}
{
    token=SymbolicNameString() { name = new AliasName<DATABASE_NAME, PARAMETER>( exceptionFactory, token ); }
        ( <DOT> token=SymbolicNameString() { name.add( token ); } )*
        {
            return name;
        }
}

List<SimpleEither<StringPos<POS>, PARAMETER>> SymbolicNameOrStringParameterList() :
{
    SimpleEither<StringPos<POS>, PARAMETER> entry;
    List<SimpleEither<StringPos<POS>, PARAMETER>> list = new ArrayList<>();
}
{
    entry=SymbolicNameOrStringParameter() { list.add( entry ); }
    ( <COMMA> entry=SymbolicNameOrStringParameter() { list.add( entry ); } )*
    {
        return list;
    }
}

SimpleEither<StringPos<POS>, PARAMETER> SymbolicNameOrStringParameter():
{
    Token name;
    PARAMETER parameter;
}
{
    name=SymbolicNameString() { return SimpleEither.<StringPos<POS>, PARAMETER>left( new StringPos<POS>( token.image, pos( token ), endPos( token ) )); }
    | parameter=Parameter(ParameterType.STRING) { return SimpleEither.<StringPos<POS>, PARAMETER>right( parameter ); }
}

String Glob() :
{
    String globString = "";
    String nextGlob = "";
    Token t = null;
}
{
    (
       // The whole glob is escaped
        LOOKAHEAD(EscapedSymbolicNameString() (<COMMA> | (<ON> <DBMS> (<TO> | <FROM>) SymbolicNameOrStringParameterList() <EOF>)))
            t=EscapedSymbolicNameString() { globString = t.image; }

        // The first part of the glob is escaped. The escaped part must be followed by a dot.
        | LOOKAHEAD(EscapedSymbolicNameString() <DOT>)
            t=EscapedSymbolicNameString() { globString = t.image; }
            nextGlob=GlobRecursive()  { globString += nextGlob; }

        // The glob starts with an unescaped part
        | globString=GlobRecursive()
    )
    {
        return globString;
    }
}

String GlobRecursive() :
{
    String globString = "";
    String nextGlob = "";
}
{
    (
        // The last part of the glob => stop recursion
        LOOKAHEAD(GlobPart() (<COMMA> | (<ON> <DBMS> (<TO> | <FROM>) SymbolicNameOrStringParameterList() <EOF>))) globString=GlobPart()

        // The glob consist of multiple parts => continue recursion
        | globString=GlobPart() nextGlob=GlobRecursive() { globString += nextGlob; }
    )
    {
        return globString;
    }
}

String GlobPart() :
{
    String globPartString = null;
    Token globPart = null;
}
{
    (
        // Unless the escaped part is the whole glob or the first part of the glob (both which are covered in Glob()),
        // it must be preceded by a dot and either be followed by a dot or be the last part of the glob.
        LOOKAHEAD(<DOT> EscapedSymbolicNameString() (<DOT> | <COMMA> | (<ON> <DBMS> (<TO> | <FROM>) SymbolicNameOrStringParameterList() <EOF>)))
            <DOT> globPart=EscapedSymbolicNameString() { globPartString = "." + globPart.image; }

        | <QUESTION> { globPartString = "?"; }
        | <TIMES> { globPartString = "*"; }
        | <DOT> { globPartString = "."; }
        | globPart = UnescapedSymbolicNameString() { globPartString = globPart.image; }
    )
    {
        return globPartString;
    }
}

String StringImage():
{
    Token t;
}
{
    t=StringToken() { return token.image; }
}

List<String> StringList():
{
    String entry;
    List<String> list = new ArrayList<>();
}
{
    entry=StringImage() { list.add( entry ); }
    ( <COMMA> entry=StringImage() { list.add( entry ); } )*
    {
        return list;
    }
}

Token StringToken():
{
   Token stringLiteral = null;
}
{
    (
        stringLiteral=<STRING_LITERAL1>
        | stringLiteral=<STRING_LITERAL2>
    )
    {
        return stringLiteral;
    }
}

SimpleEither<String, PARAMETER> StringOrParameter():
{
    Token token = null;
    PARAMETER parameter = null;
}
{
    token=StringToken() { return SimpleEither.<String, PARAMETER>left( token.image ); }
    | parameter=Parameter( ParameterType.STRING ) { return SimpleEither.<String, PARAMETER>right( parameter ); }
}

SimpleEither<Map<String, EXPRESSION>, PARAMETER> MapOrParameter() throws Exception:
{
    Map<String, EXPRESSION> map = null;
    PARAMETER parameter;
}
{
    map=Map() { return SimpleEither.<Map<String,EXPRESSION>,PARAMETER>left ( map ); }
    | parameter=Parameter( ParameterType.MAP ) { return SimpleEither.<Map<String,EXPRESSION>,PARAMETER>right( parameter ); }
}

Map<String, EXPRESSION> Map()  throws Exception:
{
    Token key;
    EXPRESSION expr;
    LinkedHashMap<String, EXPRESSION> map = new LinkedHashMap<>();
}
{
    <LCURLY>
    (
        key=SymbolicNameString()  <COLON> expr=Expression() { map.put( key.image, expr ); }
        ( <COMMA> key=SymbolicNameString()  <COLON> expr=Expression() { map.put( key.image, expr ); } )*
    )?
    <RCURLY>
    {
        return map;
    }
}

List<StringPos<POS>> SymbolicNamePositions():
{
    List<StringPos<POS>> names = new ArrayList<>();
}
{
    SymbolicNameString() { names.add( new StringPos<>( token.image, pos( token ) ) ); }
    ( <COMMA> SymbolicNameString() { names.add( new StringPos<>( token.image, pos( token ) ) ); } )*
    {
        return names;
    }
}

Token SymbolicNameString() :
{
    Token t;
}
{
    (
        t=EscapedSymbolicNameString()
        | t=UnescapedSymbolicNameString()
    )
    {
        return t;
    }
}

Token EscapedSymbolicNameString() :
{
    Token t;
}
{
    (
       t=<ESCAPED_SYMBOLIC_NAME>
    )
    {
        return t;
    }
}

Token UnescapedSymbolicNameString() :
{
    Token t;
}
{
    (
        t=UnescapedLabelSymbolicNameString()

        //list of additionally allowed keywords
        | t=<NOT>
        | t=<NULL>
        | t=<TYPED>
        | t=<NORMALIZED>
        | t=<NFC>
        | t=<NFD>
        | t=<NFKC>
        | t=<NFKD>
    )
    {
        return t;
    }
}

//used for IS
Token SymbolicLabelNameString() :
{
    Token t;
}
{
    (
        t=EscapedSymbolicNameString()
        | t=UnescapedLabelSymbolicNameString()
    )
    {
        return t;
    }
}

Token UnescapedLabelSymbolicNameString() :
{
    Token t;
}
{
    (
        t=<IDENTIFIER>

        //list of allowed keywords
        | t=<ACCESS>
        | t=<ACTIVE>
        | t=<ADMIN>
        | t=<ADMINISTRATOR>
        | t=<ALIAS>
        | t=<ALIASES>
        | t=<ALL_SHORTEST_PATH>
        | t=<ALL>
        | t=<ALTER>
        | t=<AND>
        | t=<ANY>
        | t=<ARRAY>
        | t=<AS>
        | t=<ASC>
        | t=<ASCENDING>
        | t=<ASSERT>
        | t=<ASSIGN>
        | t=<AT>
        | t=<AUTH>
        | t=<BINDINGS>
        | t=<BOOL>
        | t=<BOOLEAN>
        | t=<BOOSTED>
        | t=<BOTH>
        | t=<BREAK>
        | t=<BRIEF>
        | t=<BTREE>
        | t=<BUILT>
        | t=<BY>
        | t=<CALL>
        | t=<CASE>
        | t=<CHANGE>
        | t=<CIDR>
        | t=<COLLECT>
        | t=<COMMAND>
        | t=<COMMANDS>
        | t=<COMMIT>
        | t=<COMPOSITE>
        | t=<CONCURRENT>
        | t=<CONSTRAINT>
        | t=<CONSTRAINTS>
        | t=<CONTAINS>
        | t=<CONTINUE>
        | t=<COPY>
        | t=<COUNT>
        | t=<CREATE>
        | t=<CSV>
        | t=<CURRENT>
        | t=<DATA>
        | t=<DATABASE>
        | t=<DATABASES>
        | t=<DATE>
        | t=<DATETIME>
        | t=<DBMS>
        | t=<DEALLOCATE>
        | t=<DEFAULT_TOKEN>
        | t=<DEFINED>
        | t=<DELETE>
        | t=<DENY>
        | t=<DESC>
        | t=<DESCENDING>
        | t=<DESTROY>
        | t=<DETACH>
        | t=<DIFFERENT>
        | t=<DISTINCT>
        | t=<DRIVER>
        | t=<DROP>
        | t=<DRYRUN>
        | t=<DUMP>
        | t=<DURATION>
        | t=<EACH>
        | t=<EDGE>
        | t=<ELEMENT>
        | t=<ELEMENTS>
        | t=<ELSE>
        | t=<ENABLE>
        | t=<ENCRYPTED>
        | t=<END>
        | t=<ENDS>
        | t=<ERROR>
        | t=<EXECUTABLE>
        | t=<EXECUTE>
        | t=<EXIST>
        | t=<EXISTENCE>
        | t=<EXISTS>
        | t=<FAIL>
        | t=<FALSE>
        | t=<FIELDTERMINATOR>
        | t=<FINISH>
        | t=<FLOAT>
        | t=<FOREACH>
        | t=<FOR>
        | t=<FROM>
        | t=<FULLTEXT>
        | t=<FUNCTION>
        | t=<FUNCTIONS>
        | t=<GRANT>
        | t=<GRAPH>
        | t=<GRAPHS>
        | t=<GROUP>
        | t=<GROUPS>
        | t=<HEADERS>
        | t=<HOME>
        | t=<ID>
        | t=<IF>
        | t=<IMMUTABLE>
        | t=<IN>
        | t=<INDEX>
        | t=<INDEXES>
        | t=<INF>
        | t=<INFINITY>
        | t=<INSERT>
        | t=<INT>
        | t=<INTEGER>
        | t=<IMPERSONATE>
        | t=<IS>
        | t=<JOIN>
        | t=<KEY>
        | t=<LABEL>
        | t=<LABELS>
        | t=<LEADING>
        | t=<LIMITROWS>
        | t=<LIST>
        | t=<LOAD>
        | t=<LOCAL>
        | t=<LOOKUP>
        | t=<MATCH>
        | t=<MANAGEMENT>
        | t=<MAP>
        | t=<MERGE>
        | t=<NAME>
        | t=<NAMES>
        | t=<NAN>
        | t=<NEW>
        | t=<NODE>
        | t=<NODETACH>
        | t=<NODES>
        | t=<NONE>
        | t=<NORMALIZE>
        | t=<NOTHING>
        | t=<NOWAIT>
        | t=<OF>
        | t=<ON>
        | t=<ONLY>
        | t=<OPTIONAL>
        | t=<OPTIONS>
        | t=<OPTION>
        | t=<OR>
        | t=<ORDER>
        | t=<OUTPUT>
        | t=<PASSWORD>
        | t=<PASSWORDS>
        | t=<PATH>
        | t=<PATHS>
        | t=<PERIODIC>
        | t=<PLAINTEXT>
        | t=<POINT>
        | t=<POPULATED>
        | t=<PRIMARY>
        | t=<PRIMARIES>
        | t=<PRIVILEGE>
        | t=<PRIVILEGES>
        | t=<PROCEDURE>
        | t=<PROCEDURES>
        | t=<PROPERTIES>
        | t=<PROPERTY>
        | t=<PROVIDER>
        | t=<PROVIDERS>
        | t=<RANGE>
        | t=<READ>
        | t=<REALLOCATE>
        | t=<REDUCE>
        | t=<REL>
        | t=<RELATIONSHIP>
        | t=<RELATIONSHIPS>
        | t=<REMOVE>
        | t=<RENAME>
        | t=<REPEATABLE>
        | t=<REPLACE>
        | t=<REPORT>
        | t=<REQUIRE>
        | t=<REQUIRED>
        | t=<RETURN>
        | t=<REVOKE>
        | t=<ROLE>
        | t=<ROLES>
        | t=<ROW>
        | t=<ROWS>
        | t=<SCAN>
        | t=<SEC>
        | t=<SECOND>
        | t=<SECONDARY>
        | t=<SECONDARIES>
        | t=<SECONDS>
        | t=<SEEK>
        | t=<SERVER>
        | t=<SERVERS>
        | t=<SET>
        | t=<SETTING>
        | t=<SETTINGS>
        | t=<SHORTEST>
        | t=<SHORTEST_PATH>
        | t=<SHOW>
        | t=<SIGNED>
        | t=<SINGLE>
        | t=<SKIPROWS>
        | t=<START>
        | t=<STARTS>
        | t=<STATUS>
        | t=<STOP>
        | t=<STRING>
        | t=<SUPPORTED>
        | t=<SUSPENDED>
        | t=<TARGET>
        | t=<TERMINATE>
        | t=<TEXT>
        | t=<THEN>
        | t=<TIME>
        | t=<TIMESTAMP>
        | t=<TIMEZONE>
        | t=<TO>
        | t=<TOPOLOGY>
        | t=<TRAILING>
        | t=<TRANSACTION>
        | t=<TRANSACTIONS>
        | t=<TRAVERSE>
        | t=<TRIM>
        | t=<TRUE>
        | t=<TYPE>
        | t=<TYPES>
        | t=<UNION>
        | t=<UNIQUE>
        | t=<UNIQUENESS>
        | t=<UNWIND>
        | t=<URL>
        | t=<USE>
        | t=<USER>
        | t=<USERS>
        | t=<USING>
        | t=<VALUE>
        | t=<VARCHAR>
        | t=<VECTOR>
        | t=<VERBOSE>
        | t=<VERTEX>
        | t=<WAIT>
        | t=<WHEN>
        | t=<WHERE>
        | t=<WITH>
        | t=<WITHOUT>
        | t=<WRITE>
        | t=<XOR>
        | t=<YIELD>
        | t=<ZONED>
    )
    {

        if (DeprecatedChars.containsDeprecatedChar(t.image)) {
            for (var depChar : DeprecatedChars.deprecatedChars(t.image)) {
                astFactory.addDeprecatedIdentifierUnicodeNotification(pos(t), (char) depChar, t.image);
            }
        }
        return t;
    }
}

// used in tests
void EndOfFile() :
{}
{
    <EOF>
}
